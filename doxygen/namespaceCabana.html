<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cabana: Cabana Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cabana
   &#160;<span id="projectnumber">1.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Cabana Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Core: particle data structures and algorithms.  
<a href="namespaceCabana.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array-of-Struct-of-Arrays.  <a href="classCabana_1_1AoSoA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__aosoa__impl.html">is_aosoa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__aosoa__impl_3_01AoSoA_3_01DataTypes_00_01DeviceType_00_01VectorLength_00_01MemoryTraits_01_4_01_4.html">is_aosoa_impl&lt; AoSoA&lt; DataTypes, DeviceType, VectorLength, MemoryTraits &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html">CommunicationPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Communication plan base class.  <a href="classCabana_1_1CommunicationPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Distributor.html">Distributor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1Distributor.html" title="Distributor is a communication plan for migrating data from one uniquely-owned decomposition to anoth...">Distributor</a> is a communication plan for migrating data from one uniquely-owned decomposition to another uniquely owned decomposition.  <a href="classCabana_1_1Distributor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__distributor__impl.html">is_distributor_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__distributor__impl_3_01Distributor_3_01DeviceType_01_4_01_4.html">is_distributor_impl&lt; Distributor&lt; DeviceType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1SimdPolicy.html">SimdPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution policy over a range of 2d indices.  <a href="classCabana_1_1SimdPolicy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01Experimental_1_1CrsGraph_3_01MemorySpace_00_01Tag_01_4_01_4.html">NeighborList&lt; Experimental::CrsGraph&lt; MemorySpace, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01Experimental_1_1Dense_3_01MemorySpace_00_01Tag_01_4_01_4.html">NeighborList&lt; Experimental::Dense&lt; MemorySpace, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Halo.html">Halo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1Halo.html" title="Halo communication plan for scattering and gathering of ghosted data.">Halo</a> communication plan for scattering and gathering of ghosted data.  <a href="classCabana_1_1Halo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__halo__impl.html">is_halo_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__halo__impl_3_01Halo_3_01DeviceType_01_4_01_4.html">is_halo_impl&lt; Halo&lt; DeviceType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__halo.html">is_halo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1LinkedCellList.html">LinkedCellList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesian grid.  <a href="classCabana_1_1LinkedCellList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__linked__cell__list__impl.html">is_linked_cell_list_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__linked__cell__list__impl_3_01LinkedCellList_3_01DeviceType_01_4_01_4.html">is_linked_cell_list_impl&lt; LinkedCellList&lt; DeviceType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1MemberTypes.html">MemberTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General sequence of types for <a class="el" href="structCabana_1_1SoA.html">SoA</a> and <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> member data.  <a href="structCabana_1_1MemberTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__member__types__impl.html">is_member_types_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__member__types__impl_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html">is_member_types_impl&lt; MemberTypes&lt; Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__member__types.html">is_member_types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1MemberTypeAtIndexImpl.html">MemberTypeAtIndexImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1MemberTypeAtIndexImpl_3_010_00_01T_00_01Types_8_8_8_01_4.html">MemberTypeAtIndexImpl&lt; 0, T, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1MemberTypeAtIndex.html">MemberTypeAtIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the member at a given index.  <a href="structCabana_1_1MemberTypeAtIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1MemberTypeAtIndex_3_01M_00_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html">MemberTypeAtIndex&lt; M, MemberTypes&lt; Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1CheckMemberTypesImpl.html">CheckMemberTypesImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1CheckMemberTypesImpl_3_010_00_01T_00_01Types_8_8_8_01_4.html">CheckMemberTypesImpl&lt; 0, T, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1CheckMemberTypes.html">CheckMemberTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that member types are valied.  <a href="structCabana_1_1CheckMemberTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1CheckMemberTypes_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html">CheckMemberTypes&lt; MemberTypes&lt; Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1FullNeighborTag.html">FullNeighborTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for full neighbor lists.  <a href="classCabana_1_1FullNeighborTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1HalfNeighborTag.html">HalfNeighborTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for half neighbor lists.  <a href="classCabana_1_1HalfNeighborTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList.html">NeighborList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor list interface. Provides an interface callable at the functor level that gives access to neighbor data for particles.  <a href="classCabana_1_1NeighborList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over particle neighbors.  <a href="classCabana_1_1FirstNeighborsTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over particle neighbors (first) and neighbor's neighbors (second)  <a href="classCabana_1_1SecondNeighborsTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor operations are executed in serial on each particle thread.  <a href="classCabana_1_1SerialOpTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor operations are executed with team parallelism.  <a href="classCabana_1_1TeamOpTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor operations are executed with team vector parallelism.  <a href="classCabana_1_1TeamVectorOpTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1PackTypeAtIndexImpl.html">PackTypeAtIndexImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1PackTypeAtIndexImpl_3_010_00_01T_00_01Types_8_8_8_01_4.html">PackTypeAtIndexImpl&lt; 0, T, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1PackTypeAtIndex.html">PackTypeAtIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1ParameterPackElement.html">ParameterPackElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1ParameterPackImpl.html">ParameterPackImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1ParameterPackImpl_3_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_00_01Types_8_8_8_01_4.html">ParameterPackImpl&lt; std::index_sequence&lt; Indices... &gt;, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1ParameterPack.html">ParameterPack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__parameter__pack__impl.html">is_parameter_pack_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__parameter__pack__impl_3_01ParameterPack_3_01Types_8_8_8_01_4_01_4.html">is_parameter_pack_impl&lt; ParameterPack&lt; Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__parameter__pack.html">is_parameter_pack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Slice.html">Slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.  <a href="classCabana_1_1Slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__slice__impl.html">is_slice_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__slice__impl_3_01Slice_3_01DataType_00_01DeviceType_00_01MemoryAccessType_00_0a6758996348b9244b7f68ff7e7b91f9.html">is_slice_impl&lt; Slice&lt; DataType, DeviceType, MemoryAccessType, VectorLength, Stride &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__slice.html">is_slice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1SoA.html">SoA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__soa__impl.html">is_soa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__soa__impl_3_01SoA_3_01DataTypes_00_01VectorLength_01_4_01_4.html">is_soa_impl&lt; SoA&lt; DataTypes, VectorLength &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__soa.html">is_soa</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1SoA_3_01MemberTypes_3_01Types_8_8_8_01_4_00_01VectorLength_01_4.html">SoA&lt; MemberTypes&lt; Types... &gt;, VectorLength &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct-of-Arrays.  <a href="structCabana_1_1SoA_3_01MemberTypes_3_01Types_8_8_8_01_4_00_01VectorLength_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data describing the bin sizes and offsets resulting from a binning operation.  <a href="classCabana_1_1BinningData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__binning__data.html">is_binning_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__binning__data_3_01BinningData_3_01DeviceType_01_4_01_4.html">is_binning_data&lt; BinningData&lt; DeviceType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__binning__data_3_01const_01BinningData_3_01DeviceType_01_4_01_4.html">is_binning_data&lt; const BinningData&lt; DeviceType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1Tuple.html">Tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__tuple__impl.html">is_tuple_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__tuple__impl_3_01Tuple_3_01DataTypes_01_4_01_4.html">is_tuple_impl&lt; Tuple&lt; DataTypes &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1Tuple_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html">Tuple&lt; MemberTypes&lt; Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Tuple.html">Tuple</a>.  <a href="structCabana_1_1Tuple_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag.html">is_memory_access_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1DefaultAccessMemory.html">DefaultAccessMemory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag_3_01DefaultAccessMemory_01_4.html">is_memory_access_tag&lt; DefaultAccessMemory &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1RandomAccessMemory.html">RandomAccessMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access memory. Read-only and const with limited spatial locality.  <a href="structCabana_1_1RandomAccessMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag_3_01RandomAccessMemory_01_4.html">is_memory_access_tag&lt; RandomAccessMemory &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1AtomicAccessMemory.html">AtomicAccessMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic memory access. All reads and writes are atomic.  <a href="structCabana_1_1AtomicAccessMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag_3_01AtomicAccessMemory_01_4.html">is_memory_access_tag&lt; AtomicAccessMemory &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__accessible__from.html">is_accessible_from</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__accessible__from_3_01MemorySpace_00_01ExecutionSpace_00_01std_1_1enable__if_96534d0f81e01b006272bb63cf2f3dd3.html">is_accessible_from&lt; MemorySpace, ExecutionSpace, std::enable_if_t&lt; Kokkos::SpaceAccessibility&lt; ExecutionSpace, MemorySpace &gt;::accessible &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletLayoutCSR.html">VerletLayoutCSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSR (compressed sparse row) neighbor list layout.  <a href="structCabana_1_1VerletLayoutCSR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletLayout2D.html">VerletLayout2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D array neighbor list layout.  <a href="structCabana_1_1VerletLayout2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletListData.html">VerletListData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletListData_3_01DeviceType_00_01VerletLayoutCSR_01_4.html">VerletListData&lt; DeviceType, VerletLayoutCSR &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletListData_3_01DeviceType_00_01VerletLayout2D_01_4.html">VerletListData&lt; DeviceType, VerletLayout2D &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1VerletList.html">VerletList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor list implementation based on binning particles on a 3d Cartesian grid with cells of the same size as the interaction distance.  <a href="classCabana_1_1VerletList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01VerletLayoutCSR_00_01BuildTag_01_4_01_4.html">NeighborList&lt; VerletList&lt; MemorySpace, AlgorithmTag, VerletLayoutCSR, BuildTag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01VerletLayout2D_00_01BuildTag_01_4_01_4.html">NeighborList&lt; VerletList&lt; MemorySpace, AlgorithmTag, VerletLayout2D, BuildTag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad6d068692acbf0642e84ce1f94b677c9"><td class="memTemplParams" colspan="2"><a id="ad6d068692acbf0642e84ce1f94b677c9"></a>
template&lt;std::size_t M, class AoSoA_t &gt; </td></tr>
<tr class="memitem:ad6d068692acbf0642e84ce1f94b677c9"><td class="memTemplItemLeft" align="right" valign="top">AoSoA_t::template member_slice_type&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>slice</b> (const AoSoA_t &amp;aosoa, const std::string &amp;slice_label=&quot;&quot;)</td></tr>
<tr class="separator:ad6d068692acbf0642e84ce1f94b677c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4000682688db62eb14635ce69f42e092"><td class="memTemplParams" colspan="2"><a id="a4000682688db62eb14635ce69f42e092"></a>
template&lt;class Space , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:a4000682688db62eb14635ce69f42e092"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a4000682688db62eb14635ce69f42e092">create_mirror</a> (const Space &amp;, const SrcAoSoA &amp;src, typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:a4000682688db62eb14635ce69f42e092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a mirror of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given space. <br /></td></tr>
<tr class="separator:a4000682688db62eb14635ce69f42e092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682f288aa48e84e44856d1a0b2239b43"><td class="memTemplParams" colspan="2">template&lt;class Space , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:a682f288aa48e84e44856d1a0b2239b43"><td class="memTemplItemLeft" align="right" valign="top">SrcAoSoA&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a682f288aa48e84e44856d1a0b2239b43">create_mirror_view</a> (const Space &amp;, const SrcAoSoA &amp;src, typename std::enable_if&lt;(std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:a682f288aa48e84e44856d1a0b2239b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given space. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <a href="namespaceCabana.html#a682f288aa48e84e44856d1a0b2239b43">More...</a><br /></td></tr>
<tr class="separator:a682f288aa48e84e44856d1a0b2239b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1766b5bf6655530bbeec104d9ef7d81"><td class="memTemplParams" colspan="2">template&lt;class Space , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:aa1766b5bf6655530bbeec104d9ef7d81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#aa1766b5bf6655530bbeec104d9ef7d81">create_mirror_view</a> (const Space &amp;space, const SrcAoSoA &amp;src, typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:aa1766b5bf6655530bbeec104d9ef7d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <a href="namespaceCabana.html#aa1766b5bf6655530bbeec104d9ef7d81">More...</a><br /></td></tr>
<tr class="separator:aa1766b5bf6655530bbeec104d9ef7d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22f02b41130e19d3e1f071373ac69c9"><td class="memTemplParams" colspan="2">template&lt;class Space , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:ab22f02b41130e19d3e1f071373ac69c9"><td class="memTemplItemLeft" align="right" valign="top">SrcAoSoA&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab22f02b41130e19d3e1f071373ac69c9">create_mirror_view_and_copy</a> (const Space &amp;, const SrcAoSoA &amp;src, typename std::enable_if&lt;(std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:ab22f02b41130e19d3e1f071373ac69c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and copy the contents of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <a href="namespaceCabana.html#ab22f02b41130e19d3e1f071373ac69c9">More...</a><br /></td></tr>
<tr class="separator:ab22f02b41130e19d3e1f071373ac69c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b46fdf8a6a9140734d372ff5df15d3"><td class="memTemplParams" colspan="2">template&lt;class Space , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:ae5b46fdf8a6a9140734d372ff5df15d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ae5b46fdf8a6a9140734d372ff5df15d3">create_mirror_view_and_copy</a> (const Space &amp;space, const SrcAoSoA &amp;src, typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:ae5b46fdf8a6a9140734d372ff5df15d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and deep copy the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> into the mirror. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> and performs the deep copy.  <a href="namespaceCabana.html#ae5b46fdf8a6a9140734d372ff5df15d3">More...</a><br /></td></tr>
<tr class="separator:ae5b46fdf8a6a9140734d372ff5df15d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1932d2c9be351d64dfcb6e2d22fc68c8"><td class="memTemplParams" colspan="2">template&lt;class DstAoSoA , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:a1932d2c9be351d64dfcb6e2d22fc68c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a1932d2c9be351d64dfcb6e2d22fc68c8">deep_copy</a> (DstAoSoA &amp;dst, const SrcAoSoA &amp;src, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; DstAoSoA &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:a1932d2c9be351d64dfcb6e2d22fc68c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy data between compatible <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> objects.  <a href="namespaceCabana.html#a1932d2c9be351d64dfcb6e2d22fc68c8">More...</a><br /></td></tr>
<tr class="separator:a1932d2c9be351d64dfcb6e2d22fc68c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f82fe027dec446d5ff114b36e2a30be"><td class="memTemplParams" colspan="2">template&lt;class AoSoA_t &gt; </td></tr>
<tr class="memitem:a0f82fe027dec446d5ff114b36e2a30be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a0f82fe027dec446d5ff114b36e2a30be">deep_copy</a> (AoSoA_t &amp;aosoa, const typename AoSoA_t::tuple_type &amp;tuple)</td></tr>
<tr class="memdesc:a0f82fe027dec446d5ff114b36e2a30be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> with a tuple.  <a href="namespaceCabana.html#a0f82fe027dec446d5ff114b36e2a30be">More...</a><br /></td></tr>
<tr class="separator:a0f82fe027dec446d5ff114b36e2a30be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c2588c68205d46f36b60be2afff96e"><td class="memTemplParams" colspan="2">template&lt;class DstSlice , class SrcSlice &gt; </td></tr>
<tr class="memitem:ab6c2588c68205d46f36b60be2afff96e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab6c2588c68205d46f36b60be2afff96e">deep_copy</a> (DstSlice &amp;dst, const SrcSlice &amp;src, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; DstSlice &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SrcSlice &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:ab6c2588c68205d46f36b60be2afff96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy data between compatible <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> objects.  <a href="namespaceCabana.html#ab6c2588c68205d46f36b60be2afff96e">More...</a><br /></td></tr>
<tr class="separator:ab6c2588c68205d46f36b60be2afff96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae209c92053381625d4d040bb1f74682b"><td class="memTemplParams" colspan="2">template&lt;class Slice_t &gt; </td></tr>
<tr class="memitem:ae209c92053381625d4d040bb1f74682b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ae209c92053381625d4d040bb1f74682b">deep_copy</a> (Slice_t &amp;slice, const typename Slice_t::value_type scalar)</td></tr>
<tr class="memdesc:ae209c92053381625d4d040bb1f74682b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a slice with a scalar.  <a href="namespaceCabana.html#ae209c92053381625d4d040bb1f74682b">More...</a><br /></td></tr>
<tr class="separator:ae209c92053381625d4d040bb1f74682b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb10ac278624d871f6079c4e24ccb219"><td class="memTemplParams" colspan="2">template&lt;class Distributor_t , class AoSoA_t &gt; </td></tr>
<tr class="memitem:adb10ac278624d871f6079c4e24ccb219"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#adb10ac278624d871f6079c4e24ccb219">migrate</a> (const Distributor_t &amp;distributor, const AoSoA_t &amp;src, AoSoA_t &amp;dst, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:adb10ac278624d871f6079c4e24ccb219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. Multiple <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version.  <a href="namespaceCabana.html#adb10ac278624d871f6079c4e24ccb219">More...</a><br /></td></tr>
<tr class="separator:adb10ac278624d871f6079c4e24ccb219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cb44110c8a6215d2ca62406e8aed35"><td class="memTemplParams" colspan="2">template&lt;class Distributor_t , class AoSoA_t &gt; </td></tr>
<tr class="memitem:ab9cb44110c8a6215d2ca62406e8aed35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab9cb44110c8a6215d2ca62406e8aed35">migrate</a> (const Distributor_t &amp;distributor, AoSoA_t &amp;aosoa, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ab9cb44110c8a6215d2ca62406e8aed35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. Single <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version that will resize in-place. Note that resizing does not necessarily allocate more memory. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> memory will only increase if not enough has already been reserved/allocated for the needed number of elements.  <a href="namespaceCabana.html#ab9cb44110c8a6215d2ca62406e8aed35">More...</a><br /></td></tr>
<tr class="separator:ab9cb44110c8a6215d2ca62406e8aed35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82063f55f2d0c3d17d11ba6642fb7353"><td class="memTemplParams" colspan="2">template&lt;class Distributor_t , class Slice_t &gt; </td></tr>
<tr class="memitem:a82063f55f2d0c3d17d11ba6642fb7353"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a82063f55f2d0c3d17d11ba6642fb7353">migrate</a> (const Distributor_t &amp;distributor, const Slice_t &amp;src, Slice_t &amp;dst, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a82063f55f2d0c3d17d11ba6642fb7353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. The user can do this in-place with the same slice but they will need to manage the resizing themselves as we can't resize slices.  <a href="namespaceCabana.html#a82063f55f2d0c3d17d11ba6642fb7353">More...</a><br /></td></tr>
<tr class="separator:a82063f55f2d0c3d17d11ba6642fb7353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dd17069284c2039235e463b2d885ee"><td class="memTemplParams" colspan="2">template&lt;class Halo_t , class AoSoA_t &gt; </td></tr>
<tr class="memitem:ac0dd17069284c2039235e463b2d885ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ac0dd17069284c2039235e463b2d885ee">gather</a> (const Halo_t &amp;halo, AoSoA_t &amp;aosoa, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; Halo_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ac0dd17069284c2039235e463b2d885ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version. This is a uniquely-owned to multiply-owned communication.  <a href="namespaceCabana.html#ac0dd17069284c2039235e463b2d885ee">More...</a><br /></td></tr>
<tr class="separator:ac0dd17069284c2039235e463b2d885ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c97a585251f273cc3ed77bda475af8c"><td class="memTemplParams" colspan="2">template&lt;class Halo_t , class Slice_t &gt; </td></tr>
<tr class="memitem:a2c97a585251f273cc3ed77bda475af8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a2c97a585251f273cc3ed77bda475af8c">gather</a> (const Halo_t &amp;halo, Slice_t &amp;slice, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; Halo_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a2c97a585251f273cc3ed77bda475af8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. This is a uniquely-owned to multiply-owned communication.  <a href="namespaceCabana.html#a2c97a585251f273cc3ed77bda475af8c">More...</a><br /></td></tr>
<tr class="separator:a2c97a585251f273cc3ed77bda475af8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22a4214a72df81e7678162494c38dd0"><td class="memTemplParams" colspan="2">template&lt;class Halo_t , class Slice_t &gt; </td></tr>
<tr class="memitem:af22a4214a72df81e7678162494c38dd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#af22a4214a72df81e7678162494c38dd0">scatter</a> (const Halo_t &amp;halo, Slice_t &amp;slice, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; Halo_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:af22a4214a72df81e7678162494c38dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously scatter data from the ghosts to the local decomposition of a slice using the halo reverse communication plan. This is a multiply-owned to uniquely owned communication.  <a href="namespaceCabana.html#af22a4214a72df81e7678162494c38dd0">More...</a><br /></td></tr>
<tr class="separator:af22a4214a72df81e7678162494c38dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c3a57c3cd27a75094bbfa1be56145b"><td class="memTemplParams" colspan="2">template&lt;class LinkedCellListType , class AoSoA_t &gt; </td></tr>
<tr class="memitem:a02c3a57c3cd27a75094bbfa1be56145b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a02c3a57c3cd27a75094bbfa1be56145b">permute</a> (const LinkedCellListType &amp;linked_cell_list, AoSoA_t &amp;aosoa, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellListType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a02c3a57c3cd27a75094bbfa1be56145b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a linked cell list permute an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <a href="namespaceCabana.html#a02c3a57c3cd27a75094bbfa1be56145b">More...</a><br /></td></tr>
<tr class="separator:a02c3a57c3cd27a75094bbfa1be56145b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1ce7155c5c1185f46071b20d4dd332"><td class="memTemplParams" colspan="2">template&lt;class LinkedCellListType , class SliceType &gt; </td></tr>
<tr class="memitem:a5a1ce7155c5c1185f46071b20d4dd332"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a5a1ce7155c5c1185f46071b20d4dd332">permute</a> (const LinkedCellListType &amp;linked_cell_list, SliceType &amp;slice, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellListType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a5a1ce7155c5c1185f46071b20d4dd332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a linked cell list permute a slice.  <a href="namespaceCabana.html#a5a1ce7155c5c1185f46071b20d4dd332">More...</a><br /></td></tr>
<tr class="separator:a5a1ce7155c5c1185f46071b20d4dd332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , int VectorLength, class... ExecParameters&gt; </td></tr>
<tr class="memitem:ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab7dda1a05e595dbec3f4f06e7f878d9e">simd_parallel_for</a> (const <a class="el" href="classCabana_1_1SimdPolicy.html">SimdPolicy</a>&lt; VectorLength, ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a vectorized functor in parallel with a 2d execution policy.  <a href="namespaceCabana.html#ab7dda1a05e595dbec3f4f06e7f878d9e">More...</a><br /></td></tr>
<tr class="separator:ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb924882c14a90b695a56065f4106c22"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:acb924882c14a90b695a56065f4106c22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#acb924882c14a90b695a56065f4106c22">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:acb924882c14a90b695a56065f4106c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute <code>functor</code> in parallel according to the execution <code>policy</code> with a thread-local serial loop over particle first neighbors.  <a href="namespaceCabana.html#acb924882c14a90b695a56065f4106c22">More...</a><br /></td></tr>
<tr class="separator:acb924882c14a90b695a56065f4106c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10eeaa254bbc26461eadae4d9a0a1598"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:a10eeaa254bbc26461eadae4d9a0a1598"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a10eeaa254bbc26461eadae4d9a0a1598">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:a10eeaa254bbc26461eadae4d9a0a1598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute <code>functor</code> in parallel according to the execution <code>policy</code> with thread-local serial loops over particle first and second neighbors.  <a href="namespaceCabana.html#a10eeaa254bbc26461eadae4d9a0a1598">More...</a><br /></td></tr>
<tr class="separator:a10eeaa254bbc26461eadae4d9a0a1598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cb6955452842c7903e86a845329e7c"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:ac2cb6955452842c7903e86a845329e7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ac2cb6955452842c7903e86a845329e7c">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:ac2cb6955452842c7903e86a845329e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute <code>functor</code> in parallel according to the execution <code>policy</code> with team parallelism over particle first neighbors.  <a href="namespaceCabana.html#ac2cb6955452842c7903e86a845329e7c">More...</a><br /></td></tr>
<tr class="separator:ac2cb6955452842c7903e86a845329e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca1d55078d6cfea288c6cec130ef204"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:acca1d55078d6cfea288c6cec130ef204"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#acca1d55078d6cfea288c6cec130ef204">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:acca1d55078d6cfea288c6cec130ef204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute <code>functor</code> in parallel according to the execution <code>policy</code> with team parallelism over particle first neighbors and serial loop over second neighbors.  <a href="namespaceCabana.html#acca1d55078d6cfea288c6cec130ef204">More...</a><br /></td></tr>
<tr class="separator:acca1d55078d6cfea288c6cec130ef204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dae9114f1f2ede7f1925a0c73c7639b"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:a3dae9114f1f2ede7f1925a0c73c7639b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a3dae9114f1f2ede7f1925a0c73c7639b">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a>, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:a3dae9114f1f2ede7f1925a0c73c7639b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute <code>functor</code> in parallel according to the execution <code>policy</code> with team parallelism over particle first neighbors and vector loop parallelism over second neighbors.  <a href="namespaceCabana.html#a3dae9114f1f2ede7f1925a0c73c7639b">More...</a><br /></td></tr>
<tr class="separator:a3dae9114f1f2ede7f1925a0c73c7639b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e94d9a9c1af171bdbb8c4362c23aa0"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:af7e94d9a9c1af171bdbb8c4362c23aa0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#af7e94d9a9c1af171bdbb8c4362c23aa0">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:af7e94d9a9c1af171bdbb8c4362c23aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute <code>functor</code> reduction in parallel according to the execution <code>policy</code> with a thread-local serial loop over particle first neighbors.  <a href="namespaceCabana.html#af7e94d9a9c1af171bdbb8c4362c23aa0">More...</a><br /></td></tr>
<tr class="separator:af7e94d9a9c1af171bdbb8c4362c23aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949a3b9f4fd10c8f6b05267870eca331"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:a949a3b9f4fd10c8f6b05267870eca331"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a949a3b9f4fd10c8f6b05267870eca331">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:a949a3b9f4fd10c8f6b05267870eca331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute <code>functor</code> reduction in parallel according to the execution <code>policy</code> with thread-local serial loops over particle first and second neighbors.  <a href="namespaceCabana.html#a949a3b9f4fd10c8f6b05267870eca331">More...</a><br /></td></tr>
<tr class="separator:a949a3b9f4fd10c8f6b05267870eca331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2295a3434a7b25d87832e522474f91"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:abb2295a3434a7b25d87832e522474f91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#abb2295a3434a7b25d87832e522474f91">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:abb2295a3434a7b25d87832e522474f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute <code>functor</code> reduction in parallel according to the execution <code>policy</code> with team parallelism over particle first neighbors.  <a href="namespaceCabana.html#abb2295a3434a7b25d87832e522474f91">More...</a><br /></td></tr>
<tr class="separator:abb2295a3434a7b25d87832e522474f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad67e6a4c72546175d974afd501a5fb"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:afad67e6a4c72546175d974afd501a5fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#afad67e6a4c72546175d974afd501a5fb">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:afad67e6a4c72546175d974afd501a5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute <code>functor</code> reduction in parallel according to the execution <code>policy</code> with team parallelism over particle first neighbors and serial loop over second neighbors.  <a href="namespaceCabana.html#afad67e6a4c72546175d974afd501a5fb">More...</a><br /></td></tr>
<tr class="separator:afad67e6a4c72546175d974afd501a5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd64556212553a3ada775f74735afe30"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:afd64556212553a3ada775f74735afe30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#afd64556212553a3ada775f74735afe30">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:afd64556212553a3ada775f74735afe30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute <code>functor</code> reduction in parallel according to the execution <code>policy</code> with team parallelism over particle first neighbors and vector loop parallelism over second neighbors.  <a href="namespaceCabana.html#afd64556212553a3ada775f74735afe30">More...</a><br /></td></tr>
<tr class="separator:afd64556212553a3ada775f74735afe30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="memTemplParams" colspan="2">template&lt;class IndexType , class FunctorType , class NeighborListType &gt; </td></tr>
<tr class="memitem:a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a15dca4f62c3f1f9cb7a9c869c7ae3486">for_each_neighbor</a> (const IndexType i, const FunctorType &amp;neighbor_functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>)</td></tr>
<tr class="memdesc:a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute <code>functor</code> in serial within existing parallel kernel over particle first neighbors.  <a href="namespaceCabana.html#a15dca4f62c3f1f9cb7a9c869c7ae3486">More...</a><br /></td></tr>
<tr class="separator:a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366034424ecf96ad51645694c2d71676"><td class="memTemplParams" colspan="2">template&lt;class IndexType , class FunctorType , class NeighborListType , class TeamMemberType &gt; </td></tr>
<tr class="memitem:a366034424ecf96ad51645694c2d71676"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a366034424ecf96ad51645694c2d71676">for_each_neighbor</a> (const IndexType i, const TeamMemberType team, const FunctorType &amp;neighbor_functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>)</td></tr>
<tr class="memdesc:a366034424ecf96ad51645694c2d71676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute team parallel <code>functor</code> within existing parallel kernel over particle first neighbors.  <a href="namespaceCabana.html#a366034424ecf96ad51645694c2d71676">More...</a><br /></td></tr>
<tr class="separator:a366034424ecf96ad51645694c2d71676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e6b7aab0a76b7224ca27f2d7c0d773"><td class="memTemplParams" colspan="2"><a id="ae5e6b7aab0a76b7224ca27f2d7c0d773"></a>
template&lt;std::size_t N, class ParameterPack_t &gt; </td></tr>
<tr class="memitem:ae5e6b7aab0a76b7224ca27f2d7c0d773"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__parameter__pack.html">is_parameter_pack</a>&lt; ParameterPack_t &gt;::value, typename ParameterPack_t::template value_type&lt; N &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (ParameterPack_t &amp;pp)</td></tr>
<tr class="separator:ae5e6b7aab0a76b7224ca27f2d7c0d773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2d41e5a38af62e09889c7ebd40ff08"><td class="memTemplParams" colspan="2"><a id="acd2d41e5a38af62e09889c7ebd40ff08"></a>
template&lt;std::size_t N, class ParameterPack_t &gt; </td></tr>
<tr class="memitem:acd2d41e5a38af62e09889c7ebd40ff08"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__parameter__pack.html">is_parameter_pack</a>&lt; ParameterPack_t &gt;::value, const typename ParameterPack_t::template value_type&lt; N &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const ParameterPack_t &amp;pp)</td></tr>
<tr class="separator:acd2d41e5a38af62e09889c7ebd40ff08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766de050b94dd4323998f8b6f3825f04"><td class="memTemplParams" colspan="2"><a id="a766de050b94dd4323998f8b6f3825f04"></a>
template&lt;typename ParameterPack_t , typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a766de050b94dd4323998f8b6f3825f04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fillParameterPackImpl</b> (ParameterPack_t &amp;pp, const std::integral_constant&lt; std::size_t, 0 &gt;, const T &amp;t, const Types &amp;...)</td></tr>
<tr class="separator:a766de050b94dd4323998f8b6f3825f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e78df9dc302ae883a2a96a21a4a422c"><td class="memTemplParams" colspan="2"><a id="a2e78df9dc302ae883a2a96a21a4a422c"></a>
template&lt;typename ParameterPack_t , std::size_t N, typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a2e78df9dc302ae883a2a96a21a4a422c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fillParameterPackImpl</b> (ParameterPack_t &amp;pp, const std::integral_constant&lt; std::size_t, N &gt;, const T &amp;t, const Types &amp;... ts)</td></tr>
<tr class="separator:a2e78df9dc302ae883a2a96a21a4a422c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1bdb5946e4dfb5f96695e6cee6484d"><td class="memTemplParams" colspan="2"><a id="a6b1bdb5946e4dfb5f96695e6cee6484d"></a>
template&lt;typename ParameterPack_t , typename... Types&gt; </td></tr>
<tr class="memitem:a6b1bdb5946e4dfb5f96695e6cee6484d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fillParameterPack</b> (ParameterPack_t &amp;pp, const Types &amp;... ts)</td></tr>
<tr class="separator:a6b1bdb5946e4dfb5f96695e6cee6484d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b83ffcd0599afe7840925786c8ecdc2"><td class="memTemplParams" colspan="2"><a id="a7b83ffcd0599afe7840925786c8ecdc2"></a>
template&lt;typename ParameterPack_t &gt; </td></tr>
<tr class="memitem:a7b83ffcd0599afe7840925786c8ecdc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fillParameterPack</b> (ParameterPack_t &amp;)</td></tr>
<tr class="separator:a7b83ffcd0599afe7840925786c8ecdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f38e1ad9eb9a3e1c5cc2a04000551b9"><td class="memTemplParams" colspan="2"><a id="a6f38e1ad9eb9a3e1c5cc2a04000551b9"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a6f38e1ad9eb9a3e1c5cc2a04000551b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCabana_1_1ParameterPack.html">ParameterPack</a>&lt; Types... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeParameterPack</b> (const Types &amp;... ts)</td></tr>
<tr class="separator:a6f38e1ad9eb9a3e1c5cc2a04000551b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aab31b7d2fef61f7b49251c301d441d"><td class="memTemplParams" colspan="2"><a id="a0aab31b7d2fef61f7b49251c301d441d"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a0aab31b7d2fef61f7b49251c301d441d"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (SoA_t &amp;soa, const std::size_t a)</td></tr>
<tr class="separator:a0aab31b7d2fef61f7b49251c301d441d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab320f9af9e1b558941d7738dcf35ac8"><td class="memTemplParams" colspan="2"><a id="aab320f9af9e1b558941d7738dcf35ac8"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:aab320f9af9e1b558941d7738dcf35ac8"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const SoA_t &amp;soa, const std::size_t a)</td></tr>
<tr class="separator:aab320f9af9e1b558941d7738dcf35ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d0aed6ba4c5510c803e41352ed1a8f"><td class="memTemplParams" colspan="2"><a id="a83d0aed6ba4c5510c803e41352ed1a8f"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a83d0aed6ba4c5510c803e41352ed1a8f"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (SoA_t &amp;soa, const std::size_t a, const std::size_t d0)</td></tr>
<tr class="separator:a83d0aed6ba4c5510c803e41352ed1a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fbfd236f0a376ce95a568002658889"><td class="memTemplParams" colspan="2"><a id="a79fbfd236f0a376ce95a568002658889"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a79fbfd236f0a376ce95a568002658889"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const SoA_t &amp;soa, const std::size_t a, const std::size_t d0)</td></tr>
<tr class="separator:a79fbfd236f0a376ce95a568002658889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bcf5c9c68d55c144b93ee37ca12a97"><td class="memTemplParams" colspan="2"><a id="ab5bcf5c9c68d55c144b93ee37ca12a97"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:ab5bcf5c9c68d55c144b93ee37ca12a97"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="separator:ab5bcf5c9c68d55c144b93ee37ca12a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa1a2579b2acd4f691ebd084b37ab95"><td class="memTemplParams" colspan="2"><a id="a8aa1a2579b2acd4f691ebd084b37ab95"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a8aa1a2579b2acd4f691ebd084b37ab95"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="separator:a8aa1a2579b2acd4f691ebd084b37ab95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c259fb6ad5568465e088ce86f2714a"><td class="memTemplParams" colspan="2"><a id="a90c259fb6ad5568465e088ce86f2714a"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a90c259fb6ad5568465e088ce86f2714a"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="separator:a90c259fb6ad5568465e088ce86f2714a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929d967bcdc7b7e26092bb714348be90"><td class="memTemplParams" colspan="2"><a id="a929d967bcdc7b7e26092bb714348be90"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a929d967bcdc7b7e26092bb714348be90"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="separator:a929d967bcdc7b7e26092bb714348be90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74033479f79c2c5e1831bf9a88234ef9"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:a74033479f79c2c5e1831bf9a88234ef9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a74033479f79c2c5e1831bf9a88234ef9">sortByKeyWithComparator</a> (KeyViewType keys, Comparator comp, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a74033479f79c2c5e1831bf9a88234ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys.  <a href="namespaceCabana.html#a74033479f79c2c5e1831bf9a88234ef9">More...</a><br /></td></tr>
<tr class="separator:a74033479f79c2c5e1831bf9a88234ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7d211b39c3007dff87e7d9a03bd777"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:a7e7d211b39c3007dff87e7d9a03bd777"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a7e7d211b39c3007dff87e7d9a03bd777">sortByKeyWithComparator</a> (KeyViewType keys, Comparator comp, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a7e7d211b39c3007dff87e7d9a03bd777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys.  <a href="namespaceCabana.html#a7e7d211b39c3007dff87e7d9a03bd777">More...</a><br /></td></tr>
<tr class="separator:a7e7d211b39c3007dff87e7d9a03bd777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69aceca61e0460f10c38fa9ad329cd0d"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:a69aceca61e0460f10c38fa9ad329cd0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a69aceca61e0460f10c38fa9ad329cd0d">binByKeyWithComparator</a> (KeyViewType keys, Comparator comp, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a69aceca61e0460f10c38fa9ad329cd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys.  <a href="namespaceCabana.html#a69aceca61e0460f10c38fa9ad329cd0d">More...</a><br /></td></tr>
<tr class="separator:a69aceca61e0460f10c38fa9ad329cd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09392355b60acbaa717d5f26ab15873"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:ad09392355b60acbaa717d5f26ab15873"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ad09392355b60acbaa717d5f26ab15873">binByKeyWithComparator</a> (KeyViewType keys, Comparator comp, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ad09392355b60acbaa717d5f26ab15873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys.  <a href="namespaceCabana.html#ad09392355b60acbaa717d5f26ab15873">More...</a><br /></td></tr>
<tr class="separator:ad09392355b60acbaa717d5f26ab15873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb212c9d4bf5dd79dca6393dd5cd1d50"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:afb212c9d4bf5dd79dca6393dd5cd1d50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#afb212c9d4bf5dd79dca6393dd5cd1d50">sortByKey</a> (KeyViewType keys, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:afb212c9d4bf5dd79dca6393dd5cd1d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values.  <a href="namespaceCabana.html#afb212c9d4bf5dd79dca6393dd5cd1d50">More...</a><br /></td></tr>
<tr class="separator:afb212c9d4bf5dd79dca6393dd5cd1d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5de120bd7e1dd83a15d85ac2121633b"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:ad5de120bd7e1dd83a15d85ac2121633b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ad5de120bd7e1dd83a15d85ac2121633b">sortByKey</a> (KeyViewType keys, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ad5de120bd7e1dd83a15d85ac2121633b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values.  <a href="namespaceCabana.html#ad5de120bd7e1dd83a15d85ac2121633b">More...</a><br /></td></tr>
<tr class="separator:ad5de120bd7e1dd83a15d85ac2121633b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604397e80ba71af071611b748e0cecde"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:a604397e80ba71af071611b748e0cecde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a604397e80ba71af071611b748e0cecde">binByKey</a> (KeyViewType keys, const int nbin, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a604397e80ba71af071611b748e0cecde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values and number of bins. The bins are evenly divided over the range of key values.  <a href="namespaceCabana.html#a604397e80ba71af071611b748e0cecde">More...</a><br /></td></tr>
<tr class="separator:a604397e80ba71af071611b748e0cecde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298e4012225366d9a9fdf7b9a867f641"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:a298e4012225366d9a9fdf7b9a867f641"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a298e4012225366d9a9fdf7b9a867f641">binByKey</a> (KeyViewType keys, const int nbin, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a298e4012225366d9a9fdf7b9a867f641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values and number of bins. The bins are evenly divided over the range of key values.  <a href="namespaceCabana.html#a298e4012225366d9a9fdf7b9a867f641">More...</a><br /></td></tr>
<tr class="separator:a298e4012225366d9a9fdf7b9a867f641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a4311d29473e2ecdab7927aaff49ad"><td class="memTemplParams" colspan="2">template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </td></tr>
<tr class="memitem:a91a4311d29473e2ecdab7927aaff49ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a91a4311d29473e2ecdab7927aaff49ad">sortByKey</a> (SliceType slice, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a91a4311d29473e2ecdab7927aaff49ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys.  <a href="namespaceCabana.html#a91a4311d29473e2ecdab7927aaff49ad">More...</a><br /></td></tr>
<tr class="separator:a91a4311d29473e2ecdab7927aaff49ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95cdaf6584250a53d942bbe99e5e78e"><td class="memTemplParams" colspan="2">template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </td></tr>
<tr class="memitem:af95cdaf6584250a53d942bbe99e5e78e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#af95cdaf6584250a53d942bbe99e5e78e">sortByKey</a> (SliceType slice, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:af95cdaf6584250a53d942bbe99e5e78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys.  <a href="namespaceCabana.html#af95cdaf6584250a53d942bbe99e5e78e">More...</a><br /></td></tr>
<tr class="separator:af95cdaf6584250a53d942bbe99e5e78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e2eca356e99a00cf3f2f5848f5cf7a"><td class="memTemplParams" colspan="2">template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </td></tr>
<tr class="memitem:ad3e2eca356e99a00cf3f2f5848f5cf7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ad3e2eca356e99a00cf3f2f5848f5cf7a">binByKey</a> (SliceType slice, const int nbin, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ad3e2eca356e99a00cf3f2f5848f5cf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys.  <a href="namespaceCabana.html#ad3e2eca356e99a00cf3f2f5848f5cf7a">More...</a><br /></td></tr>
<tr class="separator:ad3e2eca356e99a00cf3f2f5848f5cf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3328dc23cbfede2bd40bcdd2fdd9074"><td class="memTemplParams" colspan="2">template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </td></tr>
<tr class="memitem:aa3328dc23cbfede2bd40bcdd2fdd9074"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#aa3328dc23cbfede2bd40bcdd2fdd9074">binByKey</a> (SliceType slice, const int nbin, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:aa3328dc23cbfede2bd40bcdd2fdd9074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys.  <a href="namespaceCabana.html#aa3328dc23cbfede2bd40bcdd2fdd9074">More...</a><br /></td></tr>
<tr class="separator:aa3328dc23cbfede2bd40bcdd2fdd9074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824f296314f00ca8e121e6a26e2846db"><td class="memTemplParams" colspan="2">template&lt;class BinningDataType , class AoSoA_t , class DeviceType  = typename BinningDataType::device_type&gt; </td></tr>
<tr class="memitem:a824f296314f00ca8e121e6a26e2846db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a824f296314f00ca8e121e6a26e2846db">permute</a> (const BinningDataType &amp;binning_data, AoSoA_t &amp;aosoa, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__binning__data.html">is_binning_data</a>&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a824f296314f00ca8e121e6a26e2846db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given binning data permute an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <a href="namespaceCabana.html#a824f296314f00ca8e121e6a26e2846db">More...</a><br /></td></tr>
<tr class="separator:a824f296314f00ca8e121e6a26e2846db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44a65c22331c71ed7cee721a41c54fc"><td class="memTemplParams" colspan="2">template&lt;class BinningDataType , class SliceType , class DeviceType  = typename BinningDataType::device_type&gt; </td></tr>
<tr class="memitem:ab44a65c22331c71ed7cee721a41c54fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab44a65c22331c71ed7cee721a41c54fc">permute</a> (const BinningDataType &amp;binning_data, SliceType &amp;slice, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__binning__data.html">is_binning_data</a>&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ab44a65c22331c71ed7cee721a41c54fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given binning data permute a slice.  <a href="namespaceCabana.html#ab44a65c22331c71ed7cee721a41c54fc">More...</a><br /></td></tr>
<tr class="separator:ab44a65c22331c71ed7cee721a41c54fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e20e9c067d985394d69366af5cd882"><td class="memTemplParams" colspan="2"><a id="a30e20e9c067d985394d69366af5cd882"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a30e20e9c067d985394d69366af5cd882"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typename Tuple_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (Tuple_t &amp;tp)</td></tr>
<tr class="separator:a30e20e9c067d985394d69366af5cd882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f93f17fcbbbc63f83e03e7d5c4a6d08"><td class="memTemplParams" colspan="2"><a id="a0f93f17fcbbbc63f83e03e7d5c4a6d08"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a0f93f17fcbbbc63f83e03e7d5c4a6d08"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION Tuple_t::template member_const_reference_type&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const Tuple_t &amp;tp)</td></tr>
<tr class="separator:a0f93f17fcbbbc63f83e03e7d5c4a6d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2354c80a56abe0e99df1eff351584f31"><td class="memTemplParams" colspan="2"><a id="a2354c80a56abe0e99df1eff351584f31"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a2354c80a56abe0e99df1eff351584f31"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typename Tuple_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (Tuple_t &amp;tp, const std::size_t d0)</td></tr>
<tr class="separator:a2354c80a56abe0e99df1eff351584f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677093a8ac21a4c897a6a5d6455d1662"><td class="memTemplParams" colspan="2"><a id="a677093a8ac21a4c897a6a5d6455d1662"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a677093a8ac21a4c897a6a5d6455d1662"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typename Tuple_t::template member_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const Tuple_t &amp;tp, const std::size_t d0)</td></tr>
<tr class="separator:a677093a8ac21a4c897a6a5d6455d1662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614c65635a984f76acdf46dc4cbffc52"><td class="memTemplParams" colspan="2"><a id="a614c65635a984f76acdf46dc4cbffc52"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a614c65635a984f76acdf46dc4cbffc52"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typename Tuple_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="separator:a614c65635a984f76acdf46dc4cbffc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1019ce4c1cf533cacedbaa5f808000"><td class="memTemplParams" colspan="2"><a id="aea1019ce4c1cf533cacedbaa5f808000"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:aea1019ce4c1cf533cacedbaa5f808000"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typename Tuple_t::template member_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="separator:aea1019ce4c1cf533cacedbaa5f808000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71efcfb57ce9e0843cd35fb8249a2dd"><td class="memTemplParams" colspan="2"><a id="ab71efcfb57ce9e0843cd35fb8249a2dd"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:ab71efcfb57ce9e0843cd35fb8249a2dd"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typename Tuple_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="separator:ab71efcfb57ce9e0843cd35fb8249a2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e4f6dea874e909927f1144057ab993"><td class="memTemplParams" colspan="2"><a id="a17e4f6dea874e909927f1144057ab993"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a17e4f6dea874e909927f1144057ab993"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typename Tuple_t::template member_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="separator:a17e4f6dea874e909927f1144057ab993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f45805f16a42f9f6f048d2e88cd940"><td class="memItemLeft" align="right" valign="top"><a id="a94f45805f16a42f9f6f048d2e88cd940"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>version</b> ()</td></tr>
<tr class="separator:a94f45805f16a42f9f6f048d2e88cd940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad181bcaca8bec0b53a05927aff3120"><td class="memItemLeft" align="right" valign="top"><a id="afad181bcaca8bec0b53a05927aff3120"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>git_commit_hash</b> ()</td></tr>
<tr class="separator:afad181bcaca8bec0b53a05927aff3120"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Core: particle data structures and algorithms. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a604397e80ba71af071611b748e0cecde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604397e80ba71af071611b748e0cecde">&#9670;&nbsp;</a></span>binByKey() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values and number of bins. The bins are evenly divided over the range of key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins.</td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin.</td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="a298e4012225366d9a9fdf7b9a867f641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298e4012225366d9a9fdf7b9a867f641">&#9670;&nbsp;</a></span>binByKey() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values and number of bins. The bins are evenly divided over the range of key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="ad3e2eca356e99a00cf3f2f5848f5cf7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e2eca356e99a00cf3f2f5848f5cf7a">&#9670;&nbsp;</a></span>binByKey() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys.</td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins.</td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin.</td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="aa3328dc23cbfede2bd40bcdd2fdd9074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3328dc23cbfede2bd40bcdd2fdd9074">&#9670;&nbsp;</a></span>binByKey() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys.</td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="a69aceca61e0460f10c38fa9ad329cd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69aceca61e0460f10c38fa9ad329cd0d">&#9670;&nbsp;</a></span>binByKeyWithComparator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::binByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for binning. Must be compatible with Kokkos::BinSort.</td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin.</td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="ad09392355b60acbaa717d5f26ab15873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09392355b60acbaa717d5f26ab15873">&#9670;&nbsp;</a></span>binByKeyWithComparator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::binByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for binning. Must be compatible with Kokkos::BinSort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="a682f288aa48e84e44856d1a0b2239b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682f288aa48e84e44856d1a0b2239b43">&#9670;&nbsp;</a></span>create_mirror_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SrcAoSoA Cabana::create_mirror_view </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given space. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="aa1766b5bf6655530bbeec104d9ef7d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1766b5bf6655530bbeec104d9ef7d81">&#9670;&nbsp;</a></span>create_mirror_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt;typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length&gt; Cabana::create_mirror_view </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="ab22f02b41130e19d3e1f071373ac69c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22f02b41130e19d3e1f071373ac69c9">&#9670;&nbsp;</a></span>create_mirror_view_and_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SrcAoSoA Cabana::create_mirror_view_and_copy </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and copy the contents of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="ae5b46fdf8a6a9140734d372ff5df15d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b46fdf8a6a9140734d372ff5df15d3">&#9670;&nbsp;</a></span>create_mirror_view_and_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt;typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length&gt; Cabana::create_mirror_view_and_copy </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and deep copy the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> into the mirror. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> and performs the deep copy. </p>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="a0f82fe027dec446d5ff114b36e2a30be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f82fe027dec446d5ff114b36e2a30be">&#9670;&nbsp;</a></span>deep_copy() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AoSoA_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AoSoA_t::tuple_type &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> with a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to fill.</td></tr>
    <tr><td class="paramname">tuple</td><td>The tuple to assign. All <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> elements will be assigned this value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1932d2c9be351d64dfcb6e2d22fc68c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1932d2c9be351d64dfcb6e2d22fc68c8">&#9670;&nbsp;</a></span>deep_copy() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DstAoSoA , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">DstAoSoA &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; DstAoSoA &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy data between compatible <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination for the copied data.</td></tr>
    <tr><td class="paramname">src</td><td>The source of the copied data.</td></tr>
  </table>
  </dd>
</dl>
<p>Only <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> objects with the same set of member data types and size may be copied. </p>

</div>
</div>
<a id="ab6c2588c68205d46f36b60be2afff96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c2588c68205d46f36b60be2afff96e">&#9670;&nbsp;</a></span>deep_copy() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DstSlice , class SrcSlice &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">DstSlice &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcSlice &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; DstSlice &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SrcSlice &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy data between compatible <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination for the copied data.</td></tr>
    <tr><td class="paramname">src</td><td>The source of the copied data.</td></tr>
  </table>
  </dd>
</dl>
<p>Only <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> objects with the same set of member data types and size may be copied. </p>

</div>
</div>
<a id="ae209c92053381625d4d040bb1f74682b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae209c92053381625d4d040bb1f74682b">&#9670;&nbsp;</a></span>deep_copy() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Slice_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">Slice_t &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Slice_t::value_type&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a slice with a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice to fill.</td></tr>
    <tr><td class="paramname">scalar</td><td>The scalar to assign. All slice elements will be assigned this value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15dca4f62c3f1f9cb7a9c869c7ae3486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15dca4f62c3f1f9cb7a9c869c7ae3486">&#9670;&nbsp;</a></span>for_each_neighbor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexType , class FunctorType , class NeighborListType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void Cabana::for_each_neighbor </td>
          <td>(</td>
          <td class="paramtype">const IndexType&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>neighbor_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>FirstNeighborsTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute <code>functor</code> in serial within existing parallel kernel over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexType</td><td>The particle index type.</td></tr>
    <tr><td class="paramname">FunctorType</td><td>The neighbor functor type to execute.</td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Particle index.</td></tr>
    <tr><td class="paramname">neighbor_functor</td><td>The neighbor functor to execute in parallel.</td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a></td><td>Tag indicating operations over particle first neighbors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a366034424ecf96ad51645694c2d71676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366034424ecf96ad51645694c2d71676">&#9670;&nbsp;</a></span>for_each_neighbor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexType , class FunctorType , class NeighborListType , class TeamMemberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void Cabana::for_each_neighbor </td>
          <td>(</td>
          <td class="paramtype">const IndexType&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TeamMemberType&#160;</td>
          <td class="paramname"><em>team</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>neighbor_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>FirstNeighborsTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute team parallel <code>functor</code> within existing parallel kernel over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexType</td><td>The particle index type.</td></tr>
    <tr><td class="paramname">FunctorType</td><td>The neighbor functor type to execute.</td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Particle index.</td></tr>
    <tr><td class="paramname">team</td><td>Kokkos team.</td></tr>
    <tr><td class="paramname">neighbor_functor</td><td>The neighbor functor to execute in parallel.</td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a></td><td>Tag indicating operations over particle first neighbors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0dd17069284c2039235e463b2d885ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0dd17069284c2039235e463b2d885ee">&#9670;&nbsp;</a></span>gather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Halo_t , class AoSoA_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::gather </td>
          <td>(</td>
          <td class="paramtype">const Halo_t &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; Halo_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version. This is a uniquely-owned to multiply-owned communication. </p>
<p>A gather sends data from a locally owned elements to one or many ranks on which they exist as ghosts. A locally owned element may be sent to as many ranks as desired to be used as a ghost on those ranks. The value of the element in the locally owned decomposition will be the value assigned to the element in the ghosted decomposition.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Halo_t</td><td><a class="el" href="classCabana_1_1Halo.html" title="Halo communication plan for scattering and gathering of ghosted data.">Halo</a> type - must be a <a class="el" href="classCabana_1_1Halo.html" title="Halo communication plan for scattering and gathering of ghosted data.">Halo</a>.</td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type - must be an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo to use for the gather.</td></tr>
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> on which to perform the gather. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> should have a size equivalent to halo.numGhost() + halo.numLocal(). The locally owned elements are expected to appear first (i.e. in the first halo.numLocal() elements) and the ghosted elements are expected to appear second (i.e. in the next halo.numGhost() elements()). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c97a585251f273cc3ed77bda475af8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c97a585251f273cc3ed77bda475af8c">&#9670;&nbsp;</a></span>gather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Halo_t , class Slice_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::gather </td>
          <td>(</td>
          <td class="paramtype">const Halo_t &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Slice_t &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; Halo_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. This is a uniquely-owned to multiply-owned communication. </p>
<p>A gather sends data from a locally owned elements to one or many ranks on which they exist as ghosts. A locally owned element may be sent to as many ranks as desired to be used as a ghost on those ranks. The value of the element in the locally owned decomposition will be the value assigned to the element in the ghosted decomposition.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Halo_t</td><td><a class="el" href="classCabana_1_1Halo.html" title="Halo communication plan for scattering and gathering of ghosted data.">Halo</a> type - must be a <a class="el" href="classCabana_1_1Halo.html" title="Halo communication plan for scattering and gathering of ghosted data.">Halo</a>.</td></tr>
    <tr><td class="paramname">Slice_t</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type - must be a <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo to use for the gather.</td></tr>
    <tr><td class="paramname">slice</td><td>The <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> on which to perform the gather. The <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> should have a size equivalent to halo.numGhost() + halo.numLocal(). The locally owned elements are expected to appear first (i.e. in the first halo.numLocal() elements) and the ghosted elements are expected to appear second (i.e. in the next halo.numGhost() elements()). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9cb44110c8a6215d2ca62406e8aed35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cb44110c8a6215d2ca62406e8aed35">&#9670;&nbsp;</a></span>migrate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Distributor_t , class AoSoA_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">const Distributor_t &amp;&#160;</td>
          <td class="paramname"><em>distributor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. Single <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version that will resize in-place. Note that resizing does not necessarily allocate more memory. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> memory will only increase if not enough has already been reserved/allocated for the needed number of elements. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="Distributor is a communication plan for migrating data from one uniquely-owned decomposition to anoth...">Distributor</a> type - must be a distributor.</td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type - must be an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration.</td></tr>
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> containing the data to be migrated. Upon input, must have the same number of elements as the inputs used to construct the destributor. At output, it will be the same size as th enumber of import elements on this rank provided by the distributor. Before using this function, consider reserving enough memory in the data structure so reallocating is not necessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb10ac278624d871f6079c4e24ccb219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb10ac278624d871f6079c4e24ccb219">&#9670;&nbsp;</a></span>migrate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Distributor_t , class AoSoA_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">const Distributor_t &amp;&#160;</td>
          <td class="paramname"><em>distributor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. Multiple <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="Distributor is a communication plan for migrating data from one uniquely-owned decomposition to anoth...">Distributor</a> type - must be a distributor.</td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type - must be an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration.</td></tr>
    <tr><td class="paramname">src</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> containing the data to be migrated. Must have the same number of elements as the inputs used to construct the distributor.</td></tr>
    <tr><td class="paramname">dst</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to which the migrated data will be written. Must be the same size as the number of imports given by the distributor on this rank. Call totalNumImport() on the distributor to get this size value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82063f55f2d0c3d17d11ba6642fb7353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82063f55f2d0c3d17d11ba6642fb7353">&#9670;&nbsp;</a></span>migrate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Distributor_t , class Slice_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">const Distributor_t &amp;&#160;</td>
          <td class="paramname"><em>distributor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Slice_t &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Slice_t &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. The user can do this in-place with the same slice but they will need to manage the resizing themselves as we can't resize slices. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="Distributor is a communication plan for migrating data from one uniquely-owned decomposition to anoth...">Distributor</a> type - must be a distributor.</td></tr>
    <tr><td class="paramname">Slice_t</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type - must be an <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration.</td></tr>
    <tr><td class="paramname">src</td><td>The slice containing the data to be migrated. Must have the same number of elements as the inputs used to construct the destributor.</td></tr>
    <tr><td class="paramname">dst</td><td>The slice to which the migrated data will be written. Must be the same size as the number of imports given by the distributor on this rank. Call totalNumImport() on the distributor to get this size value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb924882c14a90b695a56065f4106c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb924882c14a90b695a56065f4106c22">&#9670;&nbsp;</a></span>neighbor_parallel_for() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>FirstNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SerialOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute <code>functor</code> in parallel according to the execution <code>policy</code> with a thread-local serial loop over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type.</td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel</td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a></td><td>Tag indicating operations over particle first neighbors.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a></td><td>Tag indicating a serial loop strategy over neighbors.</td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes.</td></tr>
  </table>
  </dd>
</dl>
<p>A "functor" is a class containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for neighbor parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> particle_index, <span class="keyword">const</span> <span class="keywordtype">int</span> neighbor_index ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>Index</code> is a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> index to a given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> element for a particle and its neighbor. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. This compares to a single iteration <code>idx</code> of a <code>for</code> loop. </p>

</div>
</div>
<a id="ac2cb6955452842c7903e86a845329e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cb6955452842c7903e86a845329e7c">&#9670;&nbsp;</a></span>neighbor_parallel_for() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>FirstNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>TeamOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute <code>functor</code> in parallel according to the execution <code>policy</code> with team parallelism over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type.</td></tr>
    <tr><td class="paramname">ExecParameters</td><td>The Kokkos execution policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel</td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a></td><td>Tag indicating operations over particle first neighbors.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a></td><td>Tag indicating a team parallel strategy over neighbors.</td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes.</td></tr>
  </table>
  </dd>
</dl>
<p>A "functor" is a class containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for neighbor parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> particle_index, <span class="keyword">const</span> <span class="keywordtype">int</span> neighbor_index ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>Index</code> is a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> index to a given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> element for a particle and its neighbor. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. This compares to a single iteration <code>idx</code> of a <code>for</code> loop. </p>

</div>
</div>
<a id="a10eeaa254bbc26461eadae4d9a0a1598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10eeaa254bbc26461eadae4d9a0a1598">&#9670;&nbsp;</a></span>neighbor_parallel_for() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SecondNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SerialOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute <code>functor</code> in parallel according to the execution <code>policy</code> with thread-local serial loops over particle first and second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type.</td></tr>
    <tr><td class="paramname">ExecParameters</td><td>The Kokkos execution policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel</td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a></td><td>Tag indicating operations over particle first and second neighbors.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a></td><td>Tag indicating a serial loop strategy over neighbors.</td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acca1d55078d6cfea288c6cec130ef204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca1d55078d6cfea288c6cec130ef204">&#9670;&nbsp;</a></span>neighbor_parallel_for() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SecondNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>TeamOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute <code>functor</code> in parallel according to the execution <code>policy</code> with team parallelism over particle first neighbors and serial loop over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type.</td></tr>
    <tr><td class="paramname">ExecParameters</td><td>The Kokkos execution policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel</td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a></td><td>Tag indicating operations over particle first and second neighbors.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a></td><td>Tag indicating a team parallel strategy over particle first neighbors and serial execution over second neighbors.</td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dae9114f1f2ede7f1925a0c73c7639b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dae9114f1f2ede7f1925a0c73c7639b">&#9670;&nbsp;</a></span>neighbor_parallel_for() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SecondNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>TeamVectorOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute <code>functor</code> in parallel according to the execution <code>policy</code> with team parallelism over particle first neighbors and vector loop parallelism over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type.</td></tr>
    <tr><td class="paramname">ExecParameters</td><td>The Kokkos execution policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel</td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a></td><td>Tag indicating operations over particle first and second neighbors.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1TeamVectorOpTag.html" title="Neighbor operations are executed with team vector parallelism.">TeamVectorOpTag</a></td><td>Tag indicating a team parallel strategy over particle first neighbors and vector parallel loop strategy over second neighbors.</td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7e94d9a9c1af171bdbb8c4362c23aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e94d9a9c1af171bdbb8c4362c23aa0">&#9670;&nbsp;</a></span>neighbor_parallel_reduce() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>FirstNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SerialOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reduce_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute <code>functor</code> reduction in parallel according to the execution <code>policy</code> with a thread-local serial loop over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type.</td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel</td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a></td><td>Tag indicating operations over particle first neighbors.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a></td><td>Tag indicating a serial loop strategy over neighbors.</td></tr>
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors.</td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb2295a3434a7b25d87832e522474f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2295a3434a7b25d87832e522474f91">&#9670;&nbsp;</a></span>neighbor_parallel_reduce() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>FirstNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>TeamOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reduce_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute <code>functor</code> reduction in parallel according to the execution <code>policy</code> with team parallelism over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type.</td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel</td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a></td><td>Tag indicating operations over particle first neighbors.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a></td><td>Tag indicating a team parallel strategy over particle neighbors.</td></tr>
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors.</td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a949a3b9f4fd10c8f6b05267870eca331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949a3b9f4fd10c8f6b05267870eca331">&#9670;&nbsp;</a></span>neighbor_parallel_reduce() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SecondNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SerialOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reduce_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute <code>functor</code> reduction in parallel according to the execution <code>policy</code> with thread-local serial loops over particle first and second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type.</td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel</td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a></td><td>Tag indicating operations over particle first and second neighbors.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a></td><td>Tag indicating a serial loop strategy over neighbors.</td></tr>
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors.</td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afad67e6a4c72546175d974afd501a5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad67e6a4c72546175d974afd501a5fb">&#9670;&nbsp;</a></span>neighbor_parallel_reduce() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SecondNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>TeamOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reduce_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute <code>functor</code> reduction in parallel according to the execution <code>policy</code> with team parallelism over particle first neighbors and serial loop over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type.</td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel</td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a></td><td>Tag indicating operations over particle first and second neighbors.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a></td><td>Tag indicating a team parallel strategy over particle first neighbors and serial loops over second neighbors.</td></tr>
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors.</td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd64556212553a3ada775f74735afe30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd64556212553a3ada775f74735afe30">&#9670;&nbsp;</a></span>neighbor_parallel_reduce() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SecondNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>TeamVectorOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reduce_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute <code>functor</code> reduction in parallel according to the execution <code>policy</code> with team parallelism over particle first neighbors and vector loop parallelism over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type.</td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel</td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a></td><td>Tag indicating operations over particle first and second neighbors.</td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1TeamVectorOpTag.html" title="Neighbor operations are executed with team vector parallelism.">TeamVectorOpTag</a></td><td>Tag indicating a team parallel strategy over particle first neighbors and vector loops over second neighbors.</td></tr>
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors.</td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a824f296314f00ca8e121e6a26e2846db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824f296314f00ca8e121e6a26e2846db">&#9670;&nbsp;</a></span>permute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BinningDataType , class AoSoA_t , class DeviceType  = typename BinningDataType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">const BinningDataType &amp;&#160;</td>
          <td class="paramname"><em>binning_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__binning__data.html">is_binning_data</a>&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given binning data permute an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinningDataType</td><td>The binning data type.</td></tr>
    <tr><td class="paramname">AoSoA_t</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binning_data</td><td>The binning data.</td></tr>
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab44a65c22331c71ed7cee721a41c54fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44a65c22331c71ed7cee721a41c54fc">&#9670;&nbsp;</a></span>permute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BinningDataType , class SliceType , class DeviceType  = typename BinningDataType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">const BinningDataType &amp;&#160;</td>
          <td class="paramname"><em>binning_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceType &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__binning__data.html">is_binning_data</a>&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given binning data permute a slice. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinningDataType</td><td>The binning data type.</td></tr>
    <tr><td class="paramname">SliceType</td><td>The slice type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binning_data</td><td>The binning data.</td></tr>
    <tr><td class="paramname">slice</td><td>The slice to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02c3a57c3cd27a75094bbfa1be56145b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c3a57c3cd27a75094bbfa1be56145b">&#9670;&nbsp;</a></span>permute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LinkedCellListType , class AoSoA_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">const LinkedCellListType &amp;&#160;</td>
          <td class="paramname"><em>linked_cell_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellListType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a linked cell list permute an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LinkedCellListType</td><td>The linked cell list type.</td></tr>
    <tr><td class="paramname">AoSoA_t</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linked_cell_list</td><td>The linked cell list to permute the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> with.</td></tr>
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a1ce7155c5c1185f46071b20d4dd332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1ce7155c5c1185f46071b20d4dd332">&#9670;&nbsp;</a></span>permute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LinkedCellListType , class SliceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">const LinkedCellListType &amp;&#160;</td>
          <td class="paramname"><em>linked_cell_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceType &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellListType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a linked cell list permute a slice. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LinkedCellListType</td><td>The linked cell list type.</td></tr>
    <tr><td class="paramname">SliceType</td><td>The slice type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linked_cell_list</td><td>The linked cell list to permute the slice with.</td></tr>
    <tr><td class="paramname">slice</td><td>The slice to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af22a4214a72df81e7678162494c38dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22a4214a72df81e7678162494c38dd0">&#9670;&nbsp;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Halo_t , class Slice_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::scatter </td>
          <td>(</td>
          <td class="paramtype">const Halo_t &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Slice_t &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; Halo_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously scatter data from the ghosts to the local decomposition of a slice using the halo reverse communication plan. This is a multiply-owned to uniquely owned communication. </p>
<p>In a scatter operation results from ghosted values on other processors are scattered back to the owning processor of the ghost and the value associated with the ghost is summed into the locally owned value the ghost represents. If a locally owned element is ghosted on multiple ranks, then multiple contributions will be made to the sum, one for each rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Halo_t</td><td><a class="el" href="classCabana_1_1Halo.html" title="Halo communication plan for scattering and gathering of ghosted data.">Halo</a> type - must be a <a class="el" href="classCabana_1_1Halo.html" title="Halo communication plan for scattering and gathering of ghosted data.">Halo</a>.</td></tr>
    <tr><td class="paramname">Slice_t</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type - must be a <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo to use for the scatter.</td></tr>
    <tr><td class="paramname">slice</td><td>The <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> on which to perform the scatter. The <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> should have a size equivalent to halo.numGhost() + halo.numLocal(). The locally owned elements are expected to appear first (i.e. in the first halo.numLocal() elements) and the ghosted elements are expected to appear second (i.e. in the next halo.numGhost() elements()). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7dda1a05e595dbec3f4f06e7f878d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7dda1a05e595dbec3f4f06e7f878d9e">&#9670;&nbsp;</a></span>simd_parallel_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , int VectorLength, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::simd_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SimdPolicy.html">SimdPolicy</a>&lt; VectorLength, ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a vectorized functor in parallel with a 2d execution policy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">VectorLength</td><td>The length of the vector over which to execute the vectorized code.</td></tr>
    <tr><td class="paramname">ExecParameters</td><td>Execution policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The 2D range policy over which to execute the functor.</td></tr>
    <tr><td class="paramname">functor</td><td>The vectorized functor to execute in parallel. Must accept both a struct and array index.</td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes.</td></tr>
  </table>
  </dd>
</dl>
<p>A "functor" is a callable object containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> <span class="keyword">struct</span>, <span class="keyword">const</span> <span class="keywordtype">int</span> array ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>struct</code> defines an index to a given AoSoA/Slice struct and array defines and index to the given array element in that struct. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. The kernel represented by the functor is intended to vectorize of the array index.</p>
<dl class="section note"><dt>Note</dt><dd>The work tag gets applied at the user functor level, not at the level of the functor in this implementation that wraps the user functor. </dd></dl>

</div>
</div>
<a id="afb212c9d4bf5dd79dca6393dd5cd1d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb212c9d4bf5dd79dca6393dd5cd1d50">&#9670;&nbsp;</a></span>sortByKey() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort.</td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="ad5de120bd7e1dd83a15d85ac2121633b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5de120bd7e1dd83a15d85ac2121633b">&#9670;&nbsp;</a></span>sortByKey() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="a91a4311d29473e2ecdab7927aaff49ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a4311d29473e2ecdab7927aaff49ad">&#9670;&nbsp;</a></span>sortByKey() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys.</td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort.</td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="af95cdaf6584250a53d942bbe99e5e78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95cdaf6584250a53d942bbe99e5e78e">&#9670;&nbsp;</a></span>sortByKey() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="a74033479f79c2c5e1831bf9a88234ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74033479f79c2c5e1831bf9a88234ef9">&#9670;&nbsp;</a></span>sortByKeyWithComparator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::sortByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for sorting. Must be compatible with Kokkos::BinSort.</td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort.</td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="a7e7d211b39c3007dff87e7d9a03bd777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7d211b39c3007dff87e7d9a03bd777">&#9670;&nbsp;</a></span>sortByKeyWithComparator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::sortByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for sorting. Must be compatible with Kokkos::BinSort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
