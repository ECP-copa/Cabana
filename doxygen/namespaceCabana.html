<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cabana: Cabana Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cabana
   &#160;<span id="projectnumber">1.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Cabana Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Core: particle data structures and algorithms.  
<a href="namespaceCabana.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array-of-Struct-of-Arrays.  <a href="classCabana_1_1AoSoA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> static type checker.  <a href="structCabana_1_1is__aosoa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html">CommunicationPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Communication plan base class.  <a href="classCabana_1_1CommunicationPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Distributor.html">Distributor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A communication plan for migrating data from one uniquely-owned decomposition to another uniquely owned decomposition.  <a href="classCabana_1_1Distributor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> static type checker.  <a href="structCabana_1_1is__distributor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1SimdPolicy.html">SimdPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution policy over a range of 2d indices.  <a href="classCabana_1_1SimdPolicy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01Experimental_1_1CrsGraph_3_01MemorySpace_00_01Tag_01_4_01_4.html">NeighborList&lt; Experimental::CrsGraph&lt; MemorySpace, Tag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">1d ArborX <a class="el" href="classCabana_1_1NeighborList.html" title="Neighbor list interface. Provides an interface callable at the functor level that gives access to nei...">NeighborList</a> interface.  <a href="classCabana_1_1NeighborList_3_01Experimental_1_1CrsGraph_3_01MemorySpace_00_01Tag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01Experimental_1_1Dense_3_01MemorySpace_00_01Tag_01_4_01_4.html">NeighborList&lt; Experimental::Dense&lt; MemorySpace, Tag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2d ArborX <a class="el" href="classCabana_1_1NeighborList.html" title="Neighbor list interface. Provides an interface callable at the functor level that gives access to nei...">NeighborList</a> interface.  <a href="classCabana_1_1NeighborList_3_01Experimental_1_1Dense_3_01MemorySpace_00_01Tag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Halo.html">Halo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A communication plan for scattering and gathering of ghosted data.  <a href="classCabana_1_1Halo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__halo.html">is_halo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1Halo.html" title="A communication plan for scattering and gathering of ghosted data.">Halo</a> static type checker.  <a href="structCabana_1_1is__halo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1LinkedCellList.html">LinkedCellList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesian grid.  <a href="classCabana_1_1LinkedCellList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1LinkedCellList.html" title="Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesia...">LinkedCellList</a> static type checker.  <a href="structCabana_1_1is__linked__cell__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1MemberTypes.html">MemberTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General sequence of types for <a class="el" href="structCabana_1_1SoA.html">SoA</a> and <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> member data.  <a href="structCabana_1_1MemberTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__member__types.html">is_member_types</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static type checker.  <a href="structCabana_1_1is__member__types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1MemberTypeAtIndex.html">MemberTypeAtIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the member at a given index.  <a href="structCabana_1_1MemberTypeAtIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1MemberTypeAtIndex_3_01M_00_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html">MemberTypeAtIndex&lt; M, MemberTypes&lt; Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the member at a given index.  <a href="structCabana_1_1MemberTypeAtIndex_3_01M_00_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1CheckMemberTypes.html">CheckMemberTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that member types are valid.  <a href="structCabana_1_1CheckMemberTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1CheckMemberTypes_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html">CheckMemberTypes&lt; MemberTypes&lt; Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that member types are valid.  <a href="structCabana_1_1CheckMemberTypes_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1FullNeighborTag.html">FullNeighborTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for full neighbor lists.  <a href="classCabana_1_1FullNeighborTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1HalfNeighborTag.html">HalfNeighborTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for half neighbor lists.  <a href="classCabana_1_1HalfNeighborTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList.html">NeighborList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor list interface. Provides an interface callable at the functor level that gives access to neighbor data for particles.  <a href="classCabana_1_1NeighborList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over particle neighbors.  <a href="classCabana_1_1FirstNeighborsTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over particle neighbors (first) and neighbor's neighbors (second)  <a href="classCabana_1_1SecondNeighborsTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor operations are executed in serial on each particle thread.  <a href="classCabana_1_1SerialOpTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor operations are executed with team parallelism.  <a href="classCabana_1_1TeamOpTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor operations are executed with team vector parallelism.  <a href="classCabana_1_1TeamVectorOpTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1PackTypeAtIndex.html">PackTypeAtIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type at the given index of a parameter pack.  <a href="structCabana_1_1PackTypeAtIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1ParameterPackElement.html">ParameterPackElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter pack element.  <a href="structCabana_1_1ParameterPackElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1ParameterPack.html">ParameterPack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__parameter__pack.html">is_parameter_pack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1ParameterPack.html">ParameterPack</a> static type checker.  <a href="structCabana_1_1is__parameter__pack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Slice.html">Slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.  <a href="classCabana_1_1Slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__slice.html">is_slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> static type checker.  <a href="structCabana_1_1is__slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1SoA.html">SoA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__soa.html">is_soa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1SoA.html">SoA</a> static type checker.  <a href="structCabana_1_1is__soa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1SoA_3_01MemberTypes_3_01Types_8_8_8_01_4_00_01VectorLength_01_4.html">SoA&lt; MemberTypes&lt; Types... &gt;, VectorLength &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct-of-Arrays.  <a href="structCabana_1_1SoA_3_01MemberTypes_3_01Types_8_8_8_01_4_00_01VectorLength_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data describing the bin sizes and offsets resulting from a binning operation.  <a href="classCabana_1_1BinningData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__binning__data_3_01const_01BinningData_3_01DeviceType_01_4_01_4.html">is_binning_data&lt; const BinningData&lt; DeviceType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1BinningData.html" title="Data describing the bin sizes and offsets resulting from a binning operation.">BinningData</a> static type checker.  <a href="structCabana_1_1is__binning__data_3_01const_01BinningData_3_01DeviceType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1Tuple.html">Tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Tuple.html">Tuple</a> static type checker.  <a href="structCabana_1_1is__tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1Tuple_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html">Tuple&lt; MemberTypes&lt; Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Tuple.html">Tuple</a>.  <a href="structCabana_1_1Tuple_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag.html">is_memory_access_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory access type checker.  <a href="structCabana_1_1is__memory__access__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1DefaultAccessMemory.html">DefaultAccessMemory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag_3_01DefaultAccessMemory_01_4.html">is_memory_access_tag&lt; DefaultAccessMemory &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory access type checker.  <a href="structCabana_1_1is__memory__access__tag_3_01DefaultAccessMemory_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1RandomAccessMemory.html">RandomAccessMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access memory. Read-only and const with limited spatial locality.  <a href="structCabana_1_1RandomAccessMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag_3_01RandomAccessMemory_01_4.html">is_memory_access_tag&lt; RandomAccessMemory &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1AtomicAccessMemory.html">AtomicAccessMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic memory access. All reads and writes are atomic.  <a href="structCabana_1_1AtomicAccessMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag_3_01AtomicAccessMemory_01_4.html">is_memory_access_tag&lt; AtomicAccessMemory &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__accessible__from.html">is_accessible_from</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__accessible__from_3_01MemorySpace_00_01ExecutionSpace_00_01std_1_1enable__if_96534d0f81e01b006272bb63cf2f3dd3.html">is_accessible_from&lt; MemorySpace, ExecutionSpace, std::enable_if_t&lt; Kokkos::SpaceAccessibility&lt; ExecutionSpace, MemorySpace &gt;::accessible &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletLayoutCSR.html">VerletLayoutCSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSR (compressed sparse row) neighbor list layout.  <a href="structCabana_1_1VerletLayoutCSR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletLayout2D.html">VerletLayout2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D array neighbor list layout.  <a href="structCabana_1_1VerletLayout2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletListData.html">VerletListData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletListData_3_01MemorySpace_00_01VerletLayoutCSR_01_4.html">VerletListData&lt; MemorySpace, VerletLayoutCSR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the <a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a 3d Cartesian grid with cells of the same...">VerletList</a> compressed sparse row (CSR) neighbor data.  <a href="structCabana_1_1VerletListData_3_01MemorySpace_00_01VerletLayoutCSR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletListData_3_01MemorySpace_00_01VerletLayout2D_01_4.html">VerletListData&lt; MemorySpace, VerletLayout2D &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the <a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a 3d Cartesian grid with cells of the same...">VerletList</a> 2D neighbor data.  <a href="structCabana_1_1VerletListData_3_01MemorySpace_00_01VerletLayout2D_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1VerletList.html">VerletList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor list implementation based on binning particles on a 3d Cartesian grid with cells of the same size as the interaction distance.  <a href="classCabana_1_1VerletList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01VerletLayoutCSR_00_01BuildTag_01_4_01_4.html">NeighborList&lt; VerletList&lt; MemorySpace, AlgorithmTag, VerletLayoutCSR, BuildTag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSR <a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a 3d Cartesian grid with cells of the same...">VerletList</a> <a class="el" href="classCabana_1_1NeighborList.html" title="Neighbor list interface. Provides an interface callable at the functor level that gives access to nei...">NeighborList</a> interface.  <a href="classCabana_1_1NeighborList_3_01VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01VerletLayoutCSR_00_01BuildTag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01VerletLayout2D_00_01BuildTag_01_4_01_4.html">NeighborList&lt; VerletList&lt; MemorySpace, AlgorithmTag, VerletLayout2D, BuildTag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D <a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a 3d Cartesian grid with cells of the same...">VerletList</a> <a class="el" href="classCabana_1_1NeighborList.html" title="Neighbor list interface. Provides an interface callable at the functor level that gives access to nei...">NeighborList</a> interface.  <a href="classCabana_1_1NeighborList_3_01VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01VerletLayout2D_00_01BuildTag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad6d068692acbf0642e84ce1f94b677c9"><td class="memTemplParams" colspan="2">template&lt;std::size_t M, class AoSoA_t &gt; </td></tr>
<tr class="memitem:ad6d068692acbf0642e84ce1f94b677c9"><td class="memTemplItemLeft" align="right" valign="top">AoSoA_t::template member_slice_type&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ad6d068692acbf0642e84ce1f94b677c9">slice</a> (const AoSoA_t &amp;aosoa, const std::string &amp;slice_label=&quot;&quot;)</td></tr>
<tr class="memdesc:ad6d068692acbf0642e84ce1f94b677c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a slice from an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <a href="namespaceCabana.html#ad6d068692acbf0642e84ce1f94b677c9">More...</a><br /></td></tr>
<tr class="separator:ad6d068692acbf0642e84ce1f94b677c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4000682688db62eb14635ce69f42e092"><td class="memTemplParams" colspan="2"><a id="a4000682688db62eb14635ce69f42e092"></a>
template&lt;class Space , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:a4000682688db62eb14635ce69f42e092"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a4000682688db62eb14635ce69f42e092">create_mirror</a> (const Space &amp;, const SrcAoSoA &amp;src, typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:a4000682688db62eb14635ce69f42e092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a mirror of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given space. <br /></td></tr>
<tr class="separator:a4000682688db62eb14635ce69f42e092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682f288aa48e84e44856d1a0b2239b43"><td class="memTemplParams" colspan="2">template&lt;class Space , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:a682f288aa48e84e44856d1a0b2239b43"><td class="memTemplItemLeft" align="right" valign="top">SrcAoSoA&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a682f288aa48e84e44856d1a0b2239b43">create_mirror_view</a> (const Space &amp;, const SrcAoSoA &amp;src, typename std::enable_if&lt;(std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:a682f288aa48e84e44856d1a0b2239b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given space. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <a href="namespaceCabana.html#a682f288aa48e84e44856d1a0b2239b43">More...</a><br /></td></tr>
<tr class="separator:a682f288aa48e84e44856d1a0b2239b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1766b5bf6655530bbeec104d9ef7d81"><td class="memTemplParams" colspan="2">template&lt;class Space , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:aa1766b5bf6655530bbeec104d9ef7d81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#aa1766b5bf6655530bbeec104d9ef7d81">create_mirror_view</a> (const Space &amp;space, const SrcAoSoA &amp;src, typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:aa1766b5bf6655530bbeec104d9ef7d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <a href="namespaceCabana.html#aa1766b5bf6655530bbeec104d9ef7d81">More...</a><br /></td></tr>
<tr class="separator:aa1766b5bf6655530bbeec104d9ef7d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22f02b41130e19d3e1f071373ac69c9"><td class="memTemplParams" colspan="2">template&lt;class Space , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:ab22f02b41130e19d3e1f071373ac69c9"><td class="memTemplItemLeft" align="right" valign="top">SrcAoSoA&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab22f02b41130e19d3e1f071373ac69c9">create_mirror_view_and_copy</a> (const Space &amp;, const SrcAoSoA &amp;src, typename std::enable_if&lt;(std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:ab22f02b41130e19d3e1f071373ac69c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and copy the contents of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <a href="namespaceCabana.html#ab22f02b41130e19d3e1f071373ac69c9">More...</a><br /></td></tr>
<tr class="separator:ab22f02b41130e19d3e1f071373ac69c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b46fdf8a6a9140734d372ff5df15d3"><td class="memTemplParams" colspan="2">template&lt;class Space , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:ae5b46fdf8a6a9140734d372ff5df15d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ae5b46fdf8a6a9140734d372ff5df15d3">create_mirror_view_and_copy</a> (const Space &amp;space, const SrcAoSoA &amp;src, typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:ae5b46fdf8a6a9140734d372ff5df15d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and deep copy the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> into the mirror. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> and performs the deep copy.  <a href="namespaceCabana.html#ae5b46fdf8a6a9140734d372ff5df15d3">More...</a><br /></td></tr>
<tr class="separator:ae5b46fdf8a6a9140734d372ff5df15d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1932d2c9be351d64dfcb6e2d22fc68c8"><td class="memTemplParams" colspan="2">template&lt;class DstAoSoA , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:a1932d2c9be351d64dfcb6e2d22fc68c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a1932d2c9be351d64dfcb6e2d22fc68c8">deep_copy</a> (DstAoSoA &amp;dst, const SrcAoSoA &amp;src, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; DstAoSoA &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:a1932d2c9be351d64dfcb6e2d22fc68c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy data between compatible <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> objects.  <a href="namespaceCabana.html#a1932d2c9be351d64dfcb6e2d22fc68c8">More...</a><br /></td></tr>
<tr class="separator:a1932d2c9be351d64dfcb6e2d22fc68c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f82fe027dec446d5ff114b36e2a30be"><td class="memTemplParams" colspan="2">template&lt;class AoSoA_t &gt; </td></tr>
<tr class="memitem:a0f82fe027dec446d5ff114b36e2a30be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a0f82fe027dec446d5ff114b36e2a30be">deep_copy</a> (AoSoA_t &amp;aosoa, const typename AoSoA_t::tuple_type &amp;tuple)</td></tr>
<tr class="memdesc:a0f82fe027dec446d5ff114b36e2a30be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> with a tuple.  <a href="namespaceCabana.html#a0f82fe027dec446d5ff114b36e2a30be">More...</a><br /></td></tr>
<tr class="separator:a0f82fe027dec446d5ff114b36e2a30be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c2588c68205d46f36b60be2afff96e"><td class="memTemplParams" colspan="2">template&lt;class DstSlice , class SrcSlice &gt; </td></tr>
<tr class="memitem:ab6c2588c68205d46f36b60be2afff96e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab6c2588c68205d46f36b60be2afff96e">deep_copy</a> (DstSlice &amp;dst, const SrcSlice &amp;src, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; DstSlice &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SrcSlice &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:ab6c2588c68205d46f36b60be2afff96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy data between compatible <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> objects.  <a href="namespaceCabana.html#ab6c2588c68205d46f36b60be2afff96e">More...</a><br /></td></tr>
<tr class="separator:ab6c2588c68205d46f36b60be2afff96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae209c92053381625d4d040bb1f74682b"><td class="memTemplParams" colspan="2">template&lt;class Slice_t &gt; </td></tr>
<tr class="memitem:ae209c92053381625d4d040bb1f74682b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ae209c92053381625d4d040bb1f74682b">deep_copy</a> (Slice_t &amp;<a class="el" href="namespaceCabana.html#ad6d068692acbf0642e84ce1f94b677c9">slice</a>, const typename Slice_t::value_type scalar)</td></tr>
<tr class="memdesc:ae209c92053381625d4d040bb1f74682b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a slice with a scalar.  <a href="namespaceCabana.html#ae209c92053381625d4d040bb1f74682b">More...</a><br /></td></tr>
<tr class="separator:ae209c92053381625d4d040bb1f74682b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb10ac278624d871f6079c4e24ccb219"><td class="memTemplParams" colspan="2">template&lt;class Distributor_t , class AoSoA_t &gt; </td></tr>
<tr class="memitem:adb10ac278624d871f6079c4e24ccb219"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#adb10ac278624d871f6079c4e24ccb219">migrate</a> (const Distributor_t &amp;distributor, const AoSoA_t &amp;src, AoSoA_t &amp;dst, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:adb10ac278624d871f6079c4e24ccb219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. Multiple <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version.  <a href="namespaceCabana.html#adb10ac278624d871f6079c4e24ccb219">More...</a><br /></td></tr>
<tr class="separator:adb10ac278624d871f6079c4e24ccb219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cb44110c8a6215d2ca62406e8aed35"><td class="memTemplParams" colspan="2">template&lt;class Distributor_t , class AoSoA_t &gt; </td></tr>
<tr class="memitem:ab9cb44110c8a6215d2ca62406e8aed35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab9cb44110c8a6215d2ca62406e8aed35">migrate</a> (const Distributor_t &amp;distributor, AoSoA_t &amp;aosoa, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ab9cb44110c8a6215d2ca62406e8aed35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. Single <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version that will resize in-place. Note that resizing does not necessarily allocate more memory. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> memory will only increase if not enough has already been reserved/allocated for the needed number of elements.  <a href="namespaceCabana.html#ab9cb44110c8a6215d2ca62406e8aed35">More...</a><br /></td></tr>
<tr class="separator:ab9cb44110c8a6215d2ca62406e8aed35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82063f55f2d0c3d17d11ba6642fb7353"><td class="memTemplParams" colspan="2">template&lt;class Distributor_t , class Slice_t &gt; </td></tr>
<tr class="memitem:a82063f55f2d0c3d17d11ba6642fb7353"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a82063f55f2d0c3d17d11ba6642fb7353">migrate</a> (const Distributor_t &amp;distributor, const Slice_t &amp;src, Slice_t &amp;dst, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a82063f55f2d0c3d17d11ba6642fb7353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. The user can do this in-place with the same slice but they will need to manage the resizing themselves as we can't resize slices.  <a href="namespaceCabana.html#a82063f55f2d0c3d17d11ba6642fb7353">More...</a><br /></td></tr>
<tr class="separator:a82063f55f2d0c3d17d11ba6642fb7353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dd17069284c2039235e463b2d885ee"><td class="memTemplParams" colspan="2">template&lt;class Halo_t , class AoSoA_t &gt; </td></tr>
<tr class="memitem:ac0dd17069284c2039235e463b2d885ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ac0dd17069284c2039235e463b2d885ee">gather</a> (const Halo_t &amp;halo, AoSoA_t &amp;aosoa, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; Halo_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ac0dd17069284c2039235e463b2d885ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version. This is a uniquely-owned to multiply-owned communication.  <a href="namespaceCabana.html#ac0dd17069284c2039235e463b2d885ee">More...</a><br /></td></tr>
<tr class="separator:ac0dd17069284c2039235e463b2d885ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c97a585251f273cc3ed77bda475af8c"><td class="memTemplParams" colspan="2">template&lt;class Halo_t , class Slice_t &gt; </td></tr>
<tr class="memitem:a2c97a585251f273cc3ed77bda475af8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a2c97a585251f273cc3ed77bda475af8c">gather</a> (const Halo_t &amp;halo, Slice_t &amp;<a class="el" href="namespaceCabana.html#ad6d068692acbf0642e84ce1f94b677c9">slice</a>, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; Halo_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a2c97a585251f273cc3ed77bda475af8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. This is a uniquely-owned to multiply-owned communication.  <a href="namespaceCabana.html#a2c97a585251f273cc3ed77bda475af8c">More...</a><br /></td></tr>
<tr class="separator:a2c97a585251f273cc3ed77bda475af8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22a4214a72df81e7678162494c38dd0"><td class="memTemplParams" colspan="2">template&lt;class Halo_t , class Slice_t &gt; </td></tr>
<tr class="memitem:af22a4214a72df81e7678162494c38dd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#af22a4214a72df81e7678162494c38dd0">scatter</a> (const Halo_t &amp;halo, Slice_t &amp;<a class="el" href="namespaceCabana.html#ad6d068692acbf0642e84ce1f94b677c9">slice</a>, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; Halo_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:af22a4214a72df81e7678162494c38dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously scatter data from the ghosts to the local decomposition of a slice using the halo reverse communication plan. This is a multiply-owned to uniquely owned communication.  <a href="namespaceCabana.html#af22a4214a72df81e7678162494c38dd0">More...</a><br /></td></tr>
<tr class="separator:af22a4214a72df81e7678162494c38dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c3a57c3cd27a75094bbfa1be56145b"><td class="memTemplParams" colspan="2">template&lt;class LinkedCellListType , class AoSoA_t &gt; </td></tr>
<tr class="memitem:a02c3a57c3cd27a75094bbfa1be56145b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a02c3a57c3cd27a75094bbfa1be56145b">permute</a> (const LinkedCellListType &amp;linked_cell_list, AoSoA_t &amp;aosoa, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellListType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a02c3a57c3cd27a75094bbfa1be56145b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a linked cell list permute an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <a href="namespaceCabana.html#a02c3a57c3cd27a75094bbfa1be56145b">More...</a><br /></td></tr>
<tr class="separator:a02c3a57c3cd27a75094bbfa1be56145b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1ce7155c5c1185f46071b20d4dd332"><td class="memTemplParams" colspan="2">template&lt;class LinkedCellListType , class SliceType &gt; </td></tr>
<tr class="memitem:a5a1ce7155c5c1185f46071b20d4dd332"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a5a1ce7155c5c1185f46071b20d4dd332">permute</a> (const LinkedCellListType &amp;linked_cell_list, SliceType &amp;<a class="el" href="namespaceCabana.html#ad6d068692acbf0642e84ce1f94b677c9">slice</a>, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellListType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a5a1ce7155c5c1185f46071b20d4dd332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a linked cell list permute a slice.  <a href="namespaceCabana.html#a5a1ce7155c5c1185f46071b20d4dd332">More...</a><br /></td></tr>
<tr class="separator:a5a1ce7155c5c1185f46071b20d4dd332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , int VectorLength, class... ExecParameters&gt; </td></tr>
<tr class="memitem:ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab7dda1a05e595dbec3f4f06e7f878d9e">simd_parallel_for</a> (const <a class="el" href="classCabana_1_1SimdPolicy.html">SimdPolicy</a>&lt; VectorLength, ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a vectorized functor in parallel with a 2d execution policy.  <a href="namespaceCabana.html#ab7dda1a05e595dbec3f4f06e7f878d9e">More...</a><br /></td></tr>
<tr class="separator:ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb924882c14a90b695a56065f4106c22"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:acb924882c14a90b695a56065f4106c22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#acb924882c14a90b695a56065f4106c22">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:acb924882c14a90b695a56065f4106c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with a thread-local serial loop over particle first neighbors.  <a href="namespaceCabana.html#acb924882c14a90b695a56065f4106c22">More...</a><br /></td></tr>
<tr class="separator:acb924882c14a90b695a56065f4106c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10eeaa254bbc26461eadae4d9a0a1598"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:a10eeaa254bbc26461eadae4d9a0a1598"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a10eeaa254bbc26461eadae4d9a0a1598">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:a10eeaa254bbc26461eadae4d9a0a1598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with thread-local serial loops over particle first and second neighbors.  <a href="namespaceCabana.html#a10eeaa254bbc26461eadae4d9a0a1598">More...</a><br /></td></tr>
<tr class="separator:a10eeaa254bbc26461eadae4d9a0a1598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cb6955452842c7903e86a845329e7c"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:ac2cb6955452842c7903e86a845329e7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ac2cb6955452842c7903e86a845329e7c">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:ac2cb6955452842c7903e86a845329e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors.  <a href="namespaceCabana.html#ac2cb6955452842c7903e86a845329e7c">More...</a><br /></td></tr>
<tr class="separator:ac2cb6955452842c7903e86a845329e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca1d55078d6cfea288c6cec130ef204"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:acca1d55078d6cfea288c6cec130ef204"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#acca1d55078d6cfea288c6cec130ef204">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:acca1d55078d6cfea288c6cec130ef204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors and serial loop over second neighbors.  <a href="namespaceCabana.html#acca1d55078d6cfea288c6cec130ef204">More...</a><br /></td></tr>
<tr class="separator:acca1d55078d6cfea288c6cec130ef204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dae9114f1f2ede7f1925a0c73c7639b"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:a3dae9114f1f2ede7f1925a0c73c7639b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a3dae9114f1f2ede7f1925a0c73c7639b">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a>, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:a3dae9114f1f2ede7f1925a0c73c7639b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors and vector loop parallelism over second neighbors.  <a href="namespaceCabana.html#a3dae9114f1f2ede7f1925a0c73c7639b">More...</a><br /></td></tr>
<tr class="separator:a3dae9114f1f2ede7f1925a0c73c7639b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e94d9a9c1af171bdbb8c4362c23aa0"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:af7e94d9a9c1af171bdbb8c4362c23aa0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#af7e94d9a9c1af171bdbb8c4362c23aa0">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:af7e94d9a9c1af171bdbb8c4362c23aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor reduction in parallel according to the execution policy over particles with a thread-local serial loop over particle first neighbors.  <a href="namespaceCabana.html#af7e94d9a9c1af171bdbb8c4362c23aa0">More...</a><br /></td></tr>
<tr class="separator:af7e94d9a9c1af171bdbb8c4362c23aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949a3b9f4fd10c8f6b05267870eca331"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:a949a3b9f4fd10c8f6b05267870eca331"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a949a3b9f4fd10c8f6b05267870eca331">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:a949a3b9f4fd10c8f6b05267870eca331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor reduction in parallel according to the execution policy over particles with thread-local serial loops over particle first and second neighbors.  <a href="namespaceCabana.html#a949a3b9f4fd10c8f6b05267870eca331">More...</a><br /></td></tr>
<tr class="separator:a949a3b9f4fd10c8f6b05267870eca331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2295a3434a7b25d87832e522474f91"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:abb2295a3434a7b25d87832e522474f91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#abb2295a3434a7b25d87832e522474f91">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:abb2295a3434a7b25d87832e522474f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors.  <a href="namespaceCabana.html#abb2295a3434a7b25d87832e522474f91">More...</a><br /></td></tr>
<tr class="separator:abb2295a3434a7b25d87832e522474f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad67e6a4c72546175d974afd501a5fb"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:afad67e6a4c72546175d974afd501a5fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#afad67e6a4c72546175d974afd501a5fb">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:afad67e6a4c72546175d974afd501a5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors and serial loop over second neighbors.  <a href="namespaceCabana.html#afad67e6a4c72546175d974afd501a5fb">More...</a><br /></td></tr>
<tr class="separator:afad67e6a4c72546175d974afd501a5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd64556212553a3ada775f74735afe30"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:afd64556212553a3ada775f74735afe30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#afd64556212553a3ada775f74735afe30">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:afd64556212553a3ada775f74735afe30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors and vector loop parallelism over second neighbors.  <a href="namespaceCabana.html#afd64556212553a3ada775f74735afe30">More...</a><br /></td></tr>
<tr class="separator:afd64556212553a3ada775f74735afe30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="memTemplParams" colspan="2">template&lt;class IndexType , class FunctorType , class NeighborListType &gt; </td></tr>
<tr class="memitem:a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a15dca4f62c3f1f9cb7a9c869c7ae3486">for_each_neighbor</a> (const IndexType i, const FunctorType &amp;neighbor_functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>)</td></tr>
<tr class="memdesc:a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in serial within existing parallel kernel over particle first neighbors.  <a href="namespaceCabana.html#a15dca4f62c3f1f9cb7a9c869c7ae3486">More...</a><br /></td></tr>
<tr class="separator:a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366034424ecf96ad51645694c2d71676"><td class="memTemplParams" colspan="2">template&lt;class IndexType , class FunctorType , class NeighborListType , class TeamMemberType &gt; </td></tr>
<tr class="memitem:a366034424ecf96ad51645694c2d71676"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a366034424ecf96ad51645694c2d71676">for_each_neighbor</a> (const IndexType i, const TeamMemberType team, const FunctorType &amp;neighbor_functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>)</td></tr>
<tr class="memdesc:a366034424ecf96ad51645694c2d71676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute team parallel functor within existing parallel kernel over particle first neighbors.  <a href="namespaceCabana.html#a366034424ecf96ad51645694c2d71676">More...</a><br /></td></tr>
<tr class="separator:a366034424ecf96ad51645694c2d71676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e6b7aab0a76b7224ca27f2d7c0d773"><td class="memTemplParams" colspan="2"><a id="ae5e6b7aab0a76b7224ca27f2d7c0d773"></a>
template&lt;std::size_t N, class ParameterPack_t &gt; </td></tr>
<tr class="memitem:ae5e6b7aab0a76b7224ca27f2d7c0d773"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__parameter__pack.html">is_parameter_pack</a>&lt; ParameterPack_t &gt;::value, typename ParameterPack_t::template value_type&lt; N &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ae5e6b7aab0a76b7224ca27f2d7c0d773">get</a> (ParameterPack_t &amp;pp)</td></tr>
<tr class="memdesc:ae5e6b7aab0a76b7224ca27f2d7c0d773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an element from a parameter pack. <br /></td></tr>
<tr class="separator:ae5e6b7aab0a76b7224ca27f2d7c0d773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2d41e5a38af62e09889c7ebd40ff08"><td class="memTemplParams" colspan="2"><a id="acd2d41e5a38af62e09889c7ebd40ff08"></a>
template&lt;std::size_t N, class ParameterPack_t &gt; </td></tr>
<tr class="memitem:acd2d41e5a38af62e09889c7ebd40ff08"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__parameter__pack.html">is_parameter_pack</a>&lt; ParameterPack_t &gt;::value, const typename ParameterPack_t::template value_type&lt; N &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#acd2d41e5a38af62e09889c7ebd40ff08">get</a> (const ParameterPack_t &amp;pp)</td></tr>
<tr class="memdesc:acd2d41e5a38af62e09889c7ebd40ff08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an element from a parameter pack. <br /></td></tr>
<tr class="separator:acd2d41e5a38af62e09889c7ebd40ff08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1bdb5946e4dfb5f96695e6cee6484d"><td class="memTemplParams" colspan="2">template&lt;typename ParameterPack_t , typename... Types&gt; </td></tr>
<tr class="memitem:a6b1bdb5946e4dfb5f96695e6cee6484d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a6b1bdb5946e4dfb5f96695e6cee6484d">fillParameterPack</a> (ParameterPack_t &amp;pp, const Types &amp;... ts)</td></tr>
<tr class="separator:a6b1bdb5946e4dfb5f96695e6cee6484d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b83ffcd0599afe7840925786c8ecdc2"><td class="memTemplParams" colspan="2"><a id="a7b83ffcd0599afe7840925786c8ecdc2"></a>
template&lt;typename ParameterPack_t &gt; </td></tr>
<tr class="memitem:a7b83ffcd0599afe7840925786c8ecdc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a7b83ffcd0599afe7840925786c8ecdc2">fillParameterPack</a> (ParameterPack_t &amp;)</td></tr>
<tr class="memdesc:a7b83ffcd0599afe7840925786c8ecdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty case - fill a parameter pack. <br /></td></tr>
<tr class="separator:a7b83ffcd0599afe7840925786c8ecdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f38e1ad9eb9a3e1c5cc2a04000551b9"><td class="memTemplParams" colspan="2"><a id="a6f38e1ad9eb9a3e1c5cc2a04000551b9"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a6f38e1ad9eb9a3e1c5cc2a04000551b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCabana_1_1ParameterPack.html">ParameterPack</a>&lt; Types... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a6f38e1ad9eb9a3e1c5cc2a04000551b9">makeParameterPack</a> (const Types &amp;... ts)</td></tr>
<tr class="memdesc:a6f38e1ad9eb9a3e1c5cc2a04000551b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a parameter pack. <br /></td></tr>
<tr class="separator:a6f38e1ad9eb9a3e1c5cc2a04000551b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace85c21cdc66c52ead3d7dcf3d168ee8"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class PositionType &gt; </td></tr>
<tr class="memitem:ace85c21cdc66c52ead3d7dcf3d168ee8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ace85c21cdc66c52ead3d7dcf3d168ee8">createRandomParticlesMinDistance</a> (ExecutionSpace, PositionType &amp;positions, const std::size_t num_particles, const double box_min, const double box_max, const double min_dist)</td></tr>
<tr class="separator:ace85c21cdc66c52ead3d7dcf3d168ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0ca04a76c59609d5f9985bc5f0f87d"><td class="memTemplParams" colspan="2">template&lt;class PositionType &gt; </td></tr>
<tr class="memitem:a9f0ca04a76c59609d5f9985bc5f0f87d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a9f0ca04a76c59609d5f9985bc5f0f87d">createRandomParticlesMinDistance</a> (PositionType &amp;positions, const std::size_t num_particles, const double box_min, const double box_max, const double min_dist)</td></tr>
<tr class="separator:a9f0ca04a76c59609d5f9985bc5f0f87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fde813f3720b5946f711274368cd1a"><td class="memTemplParams" colspan="2"><a id="a89fde813f3720b5946f711274368cd1a"></a>
template&lt;class ExecutionSpace , class PositionType &gt; </td></tr>
<tr class="memitem:a89fde813f3720b5946f711274368cd1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a89fde813f3720b5946f711274368cd1a">createRandomParticles</a> (ExecutionSpace, PositionType &amp;positions, const std::size_t num_particles, const double box_min, const double box_max)</td></tr>
<tr class="memdesc:a89fde813f3720b5946f711274368cd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random particles. Kokkos device version. <br /></td></tr>
<tr class="separator:a89fde813f3720b5946f711274368cd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab460bf0f1b72014755b0bd79426b9df8"><td class="memTemplParams" colspan="2">template&lt;class PositionType &gt; </td></tr>
<tr class="memitem:ab460bf0f1b72014755b0bd79426b9df8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab460bf0f1b72014755b0bd79426b9df8">createRandomParticles</a> (PositionType &amp;positions, const std::size_t num_particles, const double box_min, const double box_max)</td></tr>
<tr class="separator:ab460bf0f1b72014755b0bd79426b9df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aab31b7d2fef61f7b49251c301d441d"><td class="memTemplParams" colspan="2"><a id="a0aab31b7d2fef61f7b49251c301d441d"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a0aab31b7d2fef61f7b49251c301d441d"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a0aab31b7d2fef61f7b49251c301d441d">get</a> (SoA_t &amp;soa, const std::size_t a)</td></tr>
<tr class="memdesc:a0aab31b7d2fef61f7b49251c301d441d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-0 non-const. <br /></td></tr>
<tr class="separator:a0aab31b7d2fef61f7b49251c301d441d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab320f9af9e1b558941d7738dcf35ac8"><td class="memTemplParams" colspan="2"><a id="aab320f9af9e1b558941d7738dcf35ac8"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:aab320f9af9e1b558941d7738dcf35ac8"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#aab320f9af9e1b558941d7738dcf35ac8">get</a> (const SoA_t &amp;soa, const std::size_t a)</td></tr>
<tr class="memdesc:aab320f9af9e1b558941d7738dcf35ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-0 const. <br /></td></tr>
<tr class="separator:aab320f9af9e1b558941d7738dcf35ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d0aed6ba4c5510c803e41352ed1a8f"><td class="memTemplParams" colspan="2"><a id="a83d0aed6ba4c5510c803e41352ed1a8f"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a83d0aed6ba4c5510c803e41352ed1a8f"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a83d0aed6ba4c5510c803e41352ed1a8f">get</a> (SoA_t &amp;soa, const std::size_t a, const std::size_t d0)</td></tr>
<tr class="memdesc:a83d0aed6ba4c5510c803e41352ed1a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-1 non-const. <br /></td></tr>
<tr class="separator:a83d0aed6ba4c5510c803e41352ed1a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fbfd236f0a376ce95a568002658889"><td class="memTemplParams" colspan="2"><a id="a79fbfd236f0a376ce95a568002658889"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a79fbfd236f0a376ce95a568002658889"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a79fbfd236f0a376ce95a568002658889">get</a> (const SoA_t &amp;soa, const std::size_t a, const std::size_t d0)</td></tr>
<tr class="memdesc:a79fbfd236f0a376ce95a568002658889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-1 const. <br /></td></tr>
<tr class="separator:a79fbfd236f0a376ce95a568002658889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bcf5c9c68d55c144b93ee37ca12a97"><td class="memTemplParams" colspan="2"><a id="ab5bcf5c9c68d55c144b93ee37ca12a97"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:ab5bcf5c9c68d55c144b93ee37ca12a97"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab5bcf5c9c68d55c144b93ee37ca12a97">get</a> (SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="memdesc:ab5bcf5c9c68d55c144b93ee37ca12a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-2 non-const. <br /></td></tr>
<tr class="separator:ab5bcf5c9c68d55c144b93ee37ca12a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa1a2579b2acd4f691ebd084b37ab95"><td class="memTemplParams" colspan="2"><a id="a8aa1a2579b2acd4f691ebd084b37ab95"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a8aa1a2579b2acd4f691ebd084b37ab95"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a8aa1a2579b2acd4f691ebd084b37ab95">get</a> (const SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="memdesc:a8aa1a2579b2acd4f691ebd084b37ab95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-2 const. <br /></td></tr>
<tr class="separator:a8aa1a2579b2acd4f691ebd084b37ab95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c259fb6ad5568465e088ce86f2714a"><td class="memTemplParams" colspan="2"><a id="a90c259fb6ad5568465e088ce86f2714a"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a90c259fb6ad5568465e088ce86f2714a"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a90c259fb6ad5568465e088ce86f2714a">get</a> (SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="memdesc:a90c259fb6ad5568465e088ce86f2714a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-3 non-const. <br /></td></tr>
<tr class="separator:a90c259fb6ad5568465e088ce86f2714a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929d967bcdc7b7e26092bb714348be90"><td class="memTemplParams" colspan="2"><a id="a929d967bcdc7b7e26092bb714348be90"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a929d967bcdc7b7e26092bb714348be90"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typename SoA_t::template member_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a929d967bcdc7b7e26092bb714348be90">get</a> (const SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="memdesc:a929d967bcdc7b7e26092bb714348be90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-3 const. <br /></td></tr>
<tr class="separator:a929d967bcdc7b7e26092bb714348be90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74033479f79c2c5e1831bf9a88234ef9"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:a74033479f79c2c5e1831bf9a88234ef9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a74033479f79c2c5e1831bf9a88234ef9">sortByKeyWithComparator</a> (KeyViewType keys, Comparator comp, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a74033479f79c2c5e1831bf9a88234ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys.  <a href="namespaceCabana.html#a74033479f79c2c5e1831bf9a88234ef9">More...</a><br /></td></tr>
<tr class="separator:a74033479f79c2c5e1831bf9a88234ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7d211b39c3007dff87e7d9a03bd777"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:a7e7d211b39c3007dff87e7d9a03bd777"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a7e7d211b39c3007dff87e7d9a03bd777">sortByKeyWithComparator</a> (KeyViewType keys, Comparator comp, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a7e7d211b39c3007dff87e7d9a03bd777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys.  <a href="namespaceCabana.html#a7e7d211b39c3007dff87e7d9a03bd777">More...</a><br /></td></tr>
<tr class="separator:a7e7d211b39c3007dff87e7d9a03bd777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69aceca61e0460f10c38fa9ad329cd0d"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:a69aceca61e0460f10c38fa9ad329cd0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a69aceca61e0460f10c38fa9ad329cd0d">binByKeyWithComparator</a> (KeyViewType keys, Comparator comp, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a69aceca61e0460f10c38fa9ad329cd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys.  <a href="namespaceCabana.html#a69aceca61e0460f10c38fa9ad329cd0d">More...</a><br /></td></tr>
<tr class="separator:a69aceca61e0460f10c38fa9ad329cd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09392355b60acbaa717d5f26ab15873"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:ad09392355b60acbaa717d5f26ab15873"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ad09392355b60acbaa717d5f26ab15873">binByKeyWithComparator</a> (KeyViewType keys, Comparator comp, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ad09392355b60acbaa717d5f26ab15873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys.  <a href="namespaceCabana.html#ad09392355b60acbaa717d5f26ab15873">More...</a><br /></td></tr>
<tr class="separator:ad09392355b60acbaa717d5f26ab15873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb212c9d4bf5dd79dca6393dd5cd1d50"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:afb212c9d4bf5dd79dca6393dd5cd1d50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#afb212c9d4bf5dd79dca6393dd5cd1d50">sortByKey</a> (KeyViewType keys, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:afb212c9d4bf5dd79dca6393dd5cd1d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values.  <a href="namespaceCabana.html#afb212c9d4bf5dd79dca6393dd5cd1d50">More...</a><br /></td></tr>
<tr class="separator:afb212c9d4bf5dd79dca6393dd5cd1d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5de120bd7e1dd83a15d85ac2121633b"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:ad5de120bd7e1dd83a15d85ac2121633b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ad5de120bd7e1dd83a15d85ac2121633b">sortByKey</a> (KeyViewType keys, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ad5de120bd7e1dd83a15d85ac2121633b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values.  <a href="namespaceCabana.html#ad5de120bd7e1dd83a15d85ac2121633b">More...</a><br /></td></tr>
<tr class="separator:ad5de120bd7e1dd83a15d85ac2121633b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604397e80ba71af071611b748e0cecde"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:a604397e80ba71af071611b748e0cecde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a604397e80ba71af071611b748e0cecde">binByKey</a> (KeyViewType keys, const int nbin, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a604397e80ba71af071611b748e0cecde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values and number of bins. The bins are evenly divided over the range of key values.  <a href="namespaceCabana.html#a604397e80ba71af071611b748e0cecde">More...</a><br /></td></tr>
<tr class="separator:a604397e80ba71af071611b748e0cecde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298e4012225366d9a9fdf7b9a867f641"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </td></tr>
<tr class="memitem:a298e4012225366d9a9fdf7b9a867f641"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a298e4012225366d9a9fdf7b9a867f641">binByKey</a> (KeyViewType keys, const int nbin, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a298e4012225366d9a9fdf7b9a867f641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values and number of bins. The bins are evenly divided over the range of key values.  <a href="namespaceCabana.html#a298e4012225366d9a9fdf7b9a867f641">More...</a><br /></td></tr>
<tr class="separator:a298e4012225366d9a9fdf7b9a867f641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a4311d29473e2ecdab7927aaff49ad"><td class="memTemplParams" colspan="2">template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </td></tr>
<tr class="memitem:a91a4311d29473e2ecdab7927aaff49ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a91a4311d29473e2ecdab7927aaff49ad">sortByKey</a> (SliceType <a class="el" href="namespaceCabana.html#ad6d068692acbf0642e84ce1f94b677c9">slice</a>, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a91a4311d29473e2ecdab7927aaff49ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys.  <a href="namespaceCabana.html#a91a4311d29473e2ecdab7927aaff49ad">More...</a><br /></td></tr>
<tr class="separator:a91a4311d29473e2ecdab7927aaff49ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95cdaf6584250a53d942bbe99e5e78e"><td class="memTemplParams" colspan="2">template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </td></tr>
<tr class="memitem:af95cdaf6584250a53d942bbe99e5e78e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#af95cdaf6584250a53d942bbe99e5e78e">sortByKey</a> (SliceType <a class="el" href="namespaceCabana.html#ad6d068692acbf0642e84ce1f94b677c9">slice</a>, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:af95cdaf6584250a53d942bbe99e5e78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys.  <a href="namespaceCabana.html#af95cdaf6584250a53d942bbe99e5e78e">More...</a><br /></td></tr>
<tr class="separator:af95cdaf6584250a53d942bbe99e5e78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e2eca356e99a00cf3f2f5848f5cf7a"><td class="memTemplParams" colspan="2">template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </td></tr>
<tr class="memitem:ad3e2eca356e99a00cf3f2f5848f5cf7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ad3e2eca356e99a00cf3f2f5848f5cf7a">binByKey</a> (SliceType <a class="el" href="namespaceCabana.html#ad6d068692acbf0642e84ce1f94b677c9">slice</a>, const int nbin, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ad3e2eca356e99a00cf3f2f5848f5cf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys.  <a href="namespaceCabana.html#ad3e2eca356e99a00cf3f2f5848f5cf7a">More...</a><br /></td></tr>
<tr class="separator:ad3e2eca356e99a00cf3f2f5848f5cf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3328dc23cbfede2bd40bcdd2fdd9074"><td class="memTemplParams" colspan="2">template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </td></tr>
<tr class="memitem:aa3328dc23cbfede2bd40bcdd2fdd9074"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#aa3328dc23cbfede2bd40bcdd2fdd9074">binByKey</a> (SliceType <a class="el" href="namespaceCabana.html#ad6d068692acbf0642e84ce1f94b677c9">slice</a>, const int nbin, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:aa3328dc23cbfede2bd40bcdd2fdd9074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys.  <a href="namespaceCabana.html#aa3328dc23cbfede2bd40bcdd2fdd9074">More...</a><br /></td></tr>
<tr class="separator:aa3328dc23cbfede2bd40bcdd2fdd9074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824f296314f00ca8e121e6a26e2846db"><td class="memTemplParams" colspan="2">template&lt;class BinningDataType , class AoSoA_t , class DeviceType  = typename BinningDataType::device_type&gt; </td></tr>
<tr class="memitem:a824f296314f00ca8e121e6a26e2846db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a824f296314f00ca8e121e6a26e2846db">permute</a> (const BinningDataType &amp;binning_data, AoSoA_t &amp;aosoa, typename std::enable_if&lt;(is_binning_data&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a824f296314f00ca8e121e6a26e2846db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given binning data permute an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <a href="namespaceCabana.html#a824f296314f00ca8e121e6a26e2846db">More...</a><br /></td></tr>
<tr class="separator:a824f296314f00ca8e121e6a26e2846db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44a65c22331c71ed7cee721a41c54fc"><td class="memTemplParams" colspan="2">template&lt;class BinningDataType , class SliceType , class DeviceType  = typename BinningDataType::device_type&gt; </td></tr>
<tr class="memitem:ab44a65c22331c71ed7cee721a41c54fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab44a65c22331c71ed7cee721a41c54fc">permute</a> (const BinningDataType &amp;binning_data, SliceType &amp;<a class="el" href="namespaceCabana.html#ad6d068692acbf0642e84ce1f94b677c9">slice</a>, typename std::enable_if&lt;(is_binning_data&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ab44a65c22331c71ed7cee721a41c54fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given binning data permute a slice.  <a href="namespaceCabana.html#ab44a65c22331c71ed7cee721a41c54fc">More...</a><br /></td></tr>
<tr class="separator:ab44a65c22331c71ed7cee721a41c54fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e20e9c067d985394d69366af5cd882"><td class="memTemplParams" colspan="2"><a id="a30e20e9c067d985394d69366af5cd882"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a30e20e9c067d985394d69366af5cd882"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typename Tuple_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a30e20e9c067d985394d69366af5cd882">get</a> (Tuple_t &amp;tp)</td></tr>
<tr class="memdesc:a30e20e9c067d985394d69366af5cd882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-0 non-const. <br /></td></tr>
<tr class="separator:a30e20e9c067d985394d69366af5cd882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f93f17fcbbbc63f83e03e7d5c4a6d08"><td class="memTemplParams" colspan="2"><a id="a0f93f17fcbbbc63f83e03e7d5c4a6d08"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a0f93f17fcbbbc63f83e03e7d5c4a6d08"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION Tuple_t::template member_const_reference_type&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a0f93f17fcbbbc63f83e03e7d5c4a6d08">get</a> (const Tuple_t &amp;tp)</td></tr>
<tr class="memdesc:a0f93f17fcbbbc63f83e03e7d5c4a6d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-0 const. <br /></td></tr>
<tr class="separator:a0f93f17fcbbbc63f83e03e7d5c4a6d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2354c80a56abe0e99df1eff351584f31"><td class="memTemplParams" colspan="2"><a id="a2354c80a56abe0e99df1eff351584f31"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a2354c80a56abe0e99df1eff351584f31"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typename Tuple_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a2354c80a56abe0e99df1eff351584f31">get</a> (Tuple_t &amp;tp, const std::size_t d0)</td></tr>
<tr class="memdesc:a2354c80a56abe0e99df1eff351584f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-1 non-const. <br /></td></tr>
<tr class="separator:a2354c80a56abe0e99df1eff351584f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677093a8ac21a4c897a6a5d6455d1662"><td class="memTemplParams" colspan="2"><a id="a677093a8ac21a4c897a6a5d6455d1662"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a677093a8ac21a4c897a6a5d6455d1662"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typename Tuple_t::template member_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a677093a8ac21a4c897a6a5d6455d1662">get</a> (const Tuple_t &amp;tp, const std::size_t d0)</td></tr>
<tr class="memdesc:a677093a8ac21a4c897a6a5d6455d1662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-1 const. <br /></td></tr>
<tr class="separator:a677093a8ac21a4c897a6a5d6455d1662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614c65635a984f76acdf46dc4cbffc52"><td class="memTemplParams" colspan="2"><a id="a614c65635a984f76acdf46dc4cbffc52"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a614c65635a984f76acdf46dc4cbffc52"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typename Tuple_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a614c65635a984f76acdf46dc4cbffc52">get</a> (Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="memdesc:a614c65635a984f76acdf46dc4cbffc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-2 non-const. <br /></td></tr>
<tr class="separator:a614c65635a984f76acdf46dc4cbffc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1019ce4c1cf533cacedbaa5f808000"><td class="memTemplParams" colspan="2"><a id="aea1019ce4c1cf533cacedbaa5f808000"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:aea1019ce4c1cf533cacedbaa5f808000"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typename Tuple_t::template member_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#aea1019ce4c1cf533cacedbaa5f808000">get</a> (const Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="memdesc:aea1019ce4c1cf533cacedbaa5f808000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-2 const. <br /></td></tr>
<tr class="separator:aea1019ce4c1cf533cacedbaa5f808000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71efcfb57ce9e0843cd35fb8249a2dd"><td class="memTemplParams" colspan="2"><a id="ab71efcfb57ce9e0843cd35fb8249a2dd"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:ab71efcfb57ce9e0843cd35fb8249a2dd"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typename Tuple_t::template member_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab71efcfb57ce9e0843cd35fb8249a2dd">get</a> (Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="memdesc:ab71efcfb57ce9e0843cd35fb8249a2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-3 non-const. <br /></td></tr>
<tr class="separator:ab71efcfb57ce9e0843cd35fb8249a2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e4f6dea874e909927f1144057ab993"><td class="memTemplParams" colspan="2"><a id="a17e4f6dea874e909927f1144057ab993"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a17e4f6dea874e909927f1144057ab993"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typename Tuple_t::template member_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a17e4f6dea874e909927f1144057ab993">get</a> (const Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="memdesc:a17e4f6dea874e909927f1144057ab993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-3 const. <br /></td></tr>
<tr class="separator:a17e4f6dea874e909927f1144057ab993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f45805f16a42f9f6f048d2e88cd940"><td class="memItemLeft" align="right" valign="top"><a id="a94f45805f16a42f9f6f048d2e88cd940"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a94f45805f16a42f9f6f048d2e88cd940">version</a> ()</td></tr>
<tr class="memdesc:a94f45805f16a42f9f6f048d2e88cd940"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> version. <br /></td></tr>
<tr class="separator:a94f45805f16a42f9f6f048d2e88cd940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad181bcaca8bec0b53a05927aff3120"><td class="memItemLeft" align="right" valign="top"><a id="afad181bcaca8bec0b53a05927aff3120"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#afad181bcaca8bec0b53a05927aff3120">git_commit_hash</a> ()</td></tr>
<tr class="memdesc:afad181bcaca8bec0b53a05927aff3120"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> git hash. <br /></td></tr>
<tr class="separator:afad181bcaca8bec0b53a05927aff3120"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Core: particle data structures and algorithms. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a604397e80ba71af071611b748e0cecde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604397e80ba71af071611b748e0cecde">&#9670;&nbsp;</a></span>binByKey() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values and number of bins. The bins are evenly divided over the range of key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins.</td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin.</td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="a298e4012225366d9a9fdf7b9a867f641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298e4012225366d9a9fdf7b9a867f641">&#9670;&nbsp;</a></span>binByKey() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values and number of bins. The bins are evenly divided over the range of key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="ad3e2eca356e99a00cf3f2f5848f5cf7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e2eca356e99a00cf3f2f5848f5cf7a">&#9670;&nbsp;</a></span>binByKey() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys.</td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins.</td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin.</td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="aa3328dc23cbfede2bd40bcdd2fdd9074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3328dc23cbfede2bd40bcdd2fdd9074">&#9670;&nbsp;</a></span>binByKey() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys.</td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="a69aceca61e0460f10c38fa9ad329cd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69aceca61e0460f10c38fa9ad329cd0d">&#9670;&nbsp;</a></span>binByKeyWithComparator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::binByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for binning. Must be compatible with Kokkos::BinSort.</td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin.</td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="ad09392355b60acbaa717d5f26ab15873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09392355b60acbaa717d5f26ab15873">&#9670;&nbsp;</a></span>binByKeyWithComparator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::binByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for binning. Must be compatible with Kokkos::BinSort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="a682f288aa48e84e44856d1a0b2239b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682f288aa48e84e44856d1a0b2239b43">&#9670;&nbsp;</a></span>create_mirror_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SrcAoSoA Cabana::create_mirror_view </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given space. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="aa1766b5bf6655530bbeec104d9ef7d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1766b5bf6655530bbeec104d9ef7d81">&#9670;&nbsp;</a></span>create_mirror_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt;typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length&gt; Cabana::create_mirror_view </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="ab22f02b41130e19d3e1f071373ac69c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22f02b41130e19d3e1f071373ac69c9">&#9670;&nbsp;</a></span>create_mirror_view_and_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SrcAoSoA Cabana::create_mirror_view_and_copy </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and copy the contents of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="ae5b46fdf8a6a9140734d372ff5df15d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b46fdf8a6a9140734d372ff5df15d3">&#9670;&nbsp;</a></span>create_mirror_view_and_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt;typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length&gt; Cabana::create_mirror_view_and_copy </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and deep copy the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> into the mirror. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> and performs the deep copy. </p>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="ab460bf0f1b72014755b0bd79426b9df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab460bf0f1b72014755b0bd79426b9df8">&#9670;&nbsp;</a></span>createRandomParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::createRandomParticles </td>
          <td>(</td>
          <td class="paramtype">PositionType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>box_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>box_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate random particles. Kokkos device version with default execution space. </p>

</div>
</div>
<a id="ace85c21cdc66c52ead3d7dcf3d168ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace85c21cdc66c52ead3d7dcf3d168ee8">&#9670;&nbsp;</a></span>createRandomParticlesMinDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class PositionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::createRandomParticlesMinDistance </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>box_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>box_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate random particles with minimum distance between neighbors. This approximates many physical scenarios, e.g. atomic simulations. Kokkos device version. </p>

</div>
</div>
<a id="a9f0ca04a76c59609d5f9985bc5f0f87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0ca04a76c59609d5f9985bc5f0f87d">&#9670;&nbsp;</a></span>createRandomParticlesMinDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::createRandomParticlesMinDistance </td>
          <td>(</td>
          <td class="paramtype">PositionType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>box_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>box_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate random particles with minimum distance between neighbors. This approximates many physical scenarios, e.g. atomic simulations. Kokkos device version with default execution space. </p>

</div>
</div>
<a id="a0f82fe027dec446d5ff114b36e2a30be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f82fe027dec446d5ff114b36e2a30be">&#9670;&nbsp;</a></span>deep_copy() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AoSoA_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AoSoA_t::tuple_type &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> with a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to fill.</td></tr>
    <tr><td class="paramname">tuple</td><td>The tuple to assign. All <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> elements will be assigned this value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1932d2c9be351d64dfcb6e2d22fc68c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1932d2c9be351d64dfcb6e2d22fc68c8">&#9670;&nbsp;</a></span>deep_copy() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DstAoSoA , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">DstAoSoA &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; DstAoSoA &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy data between compatible <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination for the copied data.</td></tr>
    <tr><td class="paramname">src</td><td>The source of the copied data.</td></tr>
  </table>
  </dd>
</dl>
<p>Only <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> objects with the same set of member data types and size may be copied. </p>

</div>
</div>
<a id="ab6c2588c68205d46f36b60be2afff96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c2588c68205d46f36b60be2afff96e">&#9670;&nbsp;</a></span>deep_copy() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DstSlice , class SrcSlice &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">DstSlice &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcSlice &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; DstSlice &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SrcSlice &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy data between compatible <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination for the copied data.</td></tr>
    <tr><td class="paramname">src</td><td>The source of the copied data.</td></tr>
  </table>
  </dd>
</dl>
<p>Only <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> objects with the same set of member data types and size may be copied. </p>

</div>
</div>
<a id="ae209c92053381625d4d040bb1f74682b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae209c92053381625d4d040bb1f74682b">&#9670;&nbsp;</a></span>deep_copy() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Slice_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">Slice_t &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Slice_t::value_type&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a slice with a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice to fill.</td></tr>
    <tr><td class="paramname">scalar</td><td>The scalar to assign. All slice elements will be assigned this value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b1bdb5946e4dfb5f96695e6cee6484d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1bdb5946e4dfb5f96695e6cee6484d">&#9670;&nbsp;</a></span>fillParameterPack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParameterPack_t , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::fillParameterPack </td>
          <td>(</td>
          <td class="paramtype">ParameterPack_t &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types &amp;...&#160;</td>
          <td class="paramname"><em>ts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill a parameter pack. Note the indexing is such that the Nth element of a parameter pack is the Nth element of the tuple. </p>

</div>
</div>
<a id="a15dca4f62c3f1f9cb7a9c869c7ae3486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15dca4f62c3f1f9cb7a9c869c7ae3486">&#9670;&nbsp;</a></span>for_each_neighbor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexType , class FunctorType , class NeighborListType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void Cabana::for_each_neighbor </td>
          <td>(</td>
          <td class="paramtype">const IndexType&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>neighbor_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>FirstNeighborsTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute functor in serial within existing parallel kernel over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexType</td><td>The particle index type. </td></tr>
    <tr><td class="paramname">FunctorType</td><td>The neighbor functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Particle index. </td></tr>
    <tr><td class="paramname">neighbor_functor</td><td>The neighbor functor to execute in parallel. </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a></td><td>Tag indicating operations over particle first neighbors.</td></tr>
  </table>
  </dd>
</dl>
<p>A "functor" is a class containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for neighbor parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> particle_index, <span class="keyword">const</span> <span class="keywordtype">int</span> neighbor_index ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>Index</code> is a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> index to a given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> element for a particle and its neighbor. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. This compares to a single iteration <code>idx</code> of a <code>for</code> loop. </p>

</div>
</div>
<a id="a366034424ecf96ad51645694c2d71676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366034424ecf96ad51645694c2d71676">&#9670;&nbsp;</a></span>for_each_neighbor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexType , class FunctorType , class NeighborListType , class TeamMemberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void Cabana::for_each_neighbor </td>
          <td>(</td>
          <td class="paramtype">const IndexType&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TeamMemberType&#160;</td>
          <td class="paramname"><em>team</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>neighbor_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>FirstNeighborsTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute team parallel functor within existing parallel kernel over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexType</td><td>The particle index type. </td></tr>
    <tr><td class="paramname">FunctorType</td><td>The neighbor functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">TeamMemberType</td><td>Kokkos team policy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Particle index. </td></tr>
    <tr><td class="paramname">team</td><td>Kokkos team. </td></tr>
    <tr><td class="paramname">neighbor_functor</td><td>The neighbor functor to execute in parallel. </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a></td><td>Tag indicating operations over particle first neighbors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0dd17069284c2039235e463b2d885ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0dd17069284c2039235e463b2d885ee">&#9670;&nbsp;</a></span>gather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Halo_t , class AoSoA_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::gather </td>
          <td>(</td>
          <td class="paramtype">const Halo_t &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; Halo_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version. This is a uniquely-owned to multiply-owned communication. </p>
<p>A gather sends data from a locally owned elements to one or many ranks on which they exist as ghosts. A locally owned element may be sent to as many ranks as desired to be used as a ghost on those ranks. The value of the element in the locally owned decomposition will be the value assigned to the element in the ghosted decomposition.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Halo_t</td><td><a class="el" href="classCabana_1_1Halo.html" title="A communication plan for scattering and gathering of ghosted data.">Halo</a> type - must be a <a class="el" href="classCabana_1_1Halo.html" title="A communication plan for scattering and gathering of ghosted data.">Halo</a>.</td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type - must be an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo to use for the gather.</td></tr>
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> on which to perform the gather. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> should have a size equivalent to halo.numGhost() + halo.numLocal(). The locally owned elements are expected to appear first (i.e. in the first halo.numLocal() elements) and the ghosted elements are expected to appear second (i.e. in the next halo.numGhost() elements()). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c97a585251f273cc3ed77bda475af8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c97a585251f273cc3ed77bda475af8c">&#9670;&nbsp;</a></span>gather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Halo_t , class Slice_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::gather </td>
          <td>(</td>
          <td class="paramtype">const Halo_t &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Slice_t &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; Halo_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. This is a uniquely-owned to multiply-owned communication. </p>
<p>A gather sends data from a locally owned elements to one or many ranks on which they exist as ghosts. A locally owned element may be sent to as many ranks as desired to be used as a ghost on those ranks. The value of the element in the locally owned decomposition will be the value assigned to the element in the ghosted decomposition.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Halo_t</td><td><a class="el" href="classCabana_1_1Halo.html" title="A communication plan for scattering and gathering of ghosted data.">Halo</a> type - must be a <a class="el" href="classCabana_1_1Halo.html" title="A communication plan for scattering and gathering of ghosted data.">Halo</a>.</td></tr>
    <tr><td class="paramname">Slice_t</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type - must be a <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo to use for the gather.</td></tr>
    <tr><td class="paramname">slice</td><td>The <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> on which to perform the gather. The <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> should have a size equivalent to halo.numGhost() + halo.numLocal(). The locally owned elements are expected to appear first (i.e. in the first halo.numLocal() elements) and the ghosted elements are expected to appear second (i.e. in the next halo.numGhost() elements()). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9cb44110c8a6215d2ca62406e8aed35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cb44110c8a6215d2ca62406e8aed35">&#9670;&nbsp;</a></span>migrate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Distributor_t , class AoSoA_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">const Distributor_t &amp;&#160;</td>
          <td class="paramname"><em>distributor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. Single <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version that will resize in-place. Note that resizing does not necessarily allocate more memory. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> memory will only increase if not enough has already been reserved/allocated for the needed number of elements. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> type - must be a distributor.</td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type - must be an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration.</td></tr>
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> containing the data to be migrated. Upon input, must have the same number of elements as the inputs used to construct the destributor. At output, it will be the same size as th enumber of import elements on this rank provided by the distributor. Before using this function, consider reserving enough memory in the data structure so reallocating is not necessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb10ac278624d871f6079c4e24ccb219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb10ac278624d871f6079c4e24ccb219">&#9670;&nbsp;</a></span>migrate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Distributor_t , class AoSoA_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">const Distributor_t &amp;&#160;</td>
          <td class="paramname"><em>distributor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. Multiple <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> type - must be a distributor.</td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type - must be an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration.</td></tr>
    <tr><td class="paramname">src</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> containing the data to be migrated. Must have the same number of elements as the inputs used to construct the distributor.</td></tr>
    <tr><td class="paramname">dst</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to which the migrated data will be written. Must be the same size as the number of imports given by the distributor on this rank. Call totalNumImport() on the distributor to get this size value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82063f55f2d0c3d17d11ba6642fb7353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82063f55f2d0c3d17d11ba6642fb7353">&#9670;&nbsp;</a></span>migrate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Distributor_t , class Slice_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">const Distributor_t &amp;&#160;</td>
          <td class="paramname"><em>distributor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Slice_t &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Slice_t &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. The user can do this in-place with the same slice but they will need to manage the resizing themselves as we can't resize slices. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> type - must be a distributor.</td></tr>
    <tr><td class="paramname">Slice_t</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type - must be an <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration.</td></tr>
    <tr><td class="paramname">src</td><td>The slice containing the data to be migrated. Must have the same number of elements as the inputs used to construct the destributor.</td></tr>
    <tr><td class="paramname">dst</td><td>The slice to which the migrated data will be written. Must be the same size as the number of imports given by the distributor on this rank. Call totalNumImport() on the distributor to get this size value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb924882c14a90b695a56065f4106c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb924882c14a90b695a56065f4106c22">&#9670;&nbsp;</a></span>neighbor_parallel_for() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>FirstNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SerialOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with a thread-local serial loop over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a></td><td>Tag indicating operations over particle first neighbors. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a></td><td>Tag indicating a serial loop strategy over neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes.</td></tr>
  </table>
  </dd>
</dl>
<p>A "functor" is a class containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for neighbor parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> particle_index, <span class="keyword">const</span> <span class="keywordtype">int</span> neighbor_index ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>Index</code> is a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> index to a given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> element for a particle and its neighbor. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. This compares to a single iteration <code>idx</code> of a <code>for</code> loop. </p>

</div>
</div>
<a id="ac2cb6955452842c7903e86a845329e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cb6955452842c7903e86a845329e7c">&#9670;&nbsp;</a></span>neighbor_parallel_for() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>FirstNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>TeamOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a></td><td>Tag indicating operations over particle first neighbors. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a></td><td>Tag indicating a team parallel strategy over neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10eeaa254bbc26461eadae4d9a0a1598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10eeaa254bbc26461eadae4d9a0a1598">&#9670;&nbsp;</a></span>neighbor_parallel_for() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SecondNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SerialOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with thread-local serial loops over particle first and second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a></td><td>Tag indicating operations over particle first and second neighbors. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a></td><td>Tag indicating a serial loop strategy over neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acca1d55078d6cfea288c6cec130ef204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca1d55078d6cfea288c6cec130ef204">&#9670;&nbsp;</a></span>neighbor_parallel_for() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SecondNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>TeamOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors and serial loop over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a></td><td>Tag indicating operations over particle first and second neighbors. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a></td><td>Tag indicating a team parallel strategy over particle first neighbors and serial execution over second neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dae9114f1f2ede7f1925a0c73c7639b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dae9114f1f2ede7f1925a0c73c7639b">&#9670;&nbsp;</a></span>neighbor_parallel_for() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SecondNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>TeamVectorOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors and vector loop parallelism over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a></td><td>Tag indicating operations over particle first and second neighbors. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1TeamVectorOpTag.html" title="Neighbor operations are executed with team vector parallelism.">TeamVectorOpTag</a></td><td>Tag indicating a team parallel strategy over particle first neighbors and vector parallel loop strategy over second neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7e94d9a9c1af171bdbb8c4362c23aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e94d9a9c1af171bdbb8c4362c23aa0">&#9670;&nbsp;</a></span>neighbor_parallel_reduce() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>FirstNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SerialOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reduce_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor reduction in parallel according to the execution policy over particles with a thread-local serial loop over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters. </td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a></td><td>Tag indicating operations over particle first neighbors. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a></td><td>Tag indicating a serial loop strategy over neighbors. </td></tr>
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes.</td></tr>
  </table>
  </dd>
</dl>
<p>A "functor" is a class containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for neighbor parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> particle_index, <span class="keyword">const</span> <span class="keywordtype">int</span> neighbor_index ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>Index</code> is a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> index to a given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> element for a particle and its neighbor. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. This compares to a single iteration <code>idx</code> of a <code>for</code> loop. </p>

</div>
</div>
<a id="abb2295a3434a7b25d87832e522474f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2295a3434a7b25d87832e522474f91">&#9670;&nbsp;</a></span>neighbor_parallel_reduce() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>FirstNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>TeamOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reduce_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters. </td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a></td><td>Tag indicating operations over particle first neighbors. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a></td><td>Tag indicating a team parallel strategy over particle neighbors. </td></tr>
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a949a3b9f4fd10c8f6b05267870eca331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949a3b9f4fd10c8f6b05267870eca331">&#9670;&nbsp;</a></span>neighbor_parallel_reduce() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SecondNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SerialOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reduce_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor reduction in parallel according to the execution policy over particles with thread-local serial loops over particle first and second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters. </td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a></td><td>Tag indicating operations over particle first and second neighbors. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a></td><td>Tag indicating a serial loop strategy over neighbors. </td></tr>
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afad67e6a4c72546175d974afd501a5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad67e6a4c72546175d974afd501a5fb">&#9670;&nbsp;</a></span>neighbor_parallel_reduce() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SecondNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>TeamOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reduce_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors and serial loop over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters. </td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a></td><td>Tag indicating operations over particle first and second neighbors. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a></td><td>Tag indicating a team parallel strategy over particle first neighbors and serial loops over second neighbors. </td></tr>
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd64556212553a3ada775f74735afe30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd64556212553a3ada775f74735afe30">&#9670;&nbsp;</a></span>neighbor_parallel_reduce() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>SecondNeighborsTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>TeamVectorOpTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reduce_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors and vector loop parallelism over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters. </td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a></td><td>Tag indicating operations over particle first and second neighbors. </td></tr>
    <tr><td class="paramname"><a class="el" href="classCabana_1_1TeamVectorOpTag.html" title="Neighbor operations are executed with team vector parallelism.">TeamVectorOpTag</a></td><td>Tag indicating a team parallel strategy over particle first neighbors and vector loops over second neighbors. </td></tr>
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a824f296314f00ca8e121e6a26e2846db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824f296314f00ca8e121e6a26e2846db">&#9670;&nbsp;</a></span>permute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BinningDataType , class AoSoA_t , class DeviceType  = typename BinningDataType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">const BinningDataType &amp;&#160;</td>
          <td class="paramname"><em>binning_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(is_binning_data&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given binning data permute an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinningDataType</td><td>The binning data type.</td></tr>
    <tr><td class="paramname">AoSoA_t</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binning_data</td><td>The binning data.</td></tr>
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab44a65c22331c71ed7cee721a41c54fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44a65c22331c71ed7cee721a41c54fc">&#9670;&nbsp;</a></span>permute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BinningDataType , class SliceType , class DeviceType  = typename BinningDataType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">const BinningDataType &amp;&#160;</td>
          <td class="paramname"><em>binning_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceType &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(is_binning_data&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given binning data permute a slice. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinningDataType</td><td>The binning data type.</td></tr>
    <tr><td class="paramname">SliceType</td><td>The slice type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binning_data</td><td>The binning data.</td></tr>
    <tr><td class="paramname">slice</td><td>The slice to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02c3a57c3cd27a75094bbfa1be56145b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c3a57c3cd27a75094bbfa1be56145b">&#9670;&nbsp;</a></span>permute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LinkedCellListType , class AoSoA_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">const LinkedCellListType &amp;&#160;</td>
          <td class="paramname"><em>linked_cell_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellListType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a linked cell list permute an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LinkedCellListType</td><td>The linked cell list type.</td></tr>
    <tr><td class="paramname">AoSoA_t</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linked_cell_list</td><td>The linked cell list to permute the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> with.</td></tr>
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a1ce7155c5c1185f46071b20d4dd332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1ce7155c5c1185f46071b20d4dd332">&#9670;&nbsp;</a></span>permute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LinkedCellListType , class SliceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">const LinkedCellListType &amp;&#160;</td>
          <td class="paramname"><em>linked_cell_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceType &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellListType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a linked cell list permute a slice. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LinkedCellListType</td><td>The linked cell list type.</td></tr>
    <tr><td class="paramname">SliceType</td><td>The slice type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linked_cell_list</td><td>The linked cell list to permute the slice with.</td></tr>
    <tr><td class="paramname">slice</td><td>The slice to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af22a4214a72df81e7678162494c38dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22a4214a72df81e7678162494c38dd0">&#9670;&nbsp;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Halo_t , class Slice_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::scatter </td>
          <td>(</td>
          <td class="paramtype">const Halo_t &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Slice_t &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; Halo_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously scatter data from the ghosts to the local decomposition of a slice using the halo reverse communication plan. This is a multiply-owned to uniquely owned communication. </p>
<p>In a scatter operation results from ghosted values on other processors are scattered back to the owning processor of the ghost and the value associated with the ghost is summed into the locally owned value the ghost represents. If a locally owned element is ghosted on multiple ranks, then multiple contributions will be made to the sum, one for each rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Halo_t</td><td><a class="el" href="classCabana_1_1Halo.html" title="A communication plan for scattering and gathering of ghosted data.">Halo</a> type - must be a <a class="el" href="classCabana_1_1Halo.html" title="A communication plan for scattering and gathering of ghosted data.">Halo</a>.</td></tr>
    <tr><td class="paramname">Slice_t</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type - must be a <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo to use for the scatter.</td></tr>
    <tr><td class="paramname">slice</td><td>The <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> on which to perform the scatter. The <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> should have a size equivalent to halo.numGhost() + halo.numLocal(). The locally owned elements are expected to appear first (i.e. in the first halo.numLocal() elements) and the ghosted elements are expected to appear second (i.e. in the next halo.numGhost() elements()). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7dda1a05e595dbec3f4f06e7f878d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7dda1a05e595dbec3f4f06e7f878d9e">&#9670;&nbsp;</a></span>simd_parallel_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , int VectorLength, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::simd_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SimdPolicy.html">SimdPolicy</a>&lt; VectorLength, ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a vectorized functor in parallel with a 2d execution policy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">VectorLength</td><td>The length of the vector over which to execute the vectorized code.</td></tr>
    <tr><td class="paramname">ExecParameters</td><td>Execution policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The 2D range policy over which to execute the functor.</td></tr>
    <tr><td class="paramname">functor</td><td>The vectorized functor to execute in parallel. Must accept both a struct and array index.</td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes.</td></tr>
  </table>
  </dd>
</dl>
<p>A "functor" is a callable object containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> <span class="keyword">struct</span>, <span class="keyword">const</span> <span class="keywordtype">int</span> array ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>struct</code> defines an index to a given AoSoA/Slice struct and array defines and index to the given array element in that struct. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. The kernel represented by the functor is intended to vectorize of the array index.</p>
<dl class="section note"><dt>Note</dt><dd>The work tag gets applied at the user functor level, not at the level of the functor in this implementation that wraps the user functor. </dd></dl>

</div>
</div>
<a id="ad6d068692acbf0642e84ce1f94b677c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d068692acbf0642e84ce1f94b677c9">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t M, class AoSoA_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">AoSoA_t::template member_slice_type&lt;M&gt; Cabana::slice </td>
          <td>(</td>
          <td class="paramtype">const AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>slice_label</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a slice from an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> index. </td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aosoa</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to slice from. </td></tr>
    <tr><td class="paramname">slice_label</td><td>Optional slice label. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb212c9d4bf5dd79dca6393dd5cd1d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb212c9d4bf5dd79dca6393dd5cd1d50">&#9670;&nbsp;</a></span>sortByKey() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort.</td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="ad5de120bd7e1dd83a15d85ac2121633b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5de120bd7e1dd83a15d85ac2121633b">&#9670;&nbsp;</a></span>sortByKey() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="a91a4311d29473e2ecdab7927aaff49ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a4311d29473e2ecdab7927aaff49ad">&#9670;&nbsp;</a></span>sortByKey() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys.</td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort.</td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="af95cdaf6584250a53d942bbe99e5e78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95cdaf6584250a53d942bbe99e5e78e">&#9670;&nbsp;</a></span>sortByKey() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType , class DeviceType  = typename SliceType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="a74033479f79c2c5e1831bf9a88234ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74033479f79c2c5e1831bf9a88234ef9">&#9670;&nbsp;</a></span>sortByKeyWithComparator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::sortByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for sorting. Must be compatible with Kokkos::BinSort.</td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort.</td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="a7e7d211b39c3007dff87e7d9a03bd777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7d211b39c3007dff87e7d9a03bd777">&#9670;&nbsp;</a></span>sortByKeyWithComparator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class Comparator , class DeviceType  = typename KeyViewType::device_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a>&lt;DeviceType&gt; Cabana::sortByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for sorting. Must be compatible with Kokkos::BinSort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
