<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cabana: Cabana Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cabana<span id="projectnumber">&#160;0.8.0-dev</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceCabana.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Cabana Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Core: particle data structures and algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array-of-Struct-of-Arrays.  <a href="classCabana_1_1AoSoA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1AtomicAccessMemory.html">AtomicAccessMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic memory access. All reads and writes are atomic.  <a href="structCabana_1_1AtomicAccessMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data describing the bin sizes and offsets resulting from a binning operation.  <a href="classCabana_1_1BinningData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1CheckMemberTypes.html">CheckMemberTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that member types are valid.  <a href="structCabana_1_1CheckMemberTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1CheckMemberTypes_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html">CheckMemberTypes&lt; MemberTypes&lt; Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that member types are valid.  <a href="structCabana_1_1CheckMemberTypes_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationData.html">CommunicationData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationData_3_01CommPlanType_00_01CommDataType_00_01Mpi_01_4.html">CommunicationData&lt; CommPlanType, CommDataType, Mpi &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> send/receive buffers. <a class="el" href="structCabana_1_1Mpi.html" title="Vanilla MPI backend tag - default.">Mpi</a> variant.  <a href="classCabana_1_1CommunicationData_3_01CommPlanType_00_01CommDataType_00_01Mpi_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1CommunicationDataAoSoA.html">CommunicationDataAoSoA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> send/receive buffers.  <a href="structCabana_1_1CommunicationDataAoSoA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationDataBase.html">CommunicationDataBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store communication plan and communication buffers.  <a href="classCabana_1_1CommunicationDataBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1CommunicationDataSlice.html">CommunicationDataSlice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store slice send/receive buffers.  <a href="structCabana_1_1CommunicationDataSlice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html">CommunicationPlan</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan_3_01MemorySpace_00_01Mpi_01_4.html">CommunicationPlan&lt; MemorySpace, Mpi &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Communication plan class. Uses vanilla MPI as the communication backend.  <a href="classCabana_1_1CommunicationPlan_3_01MemorySpace_00_01Mpi_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlanBase.html">CommunicationPlanBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Communication plan base class.  <a href="classCabana_1_1CommunicationPlanBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1DefaultAccessMemory.html">DefaultAccessMemory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Distributor.html">Distributor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A communication plan for migrating data from one uniquely-owned decomposition to another uniquely owned decomposition.  <a href="classCabana_1_1Distributor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1Export.html">Export</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export-based tag - default.  <a href="structCabana_1_1Export.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over particle neighbors.  <a href="classCabana_1_1FirstNeighborsTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1FullNeighborTag.html">FullNeighborTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for building full neighbor lists.  <a href="classCabana_1_1FullNeighborTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Gather.html">Gather</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Gather_3_01HaloType_00_01AoSoAType_00_01typename_01std_1_1enable__if_3_01is__aoso666e08a1494152c80218c785a19e78d3.html">Gather&lt; HaloType, AoSoAType, typename std::enable_if&lt; is_aosoa&lt; AoSoAType &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version. This is a uniquely-owned to multiply-owned communication.  <a href="classCabana_1_1Gather_3_01HaloType_00_01AoSoAType_00_01typename_01std_1_1enable__if_3_01is__aoso666e08a1494152c80218c785a19e78d3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Gather_3_01HaloType_00_01SliceType_00_01typename_01std_1_1enable__if_3_01is__slica420051aad1e71fccbd290130c9a8cef.html">Gather&lt; HaloType, SliceType, typename std::enable_if&lt; is_slice&lt; SliceType &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version. This is a uniquely-owned to multiply-owned communication.  <a href="classCabana_1_1Gather_3_01HaloType_00_01SliceType_00_01typename_01std_1_1enable__if_3_01is__slica420051aad1e71fccbd290130c9a8cef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1HalfNeighborTag.html">HalfNeighborTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for building half neighbor lists.  <a href="classCabana_1_1HalfNeighborTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Halo.html">Halo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A communication plan for scattering and gathering of ghosted data.  <a href="classCabana_1_1Halo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1Import.html">Import</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import-based tag.  <a href="structCabana_1_1Import.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random particle initialization type tag.  <a href="structCabana_1_1InitRandom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1InitUniform.html">InitUniform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform particle initialization type tag.  <a href="structCabana_1_1InitUniform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__accessible__from.html">is_accessible_from</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__accessible__from_3_01MemorySpace_00_01ExecutionSpace_00_01std_1_1enable__if_96534d0f81e01b006272bb63cf2f3dd3.html">is_accessible_from&lt; MemorySpace, ExecutionSpace, std::enable_if_t&lt; Kokkos::SpaceAccessibility&lt; ExecutionSpace, MemorySpace &gt;::accessible &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> static type checker.  <a href="structCabana_1_1is__aosoa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__binning__data_3_01const_01BinningData_3_01MemorySpace_01_4_01_4.html">is_binning_data&lt; const BinningData&lt; MemorySpace &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1BinningData.html" title="Data describing the bin sizes and offsets resulting from a binning operation.">BinningData</a> static type checker.  <a href="structCabana_1_1is__binning__data_3_01const_01BinningData_3_01MemorySpace_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> static type checker.  <a href="structCabana_1_1is__distributor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__halo.html">is_halo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1Halo.html" title="A communication plan for scattering and gathering of ghosted data.">Halo</a> static type checker.  <a href="structCabana_1_1is__halo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1LinkedCellList.html" title="Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesia...">LinkedCellList</a> static type checker.  <a href="structCabana_1_1is__linked__cell__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__member__types.html">is_member_types</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static type checker.  <a href="structCabana_1_1is__member__types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag.html">is_memory_access_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory access type checker.  <a href="structCabana_1_1is__memory__access__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag_3_01AtomicAccessMemory_01_4.html">is_memory_access_tag&lt; AtomicAccessMemory &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag_3_01DefaultAccessMemory_01_4.html">is_memory_access_tag&lt; DefaultAccessMemory &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory access type checker.  <a href="structCabana_1_1is__memory__access__tag_3_01DefaultAccessMemory_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag_3_01RandomAccessMemory_01_4.html">is_memory_access_tag&lt; RandomAccessMemory &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__parameter__pack.html">is_parameter_pack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1ParameterPack.html">ParameterPack</a> static type checker.  <a href="structCabana_1_1is__parameter__pack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__particle__list.html">is_particle_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> static type checker.  <a href="structCabana_1_1is__particle__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__particle__list__impl.html">is_particle_list_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__particle__list__impl_3_01ParticleList_3_01MemorySpace_00_01VectorLength_00_01FieldTags_8_8_8_01_4_01_4.html">is_particle_list_impl&lt; ParticleList&lt; MemorySpace, VectorLength, FieldTags... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__slice.html">is_slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> static type checker.  <a href="structCabana_1_1is__slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__soa.html">is_soa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1SoA.html">SoA</a> static type checker.  <a href="structCabana_1_1is__soa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Tuple.html">Tuple</a> static type checker.  <a href="structCabana_1_1is__tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1LinkedCellList.html">LinkedCellList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesian grid.  <a href="classCabana_1_1LinkedCellList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1LinkedCellStencil.html">LinkedCellStencil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stencil of cells surrounding each cell.  <a href="structCabana_1_1LinkedCellStencil.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1MemberTypeAtIndex.html">MemberTypeAtIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the member at a given index.  <a href="structCabana_1_1MemberTypeAtIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1MemberTypeAtIndex_3_01M_00_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html">MemberTypeAtIndex&lt; M, MemberTypes&lt; Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the member at a given index.  <a href="structCabana_1_1MemberTypeAtIndex_3_01M_00_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1MemberTypes.html">MemberTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General sequence of types for <a class="el" href="structCabana_1_1SoA.html">SoA</a> and <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> member data.  <a href="structCabana_1_1MemberTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1Mpi.html">Mpi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vanilla MPI backend tag - default.  <a href="structCabana_1_1Mpi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborDiscriminator.html">NeighborDiscriminator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighborhood discriminator.  <a href="classCabana_1_1NeighborDiscriminator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborDiscriminator_3_01FullNeighborTag_01_4.html">NeighborDiscriminator&lt; FullNeighborTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full list discriminator specialization.  <a href="classCabana_1_1NeighborDiscriminator_3_01FullNeighborTag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborDiscriminator_3_01HalfNeighborTag_01_4.html">NeighborDiscriminator&lt; HalfNeighborTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Half list discriminator specialization.  <a href="classCabana_1_1NeighborDiscriminator_3_01HalfNeighborTag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborDiscriminator_3_01SelfNeighborTag_01_4.html">NeighborDiscriminator&lt; SelfNeighborTag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList.html">NeighborList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor list interface. Provides an interface callable at the functor level that gives access to neighbor data for particles.  <a href="classCabana_1_1NeighborList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01Experimental_1_1CrsGraph_3_01MemorySpace_00_01Tag_01_4_01_4.html">NeighborList&lt; Experimental::CrsGraph&lt; MemorySpace, Tag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">1d ArborX <a class="el" href="classCabana_1_1NeighborList.html" title="Neighbor list interface. Provides an interface callable at the functor level that gives access to nei...">NeighborList</a> interface.  <a href="classCabana_1_1NeighborList_3_01Experimental_1_1CrsGraph_3_01MemorySpace_00_01Tag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01Experimental_1_1Dense_3_01MemorySpace_00_01Tag_01_4_01_4.html">NeighborList&lt; Experimental::Dense&lt; MemorySpace, Tag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2d ArborX <a class="el" href="classCabana_1_1NeighborList.html" title="Neighbor list interface. Provides an interface callable at the functor level that gives access to nei...">NeighborList</a> interface.  <a href="classCabana_1_1NeighborList_3_01Experimental_1_1Dense_3_01MemorySpace_00_01Tag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01LinkedCellList_3_01MemorySpace_00_01Scalar_00_01NumSpaceDim_01_4_01_4.html">NeighborList&lt; LinkedCellList&lt; MemorySpace, Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1LinkedCellList.html" title="Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesia...">LinkedCellList</a> <a class="el" href="classCabana_1_1NeighborList.html" title="Neighbor list interface. Provides an interface callable at the functor level that gives access to nei...">NeighborList</a> interface.  <a href="classCabana_1_1NeighborList_3_01LinkedCellList_3_01MemorySpace_00_01Scalar_00_01NumSpaceDim_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01VerletLayout2Dbbb69c9e30f1a93dc490c315328b7260.html">NeighborList&lt; VerletList&lt; MemorySpace, AlgorithmTag, VerletLayout2D, BuildTag, Dim &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D <a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a Cartesian grid with cells of the same si...">VerletList</a> <a class="el" href="classCabana_1_1NeighborList.html" title="Neighbor list interface. Provides an interface callable at the functor level that gives access to nei...">NeighborList</a> interface.  <a href="classCabana_1_1NeighborList_3_01VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01VerletLayout2Dbbb69c9e30f1a93dc490c315328b7260.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01VerletLayoutCS91df0b0ab9bd7f25043cfd9b1f7607ee.html">NeighborList&lt; VerletList&lt; MemorySpace, AlgorithmTag, VerletLayoutCSR, BuildTag, Dim &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSR <a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a Cartesian grid with cells of the same si...">VerletList</a> <a class="el" href="classCabana_1_1NeighborList.html" title="Neighbor list interface. Provides an interface callable at the functor level that gives access to nei...">NeighborList</a> interface.  <a href="classCabana_1_1NeighborList_3_01VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01VerletLayoutCS91df0b0ab9bd7f25043cfd9b1f7607ee.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1PackTypeAtIndex.html">PackTypeAtIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type at the given index of a parameter pack.  <a href="structCabana_1_1PackTypeAtIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1ParameterPack.html">ParameterPack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1ParameterPackElement.html">ParameterPackElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter pack element.  <a href="structCabana_1_1ParameterPackElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1Particle.html">Particle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single particle copy. Wraps a tuple copy of a particle.  <a href="structCabana_1_1Particle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of particle fields stored in <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <a href="classCabana_1_1ParticleList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1ParticleTraits.html">ParticleTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> particle fields for <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a>.  <a href="structCabana_1_1ParticleTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1ParticleView.html">ParticleView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single <a class="el" href="structCabana_1_1SoA.html">SoA</a> particle view. Wraps a view of the <a class="el" href="structCabana_1_1SoA.html">SoA</a> the particle resides in.  <a href="structCabana_1_1ParticleView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1RandomAccessMemory.html">RandomAccessMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access memory. Read-only and const with limited spatial locality.  <a href="structCabana_1_1RandomAccessMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Scatter.html">Scatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously scatter data from the ghosts to the local decomposition of a slice using the halo reverse communication plan. This is a multiply-owned to uniquely owned communication.  <a href="classCabana_1_1Scatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over particle neighbors (first) and neighbor's neighbors (second)  <a href="classCabana_1_1SecondNeighborsTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1SelfNeighborTag.html">SelfNeighborTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for neighbor list iteration, ignoring only self neighbors.  <a href="classCabana_1_1SelfNeighborTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor operations are executed in serial on each particle thread.  <a href="classCabana_1_1SerialOpTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1SimdPolicy.html">SimdPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution policy over a range of 2d indices.  <a href="classCabana_1_1SimdPolicy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Slice.html">Slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.  <a href="classCabana_1_1Slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1SoA.html">SoA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1SoA_3_01MemberTypes_3_01Types_8_8_8_01_4_00_01VectorLength_01_4.html">SoA&lt; MemberTypes&lt; Types... &gt;, VectorLength &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct-of-Arrays.  <a href="structCabana_1_1SoA_3_01MemberTypes_3_01Types_8_8_8_01_4_00_01VectorLength_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor operations are executed with team parallelism.  <a href="classCabana_1_1TeamOpTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor operations are executed with team vector parallelism.  <a href="classCabana_1_1TeamVectorOpTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1Tuple.html">Tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1Tuple_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html">Tuple&lt; MemberTypes&lt; Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Tuple.html">Tuple</a>.  <a href="structCabana_1_1Tuple_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1TypeIndexer.html">TypeIndexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a field type within a particle type list.  <a href="structCabana_1_1TypeIndexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletLayout2D.html">VerletLayout2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D array neighbor list layout.  <a href="structCabana_1_1VerletLayout2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletLayoutCSR.html">VerletLayoutCSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSR (compressed sparse row) neighbor list layout.  <a href="structCabana_1_1VerletLayoutCSR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1VerletList.html">VerletList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor list implementation based on binning particles on a Cartesian grid with cells of the same size as the interaction distance.  <a href="classCabana_1_1VerletList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletListData.html">VerletListData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletListData_3_01MemorySpace_00_01VerletLayout2D_01_4.html">VerletListData&lt; MemorySpace, VerletLayout2D &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the <a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a Cartesian grid with cells of the same si...">VerletList</a> 2D neighbor data.  <a href="structCabana_1_1VerletListData_3_01MemorySpace_00_01VerletLayout2D_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletListData_3_01MemorySpace_00_01VerletLayoutCSR_01_4.html">VerletListData&lt; MemorySpace, VerletLayoutCSR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the <a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a Cartesian grid with cells of the same si...">VerletList</a> compressed sparse row (CSR) neighbor data.  <a href="structCabana_1_1VerletListData_3_01MemorySpace_00_01VerletLayoutCSR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa14f30ab334c57448b204fc9b304289a" id="r_aa14f30ab334c57448b204fc9b304289a"><td class="memTemplParams" colspan="2">template&lt;std::size_t M, class AoSoA_t&gt; </td></tr>
<tr class="memitem:aa14f30ab334c57448b204fc9b304289a"><td class="memTemplItemLeft" align="right" valign="top">AoSoA_t::template member_slice_type&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a> (const AoSoA_t &amp;aosoa, const std::string &amp;slice_label=&quot;&quot;)</td></tr>
<tr class="memdesc:aa14f30ab334c57448b204fc9b304289a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a slice from an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <br /></td></tr>
<tr class="separator:aa14f30ab334c57448b204fc9b304289a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb075b5a602fbfea922fd1c190ddc3e" id="r_a8bb075b5a602fbfea922fd1c190ddc3e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bb075b5a602fbfea922fd1c190ddc3e">getUniqueTopology</a> (MPI_Comm comm, std::vector&lt; int &gt; topology)</td></tr>
<tr class="memdesc:a8bb075b5a602fbfea922fd1c190ddc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return unique neighbor ranks, with the current rank first.  <br /></td></tr>
<tr class="separator:a8bb075b5a602fbfea922fd1c190ddc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844802648f5a8db82851ba8e4672cea5" id="r_a844802648f5a8db82851ba8e4672cea5"><td class="memTemplParams" colspan="2">template&lt;class Space, class SrcAoSoA&gt; </td></tr>
<tr class="memitem:a844802648f5a8db82851ba8e4672cea5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a844802648f5a8db82851ba8e4672cea5">create_mirror</a> (const Space &amp;, const SrcAoSoA &amp;src, std::enable_if_t&lt;(!std::is_same_v&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;)&gt; *=nullptr)</td></tr>
<tr class="memdesc:a844802648f5a8db82851ba8e4672cea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a mirror of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given space.  <br /></td></tr>
<tr class="separator:a844802648f5a8db82851ba8e4672cea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a51f1811816037b2e53adf7a3e1b37" id="r_aa0a51f1811816037b2e53adf7a3e1b37"><td class="memTemplParams" colspan="2">template&lt;class Space, class SrcAoSoA&gt; </td></tr>
<tr class="memitem:aa0a51f1811816037b2e53adf7a3e1b37"><td class="memTemplItemLeft" align="right" valign="top">SrcAoSoA&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa0a51f1811816037b2e53adf7a3e1b37">create_mirror_view</a> (const Space &amp;, const SrcAoSoA &amp;src, std::enable_if_t&lt;(std::is_same_v&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;)&gt; *=nullptr)</td></tr>
<tr class="memdesc:aa0a51f1811816037b2e53adf7a3e1b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given space. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <br /></td></tr>
<tr class="separator:aa0a51f1811816037b2e53adf7a3e1b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ab274abf8942a7404be03338b0cf68" id="r_af5ab274abf8942a7404be03338b0cf68"><td class="memTemplParams" colspan="2">template&lt;class Space, class SrcAoSoA&gt; </td></tr>
<tr class="memitem:af5ab274abf8942a7404be03338b0cf68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5ab274abf8942a7404be03338b0cf68">create_mirror_view</a> (const Space &amp;space, const SrcAoSoA &amp;src, std::enable_if_t&lt;(!std::is_same_v&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;)&gt; *=nullptr)</td></tr>
<tr class="memdesc:af5ab274abf8942a7404be03338b0cf68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <br /></td></tr>
<tr class="separator:af5ab274abf8942a7404be03338b0cf68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892811b71917ebd71b3608ef3978b76d" id="r_a892811b71917ebd71b3608ef3978b76d"><td class="memTemplParams" colspan="2">template&lt;class Space, class SrcAoSoA&gt; </td></tr>
<tr class="memitem:a892811b71917ebd71b3608ef3978b76d"><td class="memTemplItemLeft" align="right" valign="top">SrcAoSoA&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a892811b71917ebd71b3608ef3978b76d">create_mirror_view_and_copy</a> (const Space &amp;, const SrcAoSoA &amp;src, std::enable_if_t&lt;(std::is_same_v&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt; &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt; *=nullptr)</td></tr>
<tr class="memdesc:a892811b71917ebd71b3608ef3978b76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and copy the contents of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <br /></td></tr>
<tr class="separator:a892811b71917ebd71b3608ef3978b76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22f44dbf5e03ccb62f338436dac5e57" id="r_aa22f44dbf5e03ccb62f338436dac5e57"><td class="memTemplParams" colspan="2">template&lt;class Space, class SrcAoSoA&gt; </td></tr>
<tr class="memitem:aa22f44dbf5e03ccb62f338436dac5e57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa22f44dbf5e03ccb62f338436dac5e57">create_mirror_view_and_copy</a> (const Space &amp;space, const SrcAoSoA &amp;src, std::enable_if_t&lt;(!std::is_same_v&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt; &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt; *=nullptr)</td></tr>
<tr class="memdesc:aa22f44dbf5e03ccb62f338436dac5e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and deep copy the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> into the mirror. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> and performs the deep copy.  <br /></td></tr>
<tr class="separator:aa22f44dbf5e03ccb62f338436dac5e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4814c237861e275fbcb767ad6c420cb" id="r_ad4814c237861e275fbcb767ad6c420cb"><td class="memTemplParams" colspan="2">template&lt;class DstAoSoA, class SrcAoSoA&gt; </td></tr>
<tr class="memitem:ad4814c237861e275fbcb767ad6c420cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad4814c237861e275fbcb767ad6c420cb">deep_copy</a> (DstAoSoA &amp;dst, const SrcAoSoA &amp;src, std::enable_if_t&lt;(<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; DstAoSoA &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt; *=nullptr)</td></tr>
<tr class="memdesc:ad4814c237861e275fbcb767ad6c420cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy data between compatible <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> objects.  <br /></td></tr>
<tr class="separator:ad4814c237861e275fbcb767ad6c420cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae797717188eda2dbe524f73fd791f8c1" id="r_ae797717188eda2dbe524f73fd791f8c1"><td class="memTemplParams" colspan="2">template&lt;class DstMemorySpace, class SrcMemorySpace, int DstVectorLength, int SrcVectorLength, class... FieldTags&gt; </td></tr>
<tr class="memitem:ae797717188eda2dbe524f73fd791f8c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae797717188eda2dbe524f73fd791f8c1">deep_copy</a> (<a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; DstMemorySpace, DstVectorLength, FieldTags... &gt; &amp;dst, const <a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; SrcMemorySpace, SrcVectorLength, FieldTags... &gt; &amp;src)</td></tr>
<tr class="memdesc:ae797717188eda2dbe524f73fd791f8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy data between compatible <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> objects.  <br /></td></tr>
<tr class="separator:ae797717188eda2dbe524f73fd791f8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f82fe027dec446d5ff114b36e2a30be" id="r_a0f82fe027dec446d5ff114b36e2a30be"><td class="memTemplParams" colspan="2">template&lt;class AoSoA_t&gt; </td></tr>
<tr class="memitem:a0f82fe027dec446d5ff114b36e2a30be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f82fe027dec446d5ff114b36e2a30be">deep_copy</a> (AoSoA_t &amp;aosoa, const typename AoSoA_t::tuple_type &amp;tuple)</td></tr>
<tr class="memdesc:a0f82fe027dec446d5ff114b36e2a30be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> with a tuple.  <br /></td></tr>
<tr class="separator:a0f82fe027dec446d5ff114b36e2a30be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc1a6a5c0d637aba8406c5095c0f29a" id="r_a3bc1a6a5c0d637aba8406c5095c0f29a"><td class="memTemplParams" colspan="2">template&lt;class DstSlice, class SrcSlice&gt; </td></tr>
<tr class="memitem:a3bc1a6a5c0d637aba8406c5095c0f29a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3bc1a6a5c0d637aba8406c5095c0f29a">deep_copy</a> (DstSlice &amp;dst, const SrcSlice &amp;src, std::enable_if_t&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; DstSlice &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SrcSlice &gt;::value)&gt; *=nullptr)</td></tr>
<tr class="memdesc:a3bc1a6a5c0d637aba8406c5095c0f29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy data between compatible <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> objects.  <br /></td></tr>
<tr class="separator:a3bc1a6a5c0d637aba8406c5095c0f29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae209c92053381625d4d040bb1f74682b" id="r_ae209c92053381625d4d040bb1f74682b"><td class="memTemplParams" colspan="2">template&lt;class Slice_t&gt; </td></tr>
<tr class="memitem:ae209c92053381625d4d040bb1f74682b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae209c92053381625d4d040bb1f74682b">deep_copy</a> (Slice_t &amp;<a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, const typename Slice_t::value_type scalar)</td></tr>
<tr class="memdesc:ae209c92053381625d4d040bb1f74682b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a slice with a scalar.  <br /></td></tr>
<tr class="separator:ae209c92053381625d4d040bb1f74682b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ce54b97e3aa320e6108b0e978e1df0" id="r_a79ce54b97e3aa320e6108b0e978e1df0"><td class="memTemplParams" colspan="2">template&lt;class DstMemorySpace, class SrcMemorySpace, int VectorLength, class... FieldTags&gt; </td></tr>
<tr class="memitem:a79ce54b97e3aa320e6108b0e978e1df0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a79ce54b97e3aa320e6108b0e978e1df0">create_mirror_view_and_copy</a> (DstMemorySpace, <a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; SrcMemorySpace, VectorLength, FieldTags... &gt; plist_src, std::enable_if_t&lt; std::is_same_v&lt; SrcMemorySpace, DstMemorySpace &gt; &gt; *=nullptr)</td></tr>
<tr class="memdesc:a79ce54b97e3aa320e6108b0e978e1df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror of the given <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> in the given memory space.  <br /></td></tr>
<tr class="separator:a79ce54b97e3aa320e6108b0e978e1df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139eac1fa0c2578743ed90b3bee42bd0" id="r_a139eac1fa0c2578743ed90b3bee42bd0"><td class="memTemplParams" colspan="2">template&lt;class DstMemorySpace, class SrcMemorySpace, int VectorLength, class... FieldTags&gt; </td></tr>
<tr class="memitem:a139eac1fa0c2578743ed90b3bee42bd0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a139eac1fa0c2578743ed90b3bee42bd0">create_mirror_view_and_copy</a> (DstMemorySpace, <a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; SrcMemorySpace, VectorLength, FieldTags... &gt; plist_src, std::enable_if_t&lt;!std::is_same_v&lt; SrcMemorySpace, DstMemorySpace &gt; &gt; *=nullptr)</td></tr>
<tr class="memdesc:a139eac1fa0c2578743ed90b3bee42bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror of the given <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> in the given memory space.  <br /></td></tr>
<tr class="separator:a139eac1fa0c2578743ed90b3bee42bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a83e23020e924fb010e2f5c20dbcc76" id="r_a7a83e23020e924fb010e2f5c20dbcc76"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class Distributor_t, class AoSoA_t&gt; </td></tr>
<tr class="memitem:a7a83e23020e924fb010e2f5c20dbcc76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a83e23020e924fb010e2f5c20dbcc76">migrate</a> (ExecutionSpace exec_space, const Distributor_t &amp;distributor, const AoSoA_t &amp;src, AoSoA_t &amp;dst, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a7a83e23020e924fb010e2f5c20dbcc76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. Multiple <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version.  <br /></td></tr>
<tr class="separator:a7a83e23020e924fb010e2f5c20dbcc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb10ac278624d871f6079c4e24ccb219" id="r_adb10ac278624d871f6079c4e24ccb219"><td class="memTemplParams" colspan="2">template&lt;class Distributor_t, class AoSoA_t&gt; </td></tr>
<tr class="memitem:adb10ac278624d871f6079c4e24ccb219"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb10ac278624d871f6079c4e24ccb219">migrate</a> (const Distributor_t &amp;distributor, const AoSoA_t &amp;src, AoSoA_t &amp;dst, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:adb10ac278624d871f6079c4e24ccb219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. Multiple <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version.  <br /></td></tr>
<tr class="separator:adb10ac278624d871f6079c4e24ccb219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b49b38dd2be95b2b905698d063a0736" id="r_a4b49b38dd2be95b2b905698d063a0736"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class Distributor_t, class AoSoA_t&gt; </td></tr>
<tr class="memitem:a4b49b38dd2be95b2b905698d063a0736"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b49b38dd2be95b2b905698d063a0736">migrate</a> (ExecutionSpace exec_space, const Distributor_t &amp;distributor, AoSoA_t &amp;aosoa, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a4b49b38dd2be95b2b905698d063a0736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. Single <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version that will resize in-place. Note that resizing does not necessarily allocate more memory. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> memory will only increase if not enough has already been reserved/allocated for the needed number of elements.  <br /></td></tr>
<tr class="separator:a4b49b38dd2be95b2b905698d063a0736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cb44110c8a6215d2ca62406e8aed35" id="r_ab9cb44110c8a6215d2ca62406e8aed35"><td class="memTemplParams" colspan="2">template&lt;class Distributor_t, class AoSoA_t&gt; </td></tr>
<tr class="memitem:ab9cb44110c8a6215d2ca62406e8aed35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab9cb44110c8a6215d2ca62406e8aed35">migrate</a> (const Distributor_t &amp;distributor, AoSoA_t &amp;aosoa, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ab9cb44110c8a6215d2ca62406e8aed35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. Single <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version that will resize in-place. Note that resizing does not necessarily allocate more memory. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> memory will only increase if not enough has already been reserved/allocated for the needed number of elements.  <br /></td></tr>
<tr class="separator:ab9cb44110c8a6215d2ca62406e8aed35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28763cb86df25a0d48011c19ddd69fc9" id="r_a28763cb86df25a0d48011c19ddd69fc9"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class Distributor_t, class Slice_t&gt; </td></tr>
<tr class="memitem:a28763cb86df25a0d48011c19ddd69fc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a28763cb86df25a0d48011c19ddd69fc9">migrate</a> (ExecutionSpace exec_space, const Distributor_t &amp;distributor, const Slice_t &amp;src, Slice_t &amp;dst, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a28763cb86df25a0d48011c19ddd69fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. The user can do this in-place with the same slice but they will need to manage the resizing themselves as we can't resize slices.  <br /></td></tr>
<tr class="separator:a28763cb86df25a0d48011c19ddd69fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82063f55f2d0c3d17d11ba6642fb7353" id="r_a82063f55f2d0c3d17d11ba6642fb7353"><td class="memTemplParams" colspan="2">template&lt;class Distributor_t, class Slice_t&gt; </td></tr>
<tr class="memitem:a82063f55f2d0c3d17d11ba6642fb7353"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a82063f55f2d0c3d17d11ba6642fb7353">migrate</a> (const Distributor_t &amp;distributor, const Slice_t &amp;src, Slice_t &amp;dst, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a82063f55f2d0c3d17d11ba6642fb7353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. The user can do this in-place with the same slice but they will need to manage the resizing themselves as we can't resize slices.  <br /></td></tr>
<tr class="separator:a82063f55f2d0c3d17d11ba6642fb7353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45fca0815618ea3fe95fcf688f38dc6" id="r_ad45fca0815618ea3fe95fcf688f38dc6"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classCabana_1_1Halo.html">Halo</a>, class ParticleData&gt; </td></tr>
<tr class="memitem:ad45fca0815618ea3fe95fcf688f38dc6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad45fca0815618ea3fe95fcf688f38dc6">haloCheckValidSize</a> (const <a class="el" href="classCabana_1_1Halo.html">Halo</a> &amp;halo, const ParticleData &amp;particles, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; <a class="el" href="classCabana_1_1Halo.html">Halo</a> &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ad45fca0815618ea3fe95fcf688f38dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure the particle size matches the total halo (local and ghost) size.  <br /></td></tr>
<tr class="separator:ad45fca0815618ea3fe95fcf688f38dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe4862a55c2c1e611de4447db7cbedb" id="r_acfe4862a55c2c1e611de4447db7cbedb"><td class="memTemplParams" colspan="2">template&lt;class HaloType, class ParticleDataType&gt; </td></tr>
<tr class="memitem:acfe4862a55c2c1e611de4447db7cbedb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acfe4862a55c2c1e611de4447db7cbedb">createGather</a> (const HaloType &amp;halo, const ParticleDataType &amp;data, const double overallocation=1.0)</td></tr>
<tr class="memdesc:acfe4862a55c2c1e611de4447db7cbedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the gather.  <br /></td></tr>
<tr class="separator:acfe4862a55c2c1e611de4447db7cbedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75770ffe2209e474ae14436511d6b326" id="r_a75770ffe2209e474ae14436511d6b326"><td class="memTemplParams" colspan="2">template&lt;class HaloType, class ParticleDataType&gt; </td></tr>
<tr class="memitem:a75770ffe2209e474ae14436511d6b326"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a75770ffe2209e474ae14436511d6b326">gather</a> (const HaloType &amp;halo, ParticleDataType &amp;data)</td></tr>
<tr class="memdesc:a75770ffe2209e474ae14436511d6b326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. This is a uniquely-owned to multiply-owned communication.  <br /></td></tr>
<tr class="separator:a75770ffe2209e474ae14436511d6b326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc228ac6b568dd1c43f84dee0093b3fd" id="r_abc228ac6b568dd1c43f84dee0093b3fd"><td class="memTemplParams" colspan="2">template&lt;class HaloType, class SliceType&gt; </td></tr>
<tr class="memitem:abc228ac6b568dd1c43f84dee0093b3fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abc228ac6b568dd1c43f84dee0093b3fd">createScatter</a> (const HaloType &amp;halo, const SliceType &amp;<a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, const double overallocation=1.0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; HaloType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:abc228ac6b568dd1c43f84dee0093b3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the scatter.  <br /></td></tr>
<tr class="separator:abc228ac6b568dd1c43f84dee0093b3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8eb6aa8da865a5ff9c1a86f1ba0a281" id="r_aa8eb6aa8da865a5ff9c1a86f1ba0a281"><td class="memTemplParams" colspan="2">template&lt;class HaloType, class SliceType&gt; </td></tr>
<tr class="memitem:aa8eb6aa8da865a5ff9c1a86f1ba0a281"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8eb6aa8da865a5ff9c1a86f1ba0a281">scatter</a> (const HaloType &amp;halo, SliceType &amp;<a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; HaloType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:aa8eb6aa8da865a5ff9c1a86f1ba0a281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously scatter data from the ghosts to the local decomposition of a slice using the halo reverse communication plan. This is a multiply-owned to uniquely owned communication.  <br /></td></tr>
<tr class="separator:aa8eb6aa8da865a5ff9c1a86f1ba0a281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e383a5f93e7ff1d54b1071c9e18feb4" id="r_a9e383a5f93e7ff1d54b1071c9e18feb4"><td class="memTemplParams" colspan="2">template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args, class Scalar, std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:a9e383a5f93e7ff1d54b1071c9e18feb4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e383a5f93e7ff1d54b1071c9e18feb4">createLinkedCellList</a> (PositionType positions, const ArrayType&lt; Scalar, NumSpaceDim &gt; grid_delta, const ArrayType&lt; Scalar, NumSpaceDim &gt; grid_min, const ArrayType&lt; Scalar, NumSpaceDim &gt; grid_max)</td></tr>
<tr class="memdesc:a9e383a5f93e7ff1d54b1071c9e18feb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for linked cell list.  <br /></td></tr>
<tr class="separator:a9e383a5f93e7ff1d54b1071c9e18feb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cb83164537db1ef13f82b3402134bb" id="r_a40cb83164537db1ef13f82b3402134bb"><td class="memTemplParams" colspan="2">template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args, class Scalar, std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:a40cb83164537db1ef13f82b3402134bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a40cb83164537db1ef13f82b3402134bb">createLinkedCellList</a> (PositionType positions, const std::size_t begin, const std::size_t end, const ArrayType&lt; Scalar, NumSpaceDim &gt; grid_delta, const ArrayType&lt; Scalar, NumSpaceDim &gt; grid_min, const ArrayType&lt; Scalar, NumSpaceDim &gt; grid_max)</td></tr>
<tr class="memdesc:a40cb83164537db1ef13f82b3402134bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for linked cell list with partial range.  <br /></td></tr>
<tr class="separator:a40cb83164537db1ef13f82b3402134bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a362466441bacacbf3d43ff5af57d4" id="r_a38a362466441bacacbf3d43ff5af57d4"><td class="memTemplParams" colspan="2">template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args, class Scalar, std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:a38a362466441bacacbf3d43ff5af57d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a38a362466441bacacbf3d43ff5af57d4">createLinkedCellList</a> (PositionType positions, const ArrayType&lt; Scalar, NumSpaceDim &gt; grid_delta, const ArrayType&lt; Scalar, NumSpaceDim &gt; grid_min, const ArrayType&lt; Scalar, NumSpaceDim &gt; grid_max, const typename PositionType::value_type neighborhood_radius, const typename PositionType::value_type cell_size_ratio=1.0)</td></tr>
<tr class="memdesc:a38a362466441bacacbf3d43ff5af57d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for linked cell list with custom cutoff radius and cell ratio.  <br /></td></tr>
<tr class="separator:a38a362466441bacacbf3d43ff5af57d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c63d0a9605d8034581758d74902a9d6" id="r_a8c63d0a9605d8034581758d74902a9d6"><td class="memTemplParams" colspan="2">template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args, class Scalar, std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:a8c63d0a9605d8034581758d74902a9d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c63d0a9605d8034581758d74902a9d6">createLinkedCellList</a> (PositionType positions, const std::size_t begin, const std::size_t end, const ArrayType&lt; Scalar, NumSpaceDim &gt; grid_delta, const ArrayType&lt; Scalar, NumSpaceDim &gt; grid_min, const ArrayType&lt; Scalar, NumSpaceDim &gt; grid_max, const typename PositionType::value_type neighborhood_radius, const typename PositionType::value_type cell_size_ratio=1.0)</td></tr>
<tr class="memdesc:a8c63d0a9605d8034581758d74902a9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for linked cell list with partial range and custom cutoff radius and/or cell ratio.  <br /></td></tr>
<tr class="separator:a8c63d0a9605d8034581758d74902a9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbab298f727489057132f718552892c" id="r_afcbab298f727489057132f718552892c"><td class="memTemplParams" colspan="2">template&lt;class PositionType&gt; </td></tr>
<tr class="memitem:afcbab298f727489057132f718552892c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afcbab298f727489057132f718552892c">createLinkedCellList</a> (PositionType positions, const typename PositionType::value_type grid_delta[3], const typename PositionType::value_type grid_min[3], const typename PositionType::value_type grid_max[3])</td></tr>
<tr class="memdesc:afcbab298f727489057132f718552892c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for linked cell list.  <br /></td></tr>
<tr class="separator:afcbab298f727489057132f718552892c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea42084be73f3ef96b5003ead86775c" id="r_a0ea42084be73f3ef96b5003ead86775c"><td class="memTemplParams" colspan="2">template&lt;class PositionType&gt; </td></tr>
<tr class="memitem:a0ea42084be73f3ef96b5003ead86775c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ea42084be73f3ef96b5003ead86775c">createLinkedCellList</a> (PositionType positions, const std::size_t begin, const std::size_t end, const typename PositionType::value_type grid_delta[3], const typename PositionType::value_type grid_min[3], const typename PositionType::value_type grid_max[3])</td></tr>
<tr class="memdesc:a0ea42084be73f3ef96b5003ead86775c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for linked cell list with partial range.  <br /></td></tr>
<tr class="separator:a0ea42084be73f3ef96b5003ead86775c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa9b63a296c89bc6ba8fa2fa8f39883" id="r_a4fa9b63a296c89bc6ba8fa2fa8f39883"><td class="memTemplParams" colspan="2">template&lt;class PositionType&gt; </td></tr>
<tr class="memitem:a4fa9b63a296c89bc6ba8fa2fa8f39883"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4fa9b63a296c89bc6ba8fa2fa8f39883">createLinkedCellList</a> (PositionType positions, const typename PositionType::value_type grid_delta[3], const typename PositionType::value_type grid_min[3], const typename PositionType::value_type grid_max[3], const typename PositionType::value_type neighborhood_radius, const typename PositionType::value_type cell_size_ratio=1.0)</td></tr>
<tr class="memdesc:a4fa9b63a296c89bc6ba8fa2fa8f39883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for linked cell list with custom cutoff radius and cell ratio.  <br /></td></tr>
<tr class="separator:a4fa9b63a296c89bc6ba8fa2fa8f39883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9803c3cb15899b5e673d57c166b50329" id="r_a9803c3cb15899b5e673d57c166b50329"><td class="memTemplParams" colspan="2">template&lt;class PositionType&gt; </td></tr>
<tr class="memitem:a9803c3cb15899b5e673d57c166b50329"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9803c3cb15899b5e673d57c166b50329">createLinkedCellList</a> (PositionType positions, const std::size_t begin, const std::size_t end, const typename PositionType::value_type grid_delta[3], const typename PositionType::value_type grid_min[3], const typename PositionType::value_type grid_max[3], const typename PositionType::value_type neighborhood_radius, const typename PositionType::value_type cell_size_ratio=1.0)</td></tr>
<tr class="memdesc:a9803c3cb15899b5e673d57c166b50329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for linked cell list with partial range and custom cutoff radius and/or cell ratio.  <br /></td></tr>
<tr class="separator:a9803c3cb15899b5e673d57c166b50329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718a56e3bd90ee4e6b80095fd15a9db7" id="r_a718a56e3bd90ee4e6b80095fd15a9db7"><td class="memTemplParams" colspan="2">template&lt;class LinkedCellListType, class PositionType&gt; </td></tr>
<tr class="memitem:a718a56e3bd90ee4e6b80095fd15a9db7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a718a56e3bd90ee4e6b80095fd15a9db7">permute</a> (LinkedCellListType &amp;linked_cell_list, PositionType &amp;positions, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellListType &gt;::value &amp;&amp;(<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; PositionType &gt;::value||<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value)), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a718a56e3bd90ee4e6b80095fd15a9db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a linked cell list permute positions.  <br /></td></tr>
<tr class="separator:a718a56e3bd90ee4e6b80095fd15a9db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cddd6233e137bfbe2ca4773e565e5d" id="r_a70cddd6233e137bfbe2ca4773e565e5d"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class ListType&gt; </td></tr>
<tr class="memitem:a70cddd6233e137bfbe2ca4773e565e5d"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; int *[2], typename ListType::memory_space &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70cddd6233e137bfbe2ca4773e565e5d">neighborHistogram</a> (ExecutionSpace exec_space, const std::size_t num_particles, const ListType &amp;list, const int num_bin)</td></tr>
<tr class="memdesc:a70cddd6233e137bfbe2ca4773e565e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a histogram of neighbors per particle.  <br /></td></tr>
<tr class="separator:a70cddd6233e137bfbe2ca4773e565e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dda1a05e595dbec3f4f06e7f878d9e" id="r_ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="memTemplParams" colspan="2">template&lt;class FunctorType, int VectorLength, class... ExecParameters&gt; </td></tr>
<tr class="memitem:ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7dda1a05e595dbec3f4f06e7f878d9e">simd_parallel_for</a> (const <a class="el" href="classCabana_1_1SimdPolicy.html">SimdPolicy</a>&lt; VectorLength, ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a vectorized functor in parallel with a 2d execution policy.  <br /></td></tr>
<tr class="separator:ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b18535ed149bb8aa6c8e4217c0dff9" id="r_a24b18535ed149bb8aa6c8e4217c0dff9"><td class="memTemplParams" colspan="2">template&lt;class FunctorType, class NeighborListType, class... ExecParameters&gt; </td></tr>
<tr class="memitem:a24b18535ed149bb8aa6c8e4217c0dff9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a24b18535ed149bb8aa6c8e4217c0dff9">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, const std::string &amp;str=&quot;&quot;, typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a24b18535ed149bb8aa6c8e4217c0dff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with a thread-local serial loop over particle first neighbors.  <br /></td></tr>
<tr class="separator:a24b18535ed149bb8aa6c8e4217c0dff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805d7df1a47edd9c4daaa11d70555401" id="r_a805d7df1a47edd9c4daaa11d70555401"><td class="memTemplParams" colspan="2">template&lt;class FunctorType, class NeighborListType, class... ExecParameters&gt; </td></tr>
<tr class="memitem:a805d7df1a47edd9c4daaa11d70555401"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a805d7df1a47edd9c4daaa11d70555401">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, const std::string &amp;str=&quot;&quot;, typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a805d7df1a47edd9c4daaa11d70555401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with thread-local serial loops over particle first and second neighbors.  <br /></td></tr>
<tr class="separator:a805d7df1a47edd9c4daaa11d70555401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdf5eabe42ed35aa32b9d5b5bdf87f4" id="r_aefdf5eabe42ed35aa32b9d5b5bdf87f4"><td class="memTemplParams" colspan="2">template&lt;class FunctorType, class NeighborListType, class... ExecParameters&gt; </td></tr>
<tr class="memitem:aefdf5eabe42ed35aa32b9d5b5bdf87f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aefdf5eabe42ed35aa32b9d5b5bdf87f4">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, const std::string &amp;str=&quot;&quot;, typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:aefdf5eabe42ed35aa32b9d5b5bdf87f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors.  <br /></td></tr>
<tr class="separator:aefdf5eabe42ed35aa32b9d5b5bdf87f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229fb2c6ed2f887d59fea0b9e2bbcb35" id="r_a229fb2c6ed2f887d59fea0b9e2bbcb35"><td class="memTemplParams" colspan="2">template&lt;class FunctorType, class NeighborListType, class... ExecParameters&gt; </td></tr>
<tr class="memitem:a229fb2c6ed2f887d59fea0b9e2bbcb35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a229fb2c6ed2f887d59fea0b9e2bbcb35">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, const std::string &amp;str=&quot;&quot;, typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a229fb2c6ed2f887d59fea0b9e2bbcb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors and serial loop over second neighbors.  <br /></td></tr>
<tr class="separator:a229fb2c6ed2f887d59fea0b9e2bbcb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ef15a052c4647babb9bb12229b9804" id="r_af4ef15a052c4647babb9bb12229b9804"><td class="memTemplParams" colspan="2">template&lt;class FunctorType, class NeighborListType, class... ExecParameters&gt; </td></tr>
<tr class="memitem:af4ef15a052c4647babb9bb12229b9804"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af4ef15a052c4647babb9bb12229b9804">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a>, const std::string &amp;str=&quot;&quot;, typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:af4ef15a052c4647babb9bb12229b9804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors and vector loop parallelism over second neighbors.  <br /></td></tr>
<tr class="separator:af4ef15a052c4647babb9bb12229b9804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5394edf96f28ccd3f77d88044c1cf46a" id="r_a5394edf96f28ccd3f77d88044c1cf46a"><td class="memTemplParams" colspan="2">template&lt;class FunctorType, class NeighborListType, class ReduceType, class... ExecParameters&gt; </td></tr>
<tr class="memitem:a5394edf96f28ccd3f77d88044c1cf46a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5394edf96f28ccd3f77d88044c1cf46a">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;, typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a5394edf96f28ccd3f77d88044c1cf46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor reduction in parallel according to the execution policy over particles with a thread-local serial loop over particle first neighbors.  <br /></td></tr>
<tr class="separator:a5394edf96f28ccd3f77d88044c1cf46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7472fbee84a03c3af4cbbd85391713" id="r_a4b7472fbee84a03c3af4cbbd85391713"><td class="memTemplParams" colspan="2">template&lt;class FunctorType, class NeighborListType, class ReduceType, class... ExecParameters&gt; </td></tr>
<tr class="memitem:a4b7472fbee84a03c3af4cbbd85391713"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b7472fbee84a03c3af4cbbd85391713">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;, typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a4b7472fbee84a03c3af4cbbd85391713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor reduction in parallel according to the execution policy over particles with thread-local serial loops over particle first and second neighbors.  <br /></td></tr>
<tr class="separator:a4b7472fbee84a03c3af4cbbd85391713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37281baa1f9f01f2ab49ef1b7b2b059" id="r_ab37281baa1f9f01f2ab49ef1b7b2b059"><td class="memTemplParams" colspan="2">template&lt;class FunctorType, class NeighborListType, class ReduceType, class... ExecParameters&gt; </td></tr>
<tr class="memitem:ab37281baa1f9f01f2ab49ef1b7b2b059"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab37281baa1f9f01f2ab49ef1b7b2b059">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;, typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ab37281baa1f9f01f2ab49ef1b7b2b059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors.  <br /></td></tr>
<tr class="separator:ab37281baa1f9f01f2ab49ef1b7b2b059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e09860dc2f238e0201b091d563d4e1c" id="r_a2e09860dc2f238e0201b091d563d4e1c"><td class="memTemplParams" colspan="2">template&lt;class FunctorType, class NeighborListType, class ReduceType, class... ExecParameters&gt; </td></tr>
<tr class="memitem:a2e09860dc2f238e0201b091d563d4e1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e09860dc2f238e0201b091d563d4e1c">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;, typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a2e09860dc2f238e0201b091d563d4e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors and serial loop over second neighbors.  <br /></td></tr>
<tr class="separator:a2e09860dc2f238e0201b091d563d4e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e10a632cbe3a11615c60c1ef1f8300" id="r_a75e10a632cbe3a11615c60c1ef1f8300"><td class="memTemplParams" colspan="2">template&lt;class FunctorType, class NeighborListType, class ReduceType, class... ExecParameters&gt; </td></tr>
<tr class="memitem:a75e10a632cbe3a11615c60c1ef1f8300"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a75e10a632cbe3a11615c60c1ef1f8300">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;, typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a75e10a632cbe3a11615c60c1ef1f8300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors and vector loop parallelism over second neighbors.  <br /></td></tr>
<tr class="separator:a75e10a632cbe3a11615c60c1ef1f8300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15dca4f62c3f1f9cb7a9c869c7ae3486" id="r_a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="memTemplParams" colspan="2">template&lt;class IndexType, class FunctorType, class NeighborListType&gt; </td></tr>
<tr class="memitem:a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a15dca4f62c3f1f9cb7a9c869c7ae3486">for_each_neighbor</a> (const IndexType i, const FunctorType &amp;neighbor_functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>)</td></tr>
<tr class="memdesc:a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in serial within existing parallel kernel over particle first neighbors.  <br /></td></tr>
<tr class="separator:a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366034424ecf96ad51645694c2d71676" id="r_a366034424ecf96ad51645694c2d71676"><td class="memTemplParams" colspan="2">template&lt;class IndexType, class FunctorType, class NeighborListType, class TeamMemberType&gt; </td></tr>
<tr class="memitem:a366034424ecf96ad51645694c2d71676"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a366034424ecf96ad51645694c2d71676">for_each_neighbor</a> (const IndexType i, const TeamMemberType team, const FunctorType &amp;neighbor_functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>)</td></tr>
<tr class="memdesc:a366034424ecf96ad51645694c2d71676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute team parallel functor within existing parallel kernel over particle first neighbors.  <br /></td></tr>
<tr class="separator:a366034424ecf96ad51645694c2d71676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f630b4b7e635dc521ad68b849140b6" id="r_ad9f630b4b7e635dc521ad68b849140b6"><td class="memTemplParams" colspan="2">template&lt;class FunctorType, class LinkedCellType, class... ExecParameters&gt; </td></tr>
<tr class="memitem:ad9f630b4b7e635dc521ad68b849140b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9f630b4b7e635dc521ad68b849140b6">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const LinkedCellType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, const std::string &amp;str=&quot;&quot;, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ad9f630b4b7e635dc521ad68b849140b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with thread-local serial loops over linked cell list bins and particle first neighbors in those bins.  <br /></td></tr>
<tr class="separator:ad9f630b4b7e635dc521ad68b849140b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fa816fbb9649b98b6765cbb9603e0b" id="r_a47fa816fbb9649b98b6765cbb9603e0b"><td class="memTemplParams" colspan="2">template&lt;class FunctorType, class LinkedCellType, class... ExecParameters&gt; </td></tr>
<tr class="memitem:a47fa816fbb9649b98b6765cbb9603e0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a47fa816fbb9649b98b6765cbb9603e0b">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const LinkedCellType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, const std::string &amp;str=&quot;&quot;, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a47fa816fbb9649b98b6765cbb9603e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with thread-local serial loops over linked cell list bins and team threading over particle first neighbors in those bins.  <br /></td></tr>
<tr class="separator:a47fa816fbb9649b98b6765cbb9603e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d6d642d6860adcd8a0f37f9c740b89" id="r_a29d6d642d6860adcd8a0f37f9c740b89"><td class="memTemplParams" colspan="2">template&lt;class FunctorType, class LinkedCellType, class ReduceType, class... ExecParameters&gt; </td></tr>
<tr class="memitem:a29d6d642d6860adcd8a0f37f9c740b89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a29d6d642d6860adcd8a0f37f9c740b89">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const LinkedCellType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a29d6d642d6860adcd8a0f37f9c740b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with thread-local serial loops over linked cell list bins and particle first neighbors in those bins.  <br /></td></tr>
<tr class="separator:a29d6d642d6860adcd8a0f37f9c740b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507a2bc4113be499490095b0d956e922" id="r_a507a2bc4113be499490095b0d956e922"><td class="memTemplParams" colspan="2">template&lt;class FunctorType, class LinkedCellType, class ReduceType, class... ExecParameters&gt; </td></tr>
<tr class="memitem:a507a2bc4113be499490095b0d956e922"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a507a2bc4113be499490095b0d956e922">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const LinkedCellType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a507a2bc4113be499490095b0d956e922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with thread-local serial loops over linked cell list bins and team threading over particle first neighbors in those bins.  <br /></td></tr>
<tr class="separator:a507a2bc4113be499490095b0d956e922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4f420020f1eb963c2012491a90d259" id="r_adb4f420020f1eb963c2012491a90d259"><td class="memTemplParams" colspan="2"><a id="adb4f420020f1eb963c2012491a90d259" name="adb4f420020f1eb963c2012491a90d259"></a>
template&lt;std::size_t N, class ParameterPack_t&gt; </td></tr>
<tr class="memitem:adb4f420020f1eb963c2012491a90d259"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__parameter__pack.html">is_parameter_pack</a>&lt; ParameterPack_t &gt;::value, typenameParameterPack_t::templatevalue_type&lt; N &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (ParameterPack_t &amp;pp)</td></tr>
<tr class="memdesc:adb4f420020f1eb963c2012491a90d259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an element from a parameter pack. <br /></td></tr>
<tr class="separator:adb4f420020f1eb963c2012491a90d259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14251895a18c9d8412d0c06857190d38" id="r_a14251895a18c9d8412d0c06857190d38"><td class="memTemplParams" colspan="2"><a id="a14251895a18c9d8412d0c06857190d38" name="a14251895a18c9d8412d0c06857190d38"></a>
template&lt;std::size_t N, class ParameterPack_t&gt; </td></tr>
<tr class="memitem:a14251895a18c9d8412d0c06857190d38"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__parameter__pack.html">is_parameter_pack</a>&lt; ParameterPack_t &gt;::value, consttypenameParameterPack_t::templatevalue_type&lt; N &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const ParameterPack_t &amp;pp)</td></tr>
<tr class="memdesc:a14251895a18c9d8412d0c06857190d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an element from a parameter pack. <br /></td></tr>
<tr class="separator:a14251895a18c9d8412d0c06857190d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1bdb5946e4dfb5f96695e6cee6484d" id="r_a6b1bdb5946e4dfb5f96695e6cee6484d"><td class="memTemplParams" colspan="2">template&lt;typename ParameterPack_t, typename... Types&gt; </td></tr>
<tr class="memitem:a6b1bdb5946e4dfb5f96695e6cee6484d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b1bdb5946e4dfb5f96695e6cee6484d">fillParameterPack</a> (ParameterPack_t &amp;pp, const Types &amp;... ts)</td></tr>
<tr class="separator:a6b1bdb5946e4dfb5f96695e6cee6484d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b83ffcd0599afe7840925786c8ecdc2" id="r_a7b83ffcd0599afe7840925786c8ecdc2"><td class="memTemplParams" colspan="2"><a id="a7b83ffcd0599afe7840925786c8ecdc2" name="a7b83ffcd0599afe7840925786c8ecdc2"></a>
template&lt;typename ParameterPack_t&gt; </td></tr>
<tr class="memitem:a7b83ffcd0599afe7840925786c8ecdc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fillParameterPack</b> (ParameterPack_t &amp;)</td></tr>
<tr class="memdesc:a7b83ffcd0599afe7840925786c8ecdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty case - fill a parameter pack. <br /></td></tr>
<tr class="separator:a7b83ffcd0599afe7840925786c8ecdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaaf4e113887600b1f87d8ca86cb787" id="r_a6eaaf4e113887600b1f87d8ca86cb787"><td class="memTemplParams" colspan="2"><a id="a6eaaf4e113887600b1f87d8ca86cb787" name="a6eaaf4e113887600b1f87d8ca86cb787"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a6eaaf4e113887600b1f87d8ca86cb787"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCabana_1_1ParameterPack.html">ParameterPack</a>&lt; Types... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeParameterPack</b> (const Types &amp;... ts)</td></tr>
<tr class="memdesc:a6eaaf4e113887600b1f87d8ca86cb787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a parameter pack. <br /></td></tr>
<tr class="separator:a6eaaf4e113887600b1f87d8ca86cb787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2671b1bc9dec4a8b1359bedde822d6" id="r_a9b2671b1bc9dec4a8b1359bedde822d6"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class InitFunctor, class ParticleListType, template&lt; class, std::size_t, class... &gt; class ArrayType, class Scalar, std::size_t NumSpaceDim, class... Args&gt; </td></tr>
<tr class="memitem:a9b2671b1bc9dec4a8b1359bedde822d6"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b2671b1bc9dec4a8b1359bedde822d6">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a>, ExecutionSpace exec_space, const InitFunctor &amp;create_functor, ParticleListType &amp;particle_list, const std::size_t num_particles, const ArrayType&lt; Scalar, NumSpaceDim &gt; box_min, const ArrayType&lt; Scalar, NumSpaceDim &gt; box_max, const std::size_t previous_num_particles=0, const bool shrink_to_fit=true, const uint64_t seed=342343901, typename std::enable_if&lt; <a class="el" href="structCabana_1_1is__particle__list.html">is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *=0)</td></tr>
<tr class="memdesc:a9b2671b1bc9dec4a8b1359bedde822d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles given an initialization functor.  <br /></td></tr>
<tr class="separator:a9b2671b1bc9dec4a8b1359bedde822d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583b9b91774baa84b4cf9c7329f5e060" id="r_a583b9b91774baa84b4cf9c7329f5e060"><td class="memTemplParams" colspan="2">template&lt;class InitFunctor, class ParticleListType, template&lt; class, std::size_t, class... &gt; class ArrayType, class Scalar, std::size_t NumSpaceDim, class... Args&gt; </td></tr>
<tr class="memitem:a583b9b91774baa84b4cf9c7329f5e060"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a583b9b91774baa84b4cf9c7329f5e060">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a> tag, const InitFunctor &amp;create_functor, ParticleListType &amp;particle_list, const std::size_t num_particles, const ArrayType&lt; Scalar, NumSpaceDim &gt; box_min, const ArrayType&lt; Scalar, NumSpaceDim &gt; box_max, const std::size_t previous_num_particles=0, const bool shrink_to_fit=true, const uint64_t seed=342343901)</td></tr>
<tr class="memdesc:a583b9b91774baa84b4cf9c7329f5e060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles given an initialization functor.  <br /></td></tr>
<tr class="separator:a583b9b91774baa84b4cf9c7329f5e060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30d1ef7fbc683accab91198f9f4fc9b" id="r_ae30d1ef7fbc683accab91198f9f4fc9b"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class Scalar, std::size_t NumSpaceDim, class... Args&gt; </td></tr>
<tr class="memitem:ae30d1ef7fbc683accab91198f9f4fc9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae30d1ef7fbc683accab91198f9f4fc9b">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a>, ExecutionSpace exec_space, PositionType &amp;positions, const std::size_t num_particles, const ArrayType&lt; Scalar, NumSpaceDim &gt; box_min, const ArrayType&lt; Scalar, NumSpaceDim &gt; box_max, const std::size_t previous_num_particles=0, const uint64_t seed=342343901, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ae30d1ef7fbc683accab91198f9f4fc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles.  <br /></td></tr>
<tr class="separator:ae30d1ef7fbc683accab91198f9f4fc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf29cebb06e9ef6549b88f8cd5203c8b" id="r_abf29cebb06e9ef6549b88f8cd5203c8b"><td class="memTemplParams" colspan="2">template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class Scalar, std::size_t NumSpaceDim, class... Args&gt; </td></tr>
<tr class="memitem:abf29cebb06e9ef6549b88f8cd5203c8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf29cebb06e9ef6549b88f8cd5203c8b">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a> tag, PositionType &amp;positions, const std::size_t num_particles, const ArrayType&lt; Scalar, NumSpaceDim &gt; box_min, const ArrayType&lt; Scalar, NumSpaceDim &gt; box_max, const std::size_t previous_num_particles=0, const uint64_t seed=342343901, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:abf29cebb06e9ef6549b88f8cd5203c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles.  <br /></td></tr>
<tr class="separator:abf29cebb06e9ef6549b88f8cd5203c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5f1181821db2d1c60f2f781421e243" id="r_acd5f1181821db2d1c60f2f781421e243"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class PositionType, class Scalar&gt; </td></tr>
<tr class="memitem:acd5f1181821db2d1c60f2f781421e243"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd5f1181821db2d1c60f2f781421e243">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a> tag, ExecutionSpace exec_space, PositionType &amp;positions, const std::size_t num_particles, const Scalar box_min[3], const Scalar box_max[3], const std::size_t previous_num_particles=0, const uint64_t seed=342343901)</td></tr>
<tr class="memdesc:acd5f1181821db2d1c60f2f781421e243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles.  <br /></td></tr>
<tr class="separator:acd5f1181821db2d1c60f2f781421e243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d34d4150b74a2f908736ef2556d77d" id="r_a78d34d4150b74a2f908736ef2556d77d"><td class="memTemplParams" colspan="2">template&lt;class PositionType, class Scalar&gt; </td></tr>
<tr class="memitem:a78d34d4150b74a2f908736ef2556d77d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a78d34d4150b74a2f908736ef2556d77d">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a> tag, PositionType &amp;positions, const std::size_t num_particles, const Scalar box_min[3], const Scalar box_max[3], const std::size_t previous_num_particles=0, const uint64_t seed=342343901)</td></tr>
<tr class="memdesc:a78d34d4150b74a2f908736ef2556d77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles.  <br /></td></tr>
<tr class="separator:a78d34d4150b74a2f908736ef2556d77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a2dac93a3ad6a0f7b4c18505034a4e" id="r_ac1a2dac93a3ad6a0f7b4c18505034a4e"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class InitFunctor, class ParticleListType, class PositionTag, template&lt; class, std::size_t, class... &gt; class ArrayType, class Scalar, std::size_t NumSpaceDim, class... Args&gt; </td></tr>
<tr class="memitem:ac1a2dac93a3ad6a0f7b4c18505034a4e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac1a2dac93a3ad6a0f7b4c18505034a4e">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a> tag, ExecutionSpace exec_space, const InitFunctor &amp;create_functor, ParticleListType &amp;particle_list, PositionTag position_tag, const std::size_t num_particles, const double min_dist, const ArrayType&lt; Scalar, NumSpaceDim &gt; box_min, const ArrayType&lt; Scalar, NumSpaceDim &gt; box_max, const std::size_t previous_num_particles=0, const bool shrink_to_fit=true, const uint64_t seed=342343901, typename std::enable_if&lt; <a class="el" href="structCabana_1_1is__particle__list.html">is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *=0)</td></tr>
<tr class="memdesc:ac1a2dac93a3ad6a0f7b4c18505034a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles with minimum separation.  <br /></td></tr>
<tr class="separator:ac1a2dac93a3ad6a0f7b4c18505034a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0f00a2e33a94fb0968b984f8ad98f4" id="r_a2e0f00a2e33a94fb0968b984f8ad98f4"><td class="memTemplParams" colspan="2">template&lt;class InitFunctor, class ParticleListType, class PositionTag, template&lt; class, std::size_t, class... &gt; class ArrayType, class Scalar, std::size_t NumSpaceDim, class... Args&gt; </td></tr>
<tr class="memitem:a2e0f00a2e33a94fb0968b984f8ad98f4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e0f00a2e33a94fb0968b984f8ad98f4">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a> tag, const InitFunctor &amp;create_functor, ParticleListType &amp;particle_list, PositionTag position_tag, const std::size_t num_particles, const double min_dist, const ArrayType&lt; Scalar, NumSpaceDim &gt; box_min, const ArrayType&lt; Scalar, NumSpaceDim &gt; box_max, const std::size_t previous_num_particles=0, const bool shrink_to_fit=true, const uint64_t seed=342343901)</td></tr>
<tr class="memdesc:a2e0f00a2e33a94fb0968b984f8ad98f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles with minimum separation.  <br /></td></tr>
<tr class="separator:a2e0f00a2e33a94fb0968b984f8ad98f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e671252eada8128208cd1d430462bcc" id="r_a5e671252eada8128208cd1d430462bcc"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class PositionType, class Scalar&gt; </td></tr>
<tr class="memitem:a5e671252eada8128208cd1d430462bcc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5e671252eada8128208cd1d430462bcc">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a> tag, ExecutionSpace exec_space, PositionType &amp;positions, const std::size_t num_particles, const double min_dist, const Scalar box_min[3], const Scalar box_max[3], const std::size_t previous_num_particles=0, const uint64_t seed=342343901)</td></tr>
<tr class="memdesc:a5e671252eada8128208cd1d430462bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles.  <br /></td></tr>
<tr class="separator:a5e671252eada8128208cd1d430462bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63c282b6c8bb6ed977e9a627fe2ee35" id="r_ae63c282b6c8bb6ed977e9a627fe2ee35"><td class="memTemplParams" colspan="2">template&lt;class PositionType, class Scalar&gt; </td></tr>
<tr class="memitem:ae63c282b6c8bb6ed977e9a627fe2ee35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae63c282b6c8bb6ed977e9a627fe2ee35">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a> tag, PositionType &amp;positions, const std::size_t num_particles, const double min_dist, const Scalar box_min[3], const Scalar box_max[3], const std::size_t previous_num_particles=0, const uint64_t seed=342343901)</td></tr>
<tr class="memdesc:ae63c282b6c8bb6ed977e9a627fe2ee35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles.  <br /></td></tr>
<tr class="separator:ae63c282b6c8bb6ed977e9a627fe2ee35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c67163e307376c05b8136c34e98c65" id="r_a62c67163e307376c05b8136c34e98c65"><td class="memTemplParams" colspan="2"><a id="a62c67163e307376c05b8136c34e98c65" name="a62c67163e307376c05b8136c34e98c65"></a>
template&lt;class FieldTag, class... FieldTags, class... IndexTypes&gt; </td></tr>
<tr class="memitem:a62c67163e307376c05b8136c34e98c65"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; sizeof...(IndexTypes)==FieldTag::rank, typenameParticle&lt; FieldTags... &gt;::tuple_type::templatemember_const_reference_type&lt; <a class="el" href="structCabana_1_1TypeIndexer.html">TypeIndexer</a>&lt; FieldTag, FieldTags... &gt;::index &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="structCabana_1_1Particle.html">Particle</a>&lt; FieldTags... &gt; &amp;particle, FieldTag, IndexTypes... indices)</td></tr>
<tr class="memdesc:a62c67163e307376c05b8136c34e98c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a single element of a single field from indices. <br /></td></tr>
<tr class="separator:a62c67163e307376c05b8136c34e98c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ea7024be0d46c66d9b7dada37dd67f" id="r_a65ea7024be0d46c66d9b7dada37dd67f"><td class="memTemplParams" colspan="2"><a id="a65ea7024be0d46c66d9b7dada37dd67f" name="a65ea7024be0d46c66d9b7dada37dd67f"></a>
template&lt;class FieldTag, class... FieldTags, class... IndexTypes&gt; </td></tr>
<tr class="memitem:a65ea7024be0d46c66d9b7dada37dd67f"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; sizeof...(IndexTypes)==FieldTag::rank, typenameParticle&lt; FieldTags... &gt;::tuple_type::templatemember_reference_type&lt; <a class="el" href="structCabana_1_1TypeIndexer.html">TypeIndexer</a>&lt; FieldTag, FieldTags... &gt;::index &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="structCabana_1_1Particle.html">Particle</a>&lt; FieldTags... &gt; &amp;particle, FieldTag, IndexTypes... indices)</td></tr>
<tr class="memdesc:a65ea7024be0d46c66d9b7dada37dd67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a single element of a single field from indices. <br /></td></tr>
<tr class="separator:a65ea7024be0d46c66d9b7dada37dd67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c63d17c98d8be087c36aa47fd0bc76" id="r_ad3c63d17c98d8be087c36aa47fd0bc76"><td class="memTemplParams" colspan="2"><a id="ad3c63d17c98d8be087c36aa47fd0bc76" name="ad3c63d17c98d8be087c36aa47fd0bc76"></a>
template&lt;class FieldTag, class... FieldTags, class... IndexTypes, int VectorLength&gt; </td></tr>
<tr class="memitem:ad3c63d17c98d8be087c36aa47fd0bc76"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; sizeof...(IndexTypes)==FieldTag::rank, typenameParticleView&lt; VectorLength, FieldTags... &gt;::soa_type::templatemember_const_reference_type&lt; <a class="el" href="structCabana_1_1TypeIndexer.html">TypeIndexer</a>&lt; FieldTag, FieldTags... &gt;::index &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="structCabana_1_1ParticleView.html">ParticleView</a>&lt; VectorLength, FieldTags... &gt; &amp;particle, FieldTag, IndexTypes... indices)</td></tr>
<tr class="memdesc:ad3c63d17c98d8be087c36aa47fd0bc76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a single element of a single field from indices. <br /></td></tr>
<tr class="separator:ad3c63d17c98d8be087c36aa47fd0bc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a6fd2968bf1e1dd4a0c88d8b1846e5" id="r_a68a6fd2968bf1e1dd4a0c88d8b1846e5"><td class="memTemplParams" colspan="2"><a id="a68a6fd2968bf1e1dd4a0c88d8b1846e5" name="a68a6fd2968bf1e1dd4a0c88d8b1846e5"></a>
template&lt;class FieldTag, class... FieldTags, class... IndexTypes, int VectorLength&gt; </td></tr>
<tr class="memitem:a68a6fd2968bf1e1dd4a0c88d8b1846e5"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; sizeof...(IndexTypes)==FieldTag::rank, typenameParticleView&lt; VectorLength, FieldTags... &gt;::soa_type::templatemember_reference_type&lt; <a class="el" href="structCabana_1_1TypeIndexer.html">TypeIndexer</a>&lt; FieldTag, FieldTags... &gt;::index &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="structCabana_1_1ParticleView.html">ParticleView</a>&lt; VectorLength, FieldTags... &gt; &amp;particle, FieldTag, IndexTypes... indices)</td></tr>
<tr class="memdesc:a68a6fd2968bf1e1dd4a0c88d8b1846e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a single element of a single field from indices. <br /></td></tr>
<tr class="separator:a68a6fd2968bf1e1dd4a0c88d8b1846e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17482f78ec93101044be7fc5747e9f72" id="r_a17482f78ec93101044be7fc5747e9f72"><td class="memTemplParams" colspan="2">template&lt;class MemorySpace, int VectorLength, class... FieldTags&gt; </td></tr>
<tr class="memitem:a17482f78ec93101044be7fc5747e9f72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a17482f78ec93101044be7fc5747e9f72">createParticleList</a> (const std::string &amp;label, <a class="el" href="structCabana_1_1ParticleTraits.html">ParticleTraits</a>&lt; FieldTags... &gt;)</td></tr>
<tr class="memdesc:a17482f78ec93101044be7fc5747e9f72"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> creation function.  <br /></td></tr>
<tr class="separator:a17482f78ec93101044be7fc5747e9f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbf302d54f1080dc3fbb2fe74f69bdb" id="r_accbf302d54f1080dc3fbb2fe74f69bdb"><td class="memTemplParams" colspan="2">template&lt;class MemorySpace, class... FieldTags&gt; </td></tr>
<tr class="memitem:accbf302d54f1080dc3fbb2fe74f69bdb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#accbf302d54f1080dc3fbb2fe74f69bdb">createParticleList</a> (const std::string &amp;label, <a class="el" href="structCabana_1_1ParticleTraits.html">ParticleTraits</a>&lt; FieldTags... &gt;)</td></tr>
<tr class="memdesc:accbf302d54f1080dc3fbb2fe74f69bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> creation function with default vector length.  <br /></td></tr>
<tr class="separator:accbf302d54f1080dc3fbb2fe74f69bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a8672095ebecba36332e0b0ea60f94" id="r_af4a8672095ebecba36332e0b0ea60f94"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class KeepView, class ParticleAoSoA&gt; </td></tr>
<tr class="memitem:af4a8672095ebecba36332e0b0ea60f94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af4a8672095ebecba36332e0b0ea60f94">remove</a> (const ExecutionSpace &amp;exec_space, const int num_keep, const KeepView &amp;keep_particle, ParticleAoSoA &amp;particles, const int num_particles_ignore=0, const bool shrink_to_fit=true)</td></tr>
<tr class="memdesc:af4a8672095ebecba36332e0b0ea60f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter out empty/unneeded particles.  <br /></td></tr>
<tr class="separator:af4a8672095ebecba36332e0b0ea60f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f062f7dc8d19daf0c5b3830c04c51e" id="r_a55f062f7dc8d19daf0c5b3830c04c51e"><td class="memTemplParams" colspan="2"><a id="a55f062f7dc8d19daf0c5b3830c04c51e" name="a55f062f7dc8d19daf0c5b3830c04c51e"></a>
template&lt;class ExecutionSpace, class ViewType, class SliceType&gt; </td></tr>
<tr class="memitem:a55f062f7dc8d19daf0c5b3830c04c51e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copySliceToView</b> (ExecutionSpace exec_space, ViewType &amp;view, const SliceType &amp;<a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, const std::size_t begin, const std::size_t end, typename std::enable_if&lt; 2==SliceType::kokkos_view::traits::dimension::rank, int * &gt;::type=0)</td></tr>
<tr class="memdesc:a55f062f7dc8d19daf0c5b3830c04c51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from slice to View. Rank-0. <br /></td></tr>
<tr class="separator:a55f062f7dc8d19daf0c5b3830c04c51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39be444dae0eb366bd8f1482ce3a554" id="r_ac39be444dae0eb366bd8f1482ce3a554"><td class="memTemplParams" colspan="2"><a id="ac39be444dae0eb366bd8f1482ce3a554" name="ac39be444dae0eb366bd8f1482ce3a554"></a>
template&lt;class ExecutionSpace, class ViewType, class SliceType&gt; </td></tr>
<tr class="memitem:ac39be444dae0eb366bd8f1482ce3a554"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copySliceToView</b> (ExecutionSpace exec_space, ViewType &amp;view, const SliceType &amp;<a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, const std::size_t begin, const std::size_t end, typename std::enable_if&lt; 3==SliceType::kokkos_view::traits::dimension::rank, int * &gt;::type=0)</td></tr>
<tr class="memdesc:ac39be444dae0eb366bd8f1482ce3a554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from slice to View. Rank-1. <br /></td></tr>
<tr class="separator:ac39be444dae0eb366bd8f1482ce3a554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22dd879aa043dc81e11e15189e407bb" id="r_ac22dd879aa043dc81e11e15189e407bb"><td class="memTemplParams" colspan="2"><a id="ac22dd879aa043dc81e11e15189e407bb" name="ac22dd879aa043dc81e11e15189e407bb"></a>
template&lt;class ExecutionSpace, class ViewType, class SliceType&gt; </td></tr>
<tr class="memitem:ac22dd879aa043dc81e11e15189e407bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copySliceToView</b> (ExecutionSpace exec_space, ViewType &amp;view, const SliceType &amp;<a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, const std::size_t begin, const std::size_t end, typename std::enable_if&lt; 4==SliceType::kokkos_view::traits::dimension::rank, int * &gt;::type=0)</td></tr>
<tr class="memdesc:ac22dd879aa043dc81e11e15189e407bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from slice to View. Rank-2. <br /></td></tr>
<tr class="separator:ac22dd879aa043dc81e11e15189e407bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4351abc308d1deabc7450a5f37d2cad9" id="r_a4351abc308d1deabc7450a5f37d2cad9"><td class="memTemplParams" colspan="2"><a id="a4351abc308d1deabc7450a5f37d2cad9" name="a4351abc308d1deabc7450a5f37d2cad9"></a>
template&lt;class ViewType, class SliceType&gt; </td></tr>
<tr class="memitem:a4351abc308d1deabc7450a5f37d2cad9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copySliceToView</b> (ViewType &amp;view, const SliceType &amp;<a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, const std::size_t begin, const std::size_t end)</td></tr>
<tr class="memdesc:a4351abc308d1deabc7450a5f37d2cad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from slice to View with default execution space. <br /></td></tr>
<tr class="separator:a4351abc308d1deabc7450a5f37d2cad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bc1515cae7d5da7248006fdf113849" id="r_a44bc1515cae7d5da7248006fdf113849"><td class="memTemplParams" colspan="2"><a id="a44bc1515cae7d5da7248006fdf113849" name="a44bc1515cae7d5da7248006fdf113849"></a>
template&lt;class ExecutionSpace, class SliceType, class ViewType&gt; </td></tr>
<tr class="memitem:a44bc1515cae7d5da7248006fdf113849"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copyViewToSlice</b> (ExecutionSpace exec_space, SliceType &amp;<a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, const ViewType &amp;view, const std::size_t begin, const std::size_t end, typename std::enable_if&lt; 2==SliceType::kokkos_view::traits::dimension::rank, int * &gt;::type=0)</td></tr>
<tr class="memdesc:a44bc1515cae7d5da7248006fdf113849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from View to slice. Rank-0. <br /></td></tr>
<tr class="separator:a44bc1515cae7d5da7248006fdf113849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0938a572be03d7c205d58f9e81caf3" id="r_aae0938a572be03d7c205d58f9e81caf3"><td class="memTemplParams" colspan="2"><a id="aae0938a572be03d7c205d58f9e81caf3" name="aae0938a572be03d7c205d58f9e81caf3"></a>
template&lt;class ExecutionSpace, class SliceType, class ViewType&gt; </td></tr>
<tr class="memitem:aae0938a572be03d7c205d58f9e81caf3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copyViewToSlice</b> (ExecutionSpace exec_space, SliceType &amp;<a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, const ViewType &amp;view, const std::size_t begin, const std::size_t end, typename std::enable_if&lt; 3==SliceType::kokkos_view::traits::dimension::rank, int * &gt;::type=0)</td></tr>
<tr class="memdesc:aae0938a572be03d7c205d58f9e81caf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from View to slice. Rank-1. <br /></td></tr>
<tr class="separator:aae0938a572be03d7c205d58f9e81caf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3f27002f8056b1d72b94aa2301ba5e" id="r_aea3f27002f8056b1d72b94aa2301ba5e"><td class="memTemplParams" colspan="2"><a id="aea3f27002f8056b1d72b94aa2301ba5e" name="aea3f27002f8056b1d72b94aa2301ba5e"></a>
template&lt;class ExecutionSpace, class SliceType, class ViewType&gt; </td></tr>
<tr class="memitem:aea3f27002f8056b1d72b94aa2301ba5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copyViewToSlice</b> (ExecutionSpace exec_space, SliceType &amp;<a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, const ViewType &amp;view, const std::size_t begin, const std::size_t end, typename std::enable_if&lt; 4==SliceType::kokkos_view::traits::dimension::rank, int * &gt;::type=0)</td></tr>
<tr class="memdesc:aea3f27002f8056b1d72b94aa2301ba5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from View to slice. Rank-2. <br /></td></tr>
<tr class="separator:aea3f27002f8056b1d72b94aa2301ba5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcaaa26544a4e172541847a82995876" id="r_a9bcaaa26544a4e172541847a82995876"><td class="memTemplParams" colspan="2"><a id="a9bcaaa26544a4e172541847a82995876" name="a9bcaaa26544a4e172541847a82995876"></a>
template&lt;class ViewType, class SliceType&gt; </td></tr>
<tr class="memitem:a9bcaaa26544a4e172541847a82995876"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copyViewToSlice</b> (SliceType &amp;<a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, const ViewType &amp;view, const std::size_t begin, const std::size_t end)</td></tr>
<tr class="memdesc:a9bcaaa26544a4e172541847a82995876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from View to slice with default execution space. <br /></td></tr>
<tr class="separator:a9bcaaa26544a4e172541847a82995876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f231f2743761433164d02ce538341c" id="r_ae0f231f2743761433164d02ce538341c"><td class="memTemplParams" colspan="2"><a id="ae0f231f2743761433164d02ce538341c" name="ae0f231f2743761433164d02ce538341c"></a>
template&lt;class SliceType&gt; </td></tr>
<tr class="memitem:ae0f231f2743761433164d02ce538341c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>checkSize</b> (SliceType <a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, const std::size_t <a class="el" href="#a38373e37aa5b7d04357323bcb20b249c">size</a>, typename std::enable_if&lt; <a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value, int &gt;::type *=0)</td></tr>
<tr class="memdesc:ae0f231f2743761433164d02ce538341c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check slice size (differs from Kokkos View). <br /></td></tr>
<tr class="separator:ae0f231f2743761433164d02ce538341c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1950445268d5bdacd831883349a68456" id="r_a1950445268d5bdacd831883349a68456"><td class="memTemplParams" colspan="2"><a id="a1950445268d5bdacd831883349a68456" name="a1950445268d5bdacd831883349a68456"></a>
template&lt;class ViewType&gt; </td></tr>
<tr class="memitem:a1950445268d5bdacd831883349a68456"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>checkSize</b> (ViewType view, const std::size_t <a class="el" href="#a38373e37aa5b7d04357323bcb20b249c">size</a>, typename std::enable_if&lt; Kokkos::is_view&lt; ViewType &gt;::value, int &gt;::type *=0)</td></tr>
<tr class="memdesc:a1950445268d5bdacd831883349a68456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check View size (differs from <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>). <br /></td></tr>
<tr class="separator:a1950445268d5bdacd831883349a68456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38373e37aa5b7d04357323bcb20b249c" id="r_a38373e37aa5b7d04357323bcb20b249c"><td class="memTemplParams" colspan="2"><a id="a38373e37aa5b7d04357323bcb20b249c" name="a38373e37aa5b7d04357323bcb20b249c"></a>
template&lt;class SliceType&gt; </td></tr>
<tr class="memitem:a38373e37aa5b7d04357323bcb20b249c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>size</b> (SliceType <a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, typename std::enable_if&lt; <a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value, int &gt;::type *=0)</td></tr>
<tr class="memdesc:a38373e37aa5b7d04357323bcb20b249c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check slice size (differs from Kokkos View). <br /></td></tr>
<tr class="separator:a38373e37aa5b7d04357323bcb20b249c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d5740a31ba48910d2a247684ab669a" id="r_a84d5740a31ba48910d2a247684ab669a"><td class="memTemplParams" colspan="2"><a id="a84d5740a31ba48910d2a247684ab669a" name="a84d5740a31ba48910d2a247684ab669a"></a>
template&lt;class ViewType&gt; </td></tr>
<tr class="memitem:a84d5740a31ba48910d2a247684ab669a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>size</b> (ViewType view, typename std::enable_if&lt; Kokkos::is_view&lt; ViewType &gt;::value, int &gt;::type *=0)</td></tr>
<tr class="memdesc:a84d5740a31ba48910d2a247684ab669a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check View size (differs from <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>). <br /></td></tr>
<tr class="separator:a84d5740a31ba48910d2a247684ab669a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85294bbc93aca84a04e821c0ed46e84e" id="r_a85294bbc93aca84a04e821c0ed46e84e"><td class="memTemplParams" colspan="2"><a id="a85294bbc93aca84a04e821c0ed46e84e" name="a85294bbc93aca84a04e821c0ed46e84e"></a>
template&lt;std::size_t M, class SoA_t&gt; </td></tr>
<tr class="memitem:a85294bbc93aca84a04e821c0ed46e84e"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (SoA_t &amp;soa, const std::size_t a)</td></tr>
<tr class="memdesc:a85294bbc93aca84a04e821c0ed46e84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-0 non-const. <br /></td></tr>
<tr class="separator:a85294bbc93aca84a04e821c0ed46e84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3357c86eceab49b5c32fd8b0a8f4088f" id="r_a3357c86eceab49b5c32fd8b0a8f4088f"><td class="memTemplParams" colspan="2"><a id="a3357c86eceab49b5c32fd8b0a8f4088f" name="a3357c86eceab49b5c32fd8b0a8f4088f"></a>
template&lt;std::size_t M, class SoA_t&gt; </td></tr>
<tr class="memitem:a3357c86eceab49b5c32fd8b0a8f4088f"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const SoA_t &amp;soa, const std::size_t a)</td></tr>
<tr class="memdesc:a3357c86eceab49b5c32fd8b0a8f4088f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-0 const. <br /></td></tr>
<tr class="separator:a3357c86eceab49b5c32fd8b0a8f4088f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6d311d8e00835d1f21ccdddacd9ff5" id="r_a7f6d311d8e00835d1f21ccdddacd9ff5"><td class="memTemplParams" colspan="2"><a id="a7f6d311d8e00835d1f21ccdddacd9ff5" name="a7f6d311d8e00835d1f21ccdddacd9ff5"></a>
template&lt;std::size_t M, class SoA_t&gt; </td></tr>
<tr class="memitem:a7f6d311d8e00835d1f21ccdddacd9ff5"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (SoA_t &amp;soa, const std::size_t a, const std::size_t d0)</td></tr>
<tr class="memdesc:a7f6d311d8e00835d1f21ccdddacd9ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-1 non-const. <br /></td></tr>
<tr class="separator:a7f6d311d8e00835d1f21ccdddacd9ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65cc1ee9d46c3ae289d992aee7ac781" id="r_ab65cc1ee9d46c3ae289d992aee7ac781"><td class="memTemplParams" colspan="2"><a id="ab65cc1ee9d46c3ae289d992aee7ac781" name="ab65cc1ee9d46c3ae289d992aee7ac781"></a>
template&lt;std::size_t M, class SoA_t&gt; </td></tr>
<tr class="memitem:ab65cc1ee9d46c3ae289d992aee7ac781"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const SoA_t &amp;soa, const std::size_t a, const std::size_t d0)</td></tr>
<tr class="memdesc:ab65cc1ee9d46c3ae289d992aee7ac781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-1 const. <br /></td></tr>
<tr class="separator:ab65cc1ee9d46c3ae289d992aee7ac781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef903ab252f568a515a36f90170e6a2" id="r_aeef903ab252f568a515a36f90170e6a2"><td class="memTemplParams" colspan="2"><a id="aeef903ab252f568a515a36f90170e6a2" name="aeef903ab252f568a515a36f90170e6a2"></a>
template&lt;std::size_t M, class SoA_t&gt; </td></tr>
<tr class="memitem:aeef903ab252f568a515a36f90170e6a2"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="memdesc:aeef903ab252f568a515a36f90170e6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-2 non-const. <br /></td></tr>
<tr class="separator:aeef903ab252f568a515a36f90170e6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5c50ab1cf04c4943457f440b83a890" id="r_a0b5c50ab1cf04c4943457f440b83a890"><td class="memTemplParams" colspan="2"><a id="a0b5c50ab1cf04c4943457f440b83a890" name="a0b5c50ab1cf04c4943457f440b83a890"></a>
template&lt;std::size_t M, class SoA_t&gt; </td></tr>
<tr class="memitem:a0b5c50ab1cf04c4943457f440b83a890"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="memdesc:a0b5c50ab1cf04c4943457f440b83a890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-2 const. <br /></td></tr>
<tr class="separator:a0b5c50ab1cf04c4943457f440b83a890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ef47d136bbb461cac2ad4a9cb2d18c" id="r_a76ef47d136bbb461cac2ad4a9cb2d18c"><td class="memTemplParams" colspan="2"><a id="a76ef47d136bbb461cac2ad4a9cb2d18c" name="a76ef47d136bbb461cac2ad4a9cb2d18c"></a>
template&lt;std::size_t M, class SoA_t&gt; </td></tr>
<tr class="memitem:a76ef47d136bbb461cac2ad4a9cb2d18c"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="memdesc:a76ef47d136bbb461cac2ad4a9cb2d18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-3 non-const. <br /></td></tr>
<tr class="separator:a76ef47d136bbb461cac2ad4a9cb2d18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881c500026c8556353cc7a4130f18204" id="r_a881c500026c8556353cc7a4130f18204"><td class="memTemplParams" colspan="2"><a id="a881c500026c8556353cc7a4130f18204" name="a881c500026c8556353cc7a4130f18204"></a>
template&lt;std::size_t M, class SoA_t&gt; </td></tr>
<tr class="memitem:a881c500026c8556353cc7a4130f18204"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="memdesc:a881c500026c8556353cc7a4130f18204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-3 const. <br /></td></tr>
<tr class="separator:a881c500026c8556353cc7a4130f18204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a029626fb67b12cf279b7f3c620159" id="r_ac7a029626fb67b12cf279b7f3c620159"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType, class Comparator, class ExecutionSpace = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:ac7a029626fb67b12cf279b7f3c620159"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac7a029626fb67b12cf279b7f3c620159">sortByKeyWithComparator</a> (KeyViewType keys, Comparator comp, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ac7a029626fb67b12cf279b7f3c620159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys.  <br /></td></tr>
<tr class="separator:ac7a029626fb67b12cf279b7f3c620159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8376dcbdaa0c3dad87fe19203cf1755" id="r_ac8376dcbdaa0c3dad87fe19203cf1755"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType, class Comparator, class ExecutionSpace = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:ac8376dcbdaa0c3dad87fe19203cf1755"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac8376dcbdaa0c3dad87fe19203cf1755">sortByKeyWithComparator</a> (KeyViewType keys, Comparator comp, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ac8376dcbdaa0c3dad87fe19203cf1755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys.  <br /></td></tr>
<tr class="separator:ac8376dcbdaa0c3dad87fe19203cf1755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc22b2013d39364f39f91677a589cb8f" id="r_adc22b2013d39364f39f91677a589cb8f"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType, class Comparator, class ExecutionSpace = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:adc22b2013d39364f39f91677a589cb8f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc22b2013d39364f39f91677a589cb8f">binByKeyWithComparator</a> (KeyViewType keys, Comparator comp, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:adc22b2013d39364f39f91677a589cb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys.  <br /></td></tr>
<tr class="separator:adc22b2013d39364f39f91677a589cb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e404c2997ca696faff2f84caf97691" id="r_a70e404c2997ca696faff2f84caf97691"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType, class Comparator, class ExecutionSpace = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:a70e404c2997ca696faff2f84caf97691"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70e404c2997ca696faff2f84caf97691">binByKeyWithComparator</a> (KeyViewType keys, Comparator comp, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a70e404c2997ca696faff2f84caf97691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys.  <br /></td></tr>
<tr class="separator:a70e404c2997ca696faff2f84caf97691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c64ff984d2da99d6ff20d89a8ae9899" id="r_a5c64ff984d2da99d6ff20d89a8ae9899"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType, class ExecutionSpace = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:a5c64ff984d2da99d6ff20d89a8ae9899"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5c64ff984d2da99d6ff20d89a8ae9899">sortByKey</a> (KeyViewType keys, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a5c64ff984d2da99d6ff20d89a8ae9899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values.  <br /></td></tr>
<tr class="separator:a5c64ff984d2da99d6ff20d89a8ae9899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cfa6540c7adf84fb5d3546950c46e6" id="r_a73cfa6540c7adf84fb5d3546950c46e6"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType, class ExecutionSpace = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:a73cfa6540c7adf84fb5d3546950c46e6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73cfa6540c7adf84fb5d3546950c46e6">sortByKey</a> (KeyViewType keys, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a73cfa6540c7adf84fb5d3546950c46e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values.  <br /></td></tr>
<tr class="separator:a73cfa6540c7adf84fb5d3546950c46e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d805b955e236c9c87c50f76c4dde7c" id="r_a07d805b955e236c9c87c50f76c4dde7c"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType, class ExecutionSpace = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:a07d805b955e236c9c87c50f76c4dde7c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a07d805b955e236c9c87c50f76c4dde7c">binByKey</a> (KeyViewType keys, const int nbin, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a07d805b955e236c9c87c50f76c4dde7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values and number of bins. The bins are evenly divided over the range of key values.  <br /></td></tr>
<tr class="separator:a07d805b955e236c9c87c50f76c4dde7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefadc00186eb5240413c19ffcc11556b" id="r_aefadc00186eb5240413c19ffcc11556b"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType, class ExecutionSpace = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:aefadc00186eb5240413c19ffcc11556b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aefadc00186eb5240413c19ffcc11556b">binByKey</a> (KeyViewType keys, const int nbin, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:aefadc00186eb5240413c19ffcc11556b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values and number of bins. The bins are evenly divided over the range of key values.  <br /></td></tr>
<tr class="separator:aefadc00186eb5240413c19ffcc11556b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2577949b8aa884de4873f31efa54401b" id="r_a2577949b8aa884de4873f31efa54401b"><td class="memTemplParams" colspan="2">template&lt;class SliceType, class ExecutionSpace = typename SliceType::execution_space&gt; </td></tr>
<tr class="memitem:a2577949b8aa884de4873f31efa54401b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2577949b8aa884de4873f31efa54401b">sortByKey</a> (SliceType <a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a2577949b8aa884de4873f31efa54401b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys.  <br /></td></tr>
<tr class="separator:a2577949b8aa884de4873f31efa54401b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360b0f9c15911bfac904d240e7f369d7" id="r_a360b0f9c15911bfac904d240e7f369d7"><td class="memTemplParams" colspan="2">template&lt;class SliceType, class ExecutionSpace = typename SliceType::execution_space&gt; </td></tr>
<tr class="memitem:a360b0f9c15911bfac904d240e7f369d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a360b0f9c15911bfac904d240e7f369d7">sortByKey</a> (SliceType <a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a360b0f9c15911bfac904d240e7f369d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys.  <br /></td></tr>
<tr class="separator:a360b0f9c15911bfac904d240e7f369d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb53c51408767f5539610cab2fae20f" id="r_a0bb53c51408767f5539610cab2fae20f"><td class="memTemplParams" colspan="2">template&lt;class SliceType, class ExecutionSpace = typename SliceType::execution_space&gt; </td></tr>
<tr class="memitem:a0bb53c51408767f5539610cab2fae20f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0bb53c51408767f5539610cab2fae20f">binByKey</a> (SliceType <a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, const int nbin, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a0bb53c51408767f5539610cab2fae20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys.  <br /></td></tr>
<tr class="separator:a0bb53c51408767f5539610cab2fae20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1893b963c55a3dc6612d27999acc71b0" id="r_a1893b963c55a3dc6612d27999acc71b0"><td class="memTemplParams" colspan="2">template&lt;class SliceType, class ExecutionSpace = typename SliceType::execution_space&gt; </td></tr>
<tr class="memitem:a1893b963c55a3dc6612d27999acc71b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1893b963c55a3dc6612d27999acc71b0">binByKey</a> (SliceType <a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, const int nbin, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a1893b963c55a3dc6612d27999acc71b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys.  <br /></td></tr>
<tr class="separator:a1893b963c55a3dc6612d27999acc71b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824f296314f00ca8e121e6a26e2846db" id="r_a824f296314f00ca8e121e6a26e2846db"><td class="memTemplParams" colspan="2">template&lt;class BinningDataType, class AoSoA_t, class ExecutionSpace = typename BinningDataType::execution_space&gt; </td></tr>
<tr class="memitem:a824f296314f00ca8e121e6a26e2846db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a824f296314f00ca8e121e6a26e2846db">permute</a> (const BinningDataType &amp;binning_data, AoSoA_t &amp;aosoa, typename std::enable_if&lt;(is_binning_data&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a824f296314f00ca8e121e6a26e2846db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given binning data permute an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <br /></td></tr>
<tr class="separator:a824f296314f00ca8e121e6a26e2846db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44a65c22331c71ed7cee721a41c54fc" id="r_ab44a65c22331c71ed7cee721a41c54fc"><td class="memTemplParams" colspan="2">template&lt;class BinningDataType, class SliceType, class ExecutionSpace = typename BinningDataType::execution_space&gt; </td></tr>
<tr class="memitem:ab44a65c22331c71ed7cee721a41c54fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab44a65c22331c71ed7cee721a41c54fc">permute</a> (const BinningDataType &amp;binning_data, SliceType &amp;<a class="el" href="#aa14f30ab334c57448b204fc9b304289a">slice</a>, typename std::enable_if&lt;(is_binning_data&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ab44a65c22331c71ed7cee721a41c54fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given binning data permute a slice.  <br /></td></tr>
<tr class="separator:ab44a65c22331c71ed7cee721a41c54fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f34189fb341f3228569a06d7a259766" id="r_a7f34189fb341f3228569a06d7a259766"><td class="memTemplParams" colspan="2">template&lt;class BinningDataType, class ViewType, class MemorySpace = typename BinningDataType::memory_space&gt; </td></tr>
<tr class="memitem:a7f34189fb341f3228569a06d7a259766"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f34189fb341f3228569a06d7a259766">permute</a> (const BinningDataType &amp;binning_data, ViewType &amp;view, typename std::enable_if&lt;(is_binning_data&lt; BinningDataType &gt;::value &amp;&amp;Kokkos::is_view&lt; ViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a7f34189fb341f3228569a06d7a259766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given binning data permute a View.  <br /></td></tr>
<tr class="separator:a7f34189fb341f3228569a06d7a259766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9c5039bd9d6602e2b586eadb908623" id="r_a7e9c5039bd9d6602e2b586eadb908623"><td class="memTemplParams" colspan="2"><a id="a7e9c5039bd9d6602e2b586eadb908623" name="a7e9c5039bd9d6602e2b586eadb908623"></a>
template&lt;std::size_t M, class Tuple_t&gt; </td></tr>
<tr class="memitem:a7e9c5039bd9d6602e2b586eadb908623"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typenameTuple_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (Tuple_t &amp;tp)</td></tr>
<tr class="memdesc:a7e9c5039bd9d6602e2b586eadb908623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-0 non-const. <br /></td></tr>
<tr class="separator:a7e9c5039bd9d6602e2b586eadb908623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a6d3bbad24474f5761de911322cbc4" id="r_ad0a6d3bbad24474f5761de911322cbc4"><td class="memTemplParams" colspan="2"><a id="ad0a6d3bbad24474f5761de911322cbc4" name="ad0a6d3bbad24474f5761de911322cbc4"></a>
template&lt;std::size_t M, class Tuple_t&gt; </td></tr>
<tr class="memitem:ad0a6d3bbad24474f5761de911322cbc4"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION Tuple_t::template member_const_reference_type&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const Tuple_t &amp;tp)</td></tr>
<tr class="memdesc:ad0a6d3bbad24474f5761de911322cbc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-0 const. <br /></td></tr>
<tr class="separator:ad0a6d3bbad24474f5761de911322cbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d016aef05b4da27fc6c3275eb14a75" id="r_a33d016aef05b4da27fc6c3275eb14a75"><td class="memTemplParams" colspan="2"><a id="a33d016aef05b4da27fc6c3275eb14a75" name="a33d016aef05b4da27fc6c3275eb14a75"></a>
template&lt;std::size_t M, class Tuple_t&gt; </td></tr>
<tr class="memitem:a33d016aef05b4da27fc6c3275eb14a75"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typenameTuple_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (Tuple_t &amp;tp, const std::size_t d0)</td></tr>
<tr class="memdesc:a33d016aef05b4da27fc6c3275eb14a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-1 non-const. <br /></td></tr>
<tr class="separator:a33d016aef05b4da27fc6c3275eb14a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd3fb43c2f7c126d5694273fc5743fc" id="r_a6fd3fb43c2f7c126d5694273fc5743fc"><td class="memTemplParams" colspan="2"><a id="a6fd3fb43c2f7c126d5694273fc5743fc" name="a6fd3fb43c2f7c126d5694273fc5743fc"></a>
template&lt;std::size_t M, class Tuple_t&gt; </td></tr>
<tr class="memitem:a6fd3fb43c2f7c126d5694273fc5743fc"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typenameTuple_t::templatemember_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const Tuple_t &amp;tp, const std::size_t d0)</td></tr>
<tr class="memdesc:a6fd3fb43c2f7c126d5694273fc5743fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-1 const. <br /></td></tr>
<tr class="separator:a6fd3fb43c2f7c126d5694273fc5743fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf89383ed7ae249eb730aebc572b28b1" id="r_abf89383ed7ae249eb730aebc572b28b1"><td class="memTemplParams" colspan="2"><a id="abf89383ed7ae249eb730aebc572b28b1" name="abf89383ed7ae249eb730aebc572b28b1"></a>
template&lt;std::size_t M, class Tuple_t&gt; </td></tr>
<tr class="memitem:abf89383ed7ae249eb730aebc572b28b1"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typenameTuple_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="memdesc:abf89383ed7ae249eb730aebc572b28b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-2 non-const. <br /></td></tr>
<tr class="separator:abf89383ed7ae249eb730aebc572b28b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45a73b3aba7da567fd0a1e50337c45a" id="r_aa45a73b3aba7da567fd0a1e50337c45a"><td class="memTemplParams" colspan="2"><a id="aa45a73b3aba7da567fd0a1e50337c45a" name="aa45a73b3aba7da567fd0a1e50337c45a"></a>
template&lt;std::size_t M, class Tuple_t&gt; </td></tr>
<tr class="memitem:aa45a73b3aba7da567fd0a1e50337c45a"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typenameTuple_t::templatemember_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="memdesc:aa45a73b3aba7da567fd0a1e50337c45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-2 const. <br /></td></tr>
<tr class="separator:aa45a73b3aba7da567fd0a1e50337c45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05881b3162977f27382ec15f3b4cfd89" id="r_a05881b3162977f27382ec15f3b4cfd89"><td class="memTemplParams" colspan="2"><a id="a05881b3162977f27382ec15f3b4cfd89" name="a05881b3162977f27382ec15f3b4cfd89"></a>
template&lt;std::size_t M, class Tuple_t&gt; </td></tr>
<tr class="memitem:a05881b3162977f27382ec15f3b4cfd89"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typenameTuple_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="memdesc:a05881b3162977f27382ec15f3b4cfd89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-3 non-const. <br /></td></tr>
<tr class="separator:a05881b3162977f27382ec15f3b4cfd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92e62b3f67a0e4deeb5aff8dcdcfae2" id="r_aa92e62b3f67a0e4deeb5aff8dcdcfae2"><td class="memTemplParams" colspan="2"><a id="aa92e62b3f67a0e4deeb5aff8dcdcfae2" name="aa92e62b3f67a0e4deeb5aff8dcdcfae2"></a>
template&lt;std::size_t M, class Tuple_t&gt; </td></tr>
<tr class="memitem:aa92e62b3f67a0e4deeb5aff8dcdcfae2"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typenameTuple_t::templatemember_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="memdesc:aa92e62b3f67a0e4deeb5aff8dcdcfae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-3 const. <br /></td></tr>
<tr class="separator:aa92e62b3f67a0e4deeb5aff8dcdcfae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc852ea757997c2582c2caf89f4637b" id="r_a4dc852ea757997c2582c2caf89f4637b"><td class="memTemplParams" colspan="2"><a id="a4dc852ea757997c2582c2caf89f4637b" name="a4dc852ea757997c2582c2caf89f4637b"></a>
template&lt;class Scalar, std::size_t Dim&gt; </td></tr>
<tr class="memitem:a4dc852ea757997c2582c2caf89f4637b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copyArray</b> (const std::array&lt; Scalar, Dim &gt; input)</td></tr>
<tr class="memdesc:a4dc852ea757997c2582c2caf89f4637b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy std::array into Kokkos::Array for potential device use. <br /></td></tr>
<tr class="separator:a4dc852ea757997c2582c2caf89f4637b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41e2cfc71aa5fa140bc2332eb8a3a3e" id="r_af41e2cfc71aa5fa140bc2332eb8a3a3e"><td class="memTemplParams" colspan="2"><a id="af41e2cfc71aa5fa140bc2332eb8a3a3e" name="af41e2cfc71aa5fa140bc2332eb8a3a3e"></a>
template&lt;class Scalar, std::size_t Dim&gt; </td></tr>
<tr class="memitem:af41e2cfc71aa5fa140bc2332eb8a3a3e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copyArray</b> (const Kokkos::Array&lt; Scalar, Dim &gt; input)</td></tr>
<tr class="memdesc:af41e2cfc71aa5fa140bc2332eb8a3a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return original Kokkos::Array. <br /></td></tr>
<tr class="separator:af41e2cfc71aa5fa140bc2332eb8a3a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bd5a37b87ce24337e38aa05b1282ee" id="r_a62bd5a37b87ce24337e38aa05b1282ee"><td class="memTemplParams" colspan="2"><a id="a62bd5a37b87ce24337e38aa05b1282ee" name="a62bd5a37b87ce24337e38aa05b1282ee"></a>
template&lt;class Scalar, std::size_t Dim&gt; </td></tr>
<tr class="memitem:a62bd5a37b87ce24337e38aa05b1282ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copyArray</b> (const Scalar input[Dim])</td></tr>
<tr class="memdesc:a62bd5a37b87ce24337e38aa05b1282ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy c-array into Kokkos::Array for potential device use. <br /></td></tr>
<tr class="separator:a62bd5a37b87ce24337e38aa05b1282ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cbe49a5251c106c2997074fc038a52" id="r_ae6cbe49a5251c106c2997074fc038a52"><td class="memTemplParams" colspan="2">template&lt;class AlgorithmTag, class LayoutTag, class BuildTag, class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, std::size_t NumSpaceDim, class... Args&gt; </td></tr>
<tr class="memitem:ae6cbe49a5251c106c2997074fc038a52"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae6cbe49a5251c106c2997074fc038a52">createVerletList</a> (PositionType positions, const std::size_t begin, const std::size_t end, const typename PositionType::value_type radius, const typename PositionType::value_type cell_size_ratio, const ArrayType&lt; typename PositionType::value_type, NumSpaceDim &gt; grid_min, const ArrayType&lt; typename PositionType::value_type, NumSpaceDim &gt; grid_max, const std::size_t max_neigh=0)</td></tr>
<tr class="memdesc:ae6cbe49a5251c106c2997074fc038a52"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a Cartesian grid with cells of the same si...">VerletList</a> constructor. Given a list of particle positions and a neighborhood radius calculate the neighbor list.  <br /></td></tr>
<tr class="separator:ae6cbe49a5251c106c2997074fc038a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad841c0a4b3133a6487cfbf38fcb957a7" id="r_ad841c0a4b3133a6487cfbf38fcb957a7"><td class="memTemplParams" colspan="2">template&lt;class AlgorithmTag, class LayoutTag, class BuildTag, class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, std::size_t NumSpaceDim, class... Args&gt; </td></tr>
<tr class="memitem:ad841c0a4b3133a6487cfbf38fcb957a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad841c0a4b3133a6487cfbf38fcb957a7">createVerletList</a> (const PositionType &amp;positions, const typename PositionType::value_type radius, const typename PositionType::value_type cell_size_ratio, const ArrayType&lt; typename PositionType::value_type, NumSpaceDim &gt; grid_min, const ArrayType&lt; typename PositionType::value_type, NumSpaceDim &gt; grid_max, const std::size_t max_neigh=0)</td></tr>
<tr class="memdesc:ad841c0a4b3133a6487cfbf38fcb957a7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a Cartesian grid with cells of the same si...">VerletList</a> constructor. Given a list of particle positions and a neighborhood radius calculate the neighbor list.  <br /></td></tr>
<tr class="separator:ad841c0a4b3133a6487cfbf38fcb957a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f45805f16a42f9f6f048d2e88cd940" id="r_a94f45805f16a42f9f6f048d2e88cd940"><td class="memItemLeft" align="right" valign="top"><a id="a94f45805f16a42f9f6f048d2e88cd940" name="a94f45805f16a42f9f6f048d2e88cd940"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>version</b> ()</td></tr>
<tr class="memdesc:a94f45805f16a42f9f6f048d2e88cd940"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> version. <br /></td></tr>
<tr class="separator:a94f45805f16a42f9f6f048d2e88cd940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad181bcaca8bec0b53a05927aff3120" id="r_afad181bcaca8bec0b53a05927aff3120"><td class="memItemLeft" align="right" valign="top"><a id="afad181bcaca8bec0b53a05927aff3120" name="afad181bcaca8bec0b53a05927aff3120"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>git_commit_hash</b> ()</td></tr>
<tr class="memdesc:afad181bcaca8bec0b53a05927aff3120"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> git hash. <br /></td></tr>
<tr class="separator:afad181bcaca8bec0b53a05927aff3120"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Core: particle data structures and algorithms. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a07d805b955e236c9c87c50f76c4dde7c" name="a07d805b955e236c9c87c50f76c4dde7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d805b955e236c9c87c50f76c4dde7c">&#9670;&#160;</a></span>binByKey() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType, class ExecutionSpace = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>nbin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values and number of bins. The bins are evenly divided over the range of key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins. </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin. </td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="aefadc00186eb5240413c19ffcc11556b" name="aefadc00186eb5240413c19ffcc11556b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefadc00186eb5240413c19ffcc11556b">&#9670;&#160;</a></span>binByKey() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType, class ExecutionSpace = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>nbin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values and number of bins. The bins are evenly divided over the range of key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="a0bb53c51408767f5539610cab2fae20f" name="a0bb53c51408767f5539610cab2fae20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb53c51408767f5539610cab2fae20f">&#9670;&#160;</a></span>binByKey() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType, class ExecutionSpace = typename SliceType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>nbin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys. </td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins. </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin. </td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="a1893b963c55a3dc6612d27999acc71b0" name="a1893b963c55a3dc6612d27999acc71b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1893b963c55a3dc6612d27999acc71b0">&#9670;&#160;</a></span>binByKey() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType, class ExecutionSpace = typename SliceType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>nbin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys. </td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="adc22b2013d39364f39f91677a589cb8f" name="adc22b2013d39364f39f91677a589cb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc22b2013d39364f39f91677a589cb8f">&#9670;&#160;</a></span>binByKeyWithComparator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType, class Comparator, class ExecutionSpace = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::binByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys. </td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for binning. Must be compatible with Kokkos::BinSort. </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin. </td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="a70e404c2997ca696faff2f84caf97691" name="a70e404c2997ca696faff2f84caf97691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e404c2997ca696faff2f84caf97691">&#9670;&#160;</a></span>binByKeyWithComparator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType, class Comparator, class ExecutionSpace = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::binByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for binning. Must be compatible with Kokkos::BinSort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="a844802648f5a8db82851ba8e4672cea5" name="a844802648f5a8db82851ba8e4672cea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844802648f5a8db82851ba8e4672cea5">&#9670;&#160;</a></span>create_mirror()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space, class SrcAoSoA&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt; Cabana::create_mirror </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;(!std::is_same_v&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;)&gt; *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a mirror of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given space. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the new space. </dd></dl>

</div>
</div>
<a id="aa0a51f1811816037b2e53adf7a3e1b37" name="aa0a51f1811816037b2e53adf7a3e1b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a51f1811816037b2e53adf7a3e1b37">&#9670;&#160;</a></span>create_mirror_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space, class SrcAoSoA&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SrcAoSoA Cabana::create_mirror_view </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;(std::is_same_v&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;)&gt; *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given space. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="af5ab274abf8942a7404be03338b0cf68" name="af5ab274abf8942a7404be03338b0cf68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ab274abf8942a7404be03338b0cf68">&#9670;&#160;</a></span>create_mirror_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space, class SrcAoSoA&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt; Cabana::create_mirror_view </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;</td>          <td class="paramname"><span class="paramname"><em>space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;(!std::is_same_v&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;)&gt; *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the new space.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="a892811b71917ebd71b3608ef3978b76d" name="a892811b71917ebd71b3608ef3978b76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892811b71917ebd71b3608ef3978b76d">&#9670;&#160;</a></span>create_mirror_view_and_copy() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space, class SrcAoSoA&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SrcAoSoA Cabana::create_mirror_view_and_copy </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;(std::is_same_v&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt; &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt; *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and copy the contents of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="aa22f44dbf5e03ccb62f338436dac5e57" name="aa22f44dbf5e03ccb62f338436dac5e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22f44dbf5e03ccb62f338436dac5e57">&#9670;&#160;</a></span>create_mirror_view_and_copy() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space, class SrcAoSoA&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt; Cabana::create_mirror_view_and_copy </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;</td>          <td class="paramname"><span class="paramname"><em>space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;(!std::is_same_v&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt; &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt; *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and deep copy the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> into the mirror. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> and performs the deep copy. </p>
<dl class="section return"><dt>Returns</dt><dd>The new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="a79ce54b97e3aa320e6108b0e978e1df0" name="a79ce54b97e3aa320e6108b0e978e1df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ce54b97e3aa320e6108b0e978e1df0">&#9670;&#160;</a></span>create_mirror_view_and_copy() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DstMemorySpace, class SrcMemorySpace, int VectorLength, class... FieldTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::create_mirror_view_and_copy </td>
          <td>(</td>
          <td class="paramtype">DstMemorySpace</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; SrcMemorySpace, VectorLength, FieldTags... &gt;</td>          <td class="paramname"><span class="paramname"><em>plist_src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_same_v&lt; SrcMemorySpace, DstMemorySpace &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mirror of the given <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> in the given memory space. </p>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> is returned. </dd></dl>

</div>
</div>
<a id="a139eac1fa0c2578743ed90b3bee42bd0" name="a139eac1fa0c2578743ed90b3bee42bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139eac1fa0c2578743ed90b3bee42bd0">&#9670;&#160;</a></span>create_mirror_view_and_copy() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DstMemorySpace, class SrcMemorySpace, int VectorLength, class... FieldTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::create_mirror_view_and_copy </td>
          <td>(</td>
          <td class="paramtype">DstMemorySpace</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; SrcMemorySpace, VectorLength, FieldTags... &gt;</td>          <td class="paramname"><span class="paramname"><em>plist_src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;!std::is_same_v&lt; SrcMemorySpace, DstMemorySpace &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mirror of the given <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> in the given memory space. </p>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> is returned. </dd></dl>

</div>
</div>
<a id="acfe4862a55c2c1e611de4447db7cbedb" name="acfe4862a55c2c1e611de4447db7cbedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe4862a55c2c1e611de4447db7cbedb">&#9670;&#160;</a></span>createGather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HaloType, class ParticleDataType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createGather </td>
          <td>(</td>
          <td class="paramtype">const HaloType &amp;</td>          <td class="paramname"><span class="paramname"><em>halo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParticleDataType &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>overallocation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the gather. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo to use for the gather. </td></tr>
    <tr><td class="paramname">data</td><td>The data on which to perform the gather. The slice should have a size equivalent to halo.numGhost() + halo.numLocal(). The locally owned elements are expected to appear first (i.e. in the first halo.numLocal() elements) and the ghosted elements are expected to appear second (i.e. in the next halo.numGhost() elements()). </td></tr>
    <tr><td class="paramname">overallocation</td><td>An optional factor to keep extra space in the buffers to avoid frequent resizing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1Gather.html">Gather</a> </dd></dl>

</div>
</div>
<a id="a9e383a5f93e7ff1d54b1071c9e18feb4" name="a9e383a5f93e7ff1d54b1071c9e18feb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e383a5f93e7ff1d54b1071c9e18feb4">&#9670;&#160;</a></span>createLinkedCellList() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args, class Scalar, std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createLinkedCellList </td>
          <td>(</td>
          <td class="paramtype">PositionType</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for linked cell list. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1LinkedCellList.html" title="Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesia...">LinkedCellList</a>. </dd></dl>

</div>
</div>
<a id="a38a362466441bacacbf3d43ff5af57d4" name="a38a362466441bacacbf3d43ff5af57d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a362466441bacacbf3d43ff5af57d4">&#9670;&#160;</a></span>createLinkedCellList() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args, class Scalar, std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createLinkedCellList </td>
          <td>(</td>
          <td class="paramtype">PositionType</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>neighborhood_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>cell_size_ratio</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for linked cell list with custom cutoff radius and cell ratio. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1LinkedCellList.html" title="Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesia...">LinkedCellList</a>. </dd></dl>

</div>
</div>
<a id="a40cb83164537db1ef13f82b3402134bb" name="a40cb83164537db1ef13f82b3402134bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cb83164537db1ef13f82b3402134bb">&#9670;&#160;</a></span>createLinkedCellList() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args, class Scalar, std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createLinkedCellList </td>
          <td>(</td>
          <td class="paramtype">PositionType</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for linked cell list with partial range. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1LinkedCellList.html" title="Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesia...">LinkedCellList</a>. </dd></dl>

</div>
</div>
<a id="a8c63d0a9605d8034581758d74902a9d6" name="a8c63d0a9605d8034581758d74902a9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c63d0a9605d8034581758d74902a9d6">&#9670;&#160;</a></span>createLinkedCellList() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args, class Scalar, std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createLinkedCellList </td>
          <td>(</td>
          <td class="paramtype">PositionType</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>neighborhood_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>cell_size_ratio</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for linked cell list with partial range and custom cutoff radius and/or cell ratio. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1LinkedCellList.html" title="Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesia...">LinkedCellList</a>. </dd></dl>

</div>
</div>
<a id="a0ea42084be73f3ef96b5003ead86775c" name="a0ea42084be73f3ef96b5003ead86775c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea42084be73f3ef96b5003ead86775c">&#9670;&#160;</a></span>createLinkedCellList() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createLinkedCellList </td>
          <td>(</td>
          <td class="paramtype">PositionType</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>grid_delta</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>[3]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for linked cell list with partial range. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1LinkedCellList.html" title="Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesia...">LinkedCellList</a>. </dd></dl>

</div>
</div>
<a id="a9803c3cb15899b5e673d57c166b50329" name="a9803c3cb15899b5e673d57c166b50329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9803c3cb15899b5e673d57c166b50329">&#9670;&#160;</a></span>createLinkedCellList() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createLinkedCellList </td>
          <td>(</td>
          <td class="paramtype">PositionType</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>grid_delta</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>neighborhood_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>cell_size_ratio</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for linked cell list with partial range and custom cutoff radius and/or cell ratio. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1LinkedCellList.html" title="Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesia...">LinkedCellList</a>. </dd></dl>

</div>
</div>
<a id="afcbab298f727489057132f718552892c" name="afcbab298f727489057132f718552892c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbab298f727489057132f718552892c">&#9670;&#160;</a></span>createLinkedCellList() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createLinkedCellList </td>
          <td>(</td>
          <td class="paramtype">PositionType</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>grid_delta</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>[3]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for linked cell list. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1LinkedCellList.html" title="Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesia...">LinkedCellList</a>. </dd></dl>

</div>
</div>
<a id="a4fa9b63a296c89bc6ba8fa2fa8f39883" name="a4fa9b63a296c89bc6ba8fa2fa8f39883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa9b63a296c89bc6ba8fa2fa8f39883">&#9670;&#160;</a></span>createLinkedCellList() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createLinkedCellList </td>
          <td>(</td>
          <td class="paramtype">PositionType</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>grid_delta</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>neighborhood_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>cell_size_ratio</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for linked cell list with custom cutoff radius and cell ratio. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1LinkedCellList.html" title="Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesia...">LinkedCellList</a>. </dd></dl>

</div>
</div>
<a id="a17482f78ec93101044be7fc5747e9f72" name="a17482f78ec93101044be7fc5747e9f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17482f78ec93101044be7fc5747e9f72">&#9670;&#160;</a></span>createParticleList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace, int VectorLength, class... FieldTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createParticleList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCabana_1_1ParticleTraits.html">ParticleTraits</a>&lt; FieldTags... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> creation function. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> </dd></dl>

</div>
</div>
<a id="accbf302d54f1080dc3fbb2fe74f69bdb" name="accbf302d54f1080dc3fbb2fe74f69bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbf302d54f1080dc3fbb2fe74f69bdb">&#9670;&#160;</a></span>createParticleList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace, class... FieldTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createParticleList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCabana_1_1ParticleTraits.html">ParticleTraits</a>&lt; FieldTags... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> creation function with default vector length. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> </dd></dl>

</div>
</div>
<a id="a583b9b91774baa84b4cf9c7329f5e060" name="a583b9b91774baa84b4cf9c7329f5e060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583b9b91774baa84b4cf9c7329f5e060">&#9670;&#160;</a></span>createParticles() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InitFunctor, class ParticleListType, template&lt; class, std::size_t, class... &gt; class ArrayType, class Scalar, std::size_t NumSpaceDim, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InitFunctor &amp;</td>          <td class="paramname"><span class="paramname"><em>create_functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleListType &amp;</td>          <td class="paramname"><span class="paramname"><em>particle_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_particles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>box_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>box_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>previous_num_particles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>shrink_to_fit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">342343901</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles given an initialization functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">create_functor</td><td>A functor which populates a particle given the logical position of a particle. This functor returns true if a particle was created and false if it was not giving the signature: <pre class="fragment">bool createFunctor( const double pid, const double px[d], const double pv,
                    typename ParticleAoSoA::tuple_type&amp; particle );
</pre> </td></tr>
    <tr><td class="paramname">particle_list</td><td>The <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> to populate. This will be filled with particles and resized to a size equal to the number of particles created. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">box_min</td><td>Array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>Array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">shrink_to_fit</td><td>Optionally remove unused allocated space after creation. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of particles created. </dd></dl>

</div>
</div>
<a id="a2e0f00a2e33a94fb0968b984f8ad98f4" name="a2e0f00a2e33a94fb0968b984f8ad98f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0f00a2e33a94fb0968b984f8ad98f4">&#9670;&#160;</a></span>createParticles() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InitFunctor, class ParticleListType, class PositionTag, template&lt; class, std::size_t, class... &gt; class ArrayType, class Scalar, std::size_t NumSpaceDim, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InitFunctor &amp;</td>          <td class="paramname"><span class="paramname"><em>create_functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleListType &amp;</td>          <td class="paramname"><span class="paramname"><em>particle_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionTag</td>          <td class="paramname"><span class="paramname"><em>position_tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_particles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>min_dist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>box_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>box_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>previous_num_particles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>shrink_to_fit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">342343901</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles with minimum separation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">create_functor</td><td>A functor which populates a particle given the logical position of a particle. This functor returns true if a particle was created and false if it was not giving the signature: <pre class="fragment">bool createFunctor( const double pid, const double px[d], const double pv,
                    typename ParticleAoSoA::tuple_type&amp; particle );
</pre> </td></tr>
    <tr><td class="paramname">particle_list</td><td>The <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> to populate. This will be filled with particles and resized to a size equal to the number of particles created. </td></tr>
    <tr><td class="paramname">position_tag</td><td>Position particle list type tag. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">min_dist</td><td>Minimum separation distance between particles. Potential particles created within this distance of an existing particle are rejected. </td></tr>
    <tr><td class="paramname">box_min</td><td>Array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>Array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">shrink_to_fit</td><td>Optionally remove unused allocated space after creation. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of particles created.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This approximates many physical scenarios, e.g. atomic simulations. </dd></dl>

</div>
</div>
<a id="ac1a2dac93a3ad6a0f7b4c18505034a4e" name="ac1a2dac93a3ad6a0f7b4c18505034a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a2dac93a3ad6a0f7b4c18505034a4e">&#9670;&#160;</a></span>createParticles() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace, class InitFunctor, class ParticleListType, class PositionTag, template&lt; class, std::size_t, class... &gt; class ArrayType, class Scalar, std::size_t NumSpaceDim, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionSpace</td>          <td class="paramname"><span class="paramname"><em>exec_space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InitFunctor &amp;</td>          <td class="paramname"><span class="paramname"><em>create_functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleListType &amp;</td>          <td class="paramname"><span class="paramname"><em>particle_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionTag</td>          <td class="paramname"><span class="paramname"><em>position_tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_particles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>min_dist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>box_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>box_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>previous_num_particles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>shrink_to_fit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">342343901</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structCabana_1_1is__particle__list.html">is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles with minimum separation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">create_functor</td><td>A functor which populates a particle given the logical position of a particle. This functor returns true if a particle was created and false if it was not giving the signature: <pre class="fragment">bool createFunctor( const double pid, const double px[d], const double pv,
                    typename ParticleAoSoA::tuple_type&amp; particle );
</pre> </td></tr>
    <tr><td class="paramname">particle_list</td><td>The <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> to populate. This will be filled with particles and resized to a size equal to the number of particles created. </td></tr>
    <tr><td class="paramname">position_tag</td><td>Position particle list type tag. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">min_dist</td><td>Minimum separation distance between particles. Potential particles created within this distance of an existing particle are rejected. </td></tr>
    <tr><td class="paramname">box_min</td><td>Array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>Array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">shrink_to_fit</td><td>Optionally remove unused allocated space after creation. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of particles created.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This approximates many physical scenarios, e.g. atomic simulations. </dd></dl>

</div>
</div>
<a id="a5e671252eada8128208cd1d430462bcc" name="a5e671252eada8128208cd1d430462bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e671252eada8128208cd1d430462bcc">&#9670;&#160;</a></span>createParticles() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace, class PositionType, class Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionSpace</td>          <td class="paramname"><span class="paramname"><em>exec_space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionType &amp;</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_particles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>min_dist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar</td>          <td class="paramname"><span class="paramname"><em>box_min</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar</td>          <td class="paramname"><span class="paramname"><em>box_max</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>previous_num_particles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">342343901</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">positions</td><td><a class="el" href="structCabana_1_1Particle.html" title="Single particle copy. Wraps a tuple copy of a particle.">Particle</a> positions slice. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">min_dist</td><td>Minimum separation distance between particles. Potential particles created within this distance of an existing particle are rejected. </td></tr>
    <tr><td class="paramname">box_min</td><td>C-array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>C-array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd5f1181821db2d1c60f2f781421e243" name="acd5f1181821db2d1c60f2f781421e243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5f1181821db2d1c60f2f781421e243">&#9670;&#160;</a></span>createParticles() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace, class PositionType, class Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionSpace</td>          <td class="paramname"><span class="paramname"><em>exec_space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionType &amp;</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_particles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar</td>          <td class="paramname"><span class="paramname"><em>box_min</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar</td>          <td class="paramname"><span class="paramname"><em>box_max</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>previous_num_particles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">342343901</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">positions</td><td><a class="el" href="structCabana_1_1Particle.html" title="Single particle copy. Wraps a tuple copy of a particle.">Particle</a> positions slice. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">box_min</td><td>Array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>Array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf29cebb06e9ef6549b88f8cd5203c8b" name="abf29cebb06e9ef6549b88f8cd5203c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf29cebb06e9ef6549b88f8cd5203c8b">&#9670;&#160;</a></span>createParticles() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class Scalar, std::size_t NumSpaceDim, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionType &amp;</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_particles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>box_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>box_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>previous_num_particles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">342343901</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">positions</td><td><a class="el" href="structCabana_1_1Particle.html" title="Single particle copy. Wraps a tuple copy of a particle.">Particle</a> positions slice. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">box_min</td><td>Array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>Array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae63c282b6c8bb6ed977e9a627fe2ee35" name="ae63c282b6c8bb6ed977e9a627fe2ee35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63c282b6c8bb6ed977e9a627fe2ee35">&#9670;&#160;</a></span>createParticles() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType, class Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionType &amp;</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_particles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>min_dist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar</td>          <td class="paramname"><span class="paramname"><em>box_min</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar</td>          <td class="paramname"><span class="paramname"><em>box_max</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>previous_num_particles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">342343901</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">positions</td><td><a class="el" href="structCabana_1_1Particle.html" title="Single particle copy. Wraps a tuple copy of a particle.">Particle</a> positions slice. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">min_dist</td><td>Minimum separation distance between particles. Potential particles created within this distance of an existing particle are rejected. </td></tr>
    <tr><td class="paramname">box_min</td><td>C-array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>C-array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78d34d4150b74a2f908736ef2556d77d" name="a78d34d4150b74a2f908736ef2556d77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d34d4150b74a2f908736ef2556d77d">&#9670;&#160;</a></span>createParticles() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType, class Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionType &amp;</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_particles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar</td>          <td class="paramname"><span class="paramname"><em>box_min</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar</td>          <td class="paramname"><span class="paramname"><em>box_max</em></span>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>previous_num_particles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">342343901</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">positions</td><td><a class="el" href="structCabana_1_1Particle.html" title="Single particle copy. Wraps a tuple copy of a particle.">Particle</a> positions slice. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">box_min</td><td>C-array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>C-array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b2671b1bc9dec4a8b1359bedde822d6" name="a9b2671b1bc9dec4a8b1359bedde822d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2671b1bc9dec4a8b1359bedde822d6">&#9670;&#160;</a></span>createParticles() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace, class InitFunctor, class ParticleListType, template&lt; class, std::size_t, class... &gt; class ArrayType, class Scalar, std::size_t NumSpaceDim, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionSpace</td>          <td class="paramname"><span class="paramname"><em>exec_space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InitFunctor &amp;</td>          <td class="paramname"><span class="paramname"><em>create_functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleListType &amp;</td>          <td class="paramname"><span class="paramname"><em>particle_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_particles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>box_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>box_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>previous_num_particles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>shrink_to_fit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">342343901</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structCabana_1_1is__particle__list.html">is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles given an initialization functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">create_functor</td><td>A functor which populates a particle given the logical position of a particle. This functor returns true if a particle was created and false if it was not giving the signature: <pre class="fragment">bool createFunctor( const double pid, const double px[d], const double pv,
                    typename ParticleAoSoA::tuple_type&amp; particle );
</pre> </td></tr>
    <tr><td class="paramname">particle_list</td><td>The <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> to populate. This will be filled with particles and resized to a size equal to the number of particles created. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">box_min</td><td>Array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>Array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">shrink_to_fit</td><td>Optionally remove unused allocated space after creation. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of particles created. </dd></dl>

</div>
</div>
<a id="ae30d1ef7fbc683accab91198f9f4fc9b" name="ae30d1ef7fbc683accab91198f9f4fc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30d1ef7fbc683accab91198f9f4fc9b">&#9670;&#160;</a></span>createParticles() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace, class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class Scalar, std::size_t NumSpaceDim, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionSpace</td>          <td class="paramname"><span class="paramname"><em>exec_space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionType &amp;</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_particles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>box_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; Scalar, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>box_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>previous_num_particles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">342343901</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">positions</td><td><a class="el" href="structCabana_1_1Particle.html" title="Single particle copy. Wraps a tuple copy of a particle.">Particle</a> positions slice. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">box_min</td><td>Array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>Array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc228ac6b568dd1c43f84dee0093b3fd" name="abc228ac6b568dd1c43f84dee0093b3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc228ac6b568dd1c43f84dee0093b3fd">&#9670;&#160;</a></span>createScatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HaloType, class SliceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createScatter </td>
          <td>(</td>
          <td class="paramtype">const HaloType &amp;</td>          <td class="paramname"><span class="paramname"><em>halo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SliceType &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>overallocation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; HaloType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the scatter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo to use for the scatter. </td></tr>
    <tr><td class="paramname">slice</td><td>The slice on which to perform the scatter. The slice should have a size equivalent to halo.numGhost() + halo.numLocal(). The locally owned elements are expected to appear first (i.e. in the first halo.numLocal() elements) and the ghosted elements are expected to appear second (i.e. in the next halo.numGhost() elements()). </td></tr>
    <tr><td class="paramname">overallocation</td><td>An optional factor to keep extra space in the buffers to avoid frequent resizing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1Scatter.html" title="Synchronously scatter data from the ghosts to the local decomposition of a slice using the halo rever...">Scatter</a> </dd></dl>

</div>
</div>
<a id="ad841c0a4b3133a6487cfbf38fcb957a7" name="ad841c0a4b3133a6487cfbf38fcb957a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad841c0a4b3133a6487cfbf38fcb957a7">&#9670;&#160;</a></span>createVerletList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AlgorithmTag, class LayoutTag, class BuildTag, class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, std::size_t NumSpaceDim, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createVerletList </td>
          <td>(</td>
          <td class="paramtype">const PositionType &amp;</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>cell_size_ratio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_neigh</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a Cartesian grid with cells of the same si...">VerletList</a> constructor. Given a list of particle positions and a neighborhood radius calculate the neighbor list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positions</td><td>The particle positions </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the neighborhood. Particles within this radius are considered neighbors. This is effectively the grid cell size in each dimension. </td></tr>
    <tr><td class="paramname">cell_size_ratio</td><td>The ratio of the cell size in the Cartesian grid to the neighborhood radius. For example, if the cell size ratio is 0.5 then the cells will be half the size of the neighborhood radius in each dimension. </td></tr>
    <tr><td class="paramname">grid_min</td><td>The minimum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">grid_max</td><td>The maximum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">max_neigh</td><td>Optional maximum number of neighbors per particle to pre-allocate the neighbor list. Potentially avoids recounting with 2D layout only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6cbe49a5251c106c2997074fc038a52" name="ae6cbe49a5251c106c2997074fc038a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cbe49a5251c106c2997074fc038a52">&#9670;&#160;</a></span>createVerletList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AlgorithmTag, class LayoutTag, class BuildTag, class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, std::size_t NumSpaceDim, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createVerletList </td>
          <td>(</td>
          <td class="paramtype">PositionType</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>cell_size_ratio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, NumSpaceDim &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_neigh</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a Cartesian grid with cells of the same si...">VerletList</a> constructor. Given a list of particle positions and a neighborhood radius calculate the neighbor list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positions</td><td>The particle positions </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning particle index to compute neighbors for. </td></tr>
    <tr><td class="paramname">end</td><td>The end particle index to compute neighbors for. </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the neighborhood. Particles within this radius are considered neighbors. This is effectively the grid cell size in each dimension. </td></tr>
    <tr><td class="paramname">cell_size_ratio</td><td>The ratio of the cell size in the Cartesian grid to the neighborhood radius. For example, if the cell size ratio is 0.5 then the cells will be half the size of the neighborhood radius in each dimension. </td></tr>
    <tr><td class="paramname">grid_min</td><td>The minimum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">grid_max</td><td>The maximum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">max_neigh</td><td>Optional maximum number of neighbors per particle to pre-allocate the neighbor list. Potentially avoids recounting with 2D layout only.</td></tr>
  </table>
  </dd>
</dl>
<p>Particles outside of the neighborhood radius will not be considered neighbors. Only compute the neighbors of those that are within the given range. All particles are candidates for being a neighbor, regardless of whether or not they are in the range. </p>

</div>
</div>
<a id="a0f82fe027dec446d5ff114b36e2a30be" name="a0f82fe027dec446d5ff114b36e2a30be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f82fe027dec446d5ff114b36e2a30be">&#9670;&#160;</a></span>deep_copy() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AoSoA_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">AoSoA_t &amp;</td>          <td class="paramname"><span class="paramname"><em>aosoa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AoSoA_t::tuple_type &amp;</td>          <td class="paramname"><span class="paramname"><em>tuple</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> with a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to fill. </td></tr>
    <tr><td class="paramname">tuple</td><td>The tuple to assign. All <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> elements will be assigned this value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4814c237861e275fbcb767ad6c420cb" name="ad4814c237861e275fbcb767ad6c420cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4814c237861e275fbcb767ad6c420cb">&#9670;&#160;</a></span>deep_copy() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DstAoSoA, class SrcAoSoA&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">DstAoSoA &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;(<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; DstAoSoA &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt; *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy data between compatible <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination for the copied data. </td></tr>
    <tr><td class="paramname">src</td><td>The source of the copied data.</td></tr>
  </table>
  </dd>
</dl>
<p>Only <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> objects with the same set of member data types and size may be copied. </p>

</div>
</div>
<a id="a3bc1a6a5c0d637aba8406c5095c0f29a" name="a3bc1a6a5c0d637aba8406c5095c0f29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc1a6a5c0d637aba8406c5095c0f29a">&#9670;&#160;</a></span>deep_copy() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DstSlice, class SrcSlice&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">DstSlice &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcSlice &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; DstSlice &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SrcSlice &gt;::value)&gt; *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy data between compatible <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination for the copied data. </td></tr>
    <tr><td class="paramname">src</td><td>The source of the copied data.</td></tr>
  </table>
  </dd>
</dl>
<p>Only <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> objects with the same set of member data types and size may be copied. </p>

</div>
</div>
<a id="ae797717188eda2dbe524f73fd791f8c1" name="ae797717188eda2dbe524f73fd791f8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae797717188eda2dbe524f73fd791f8c1">&#9670;&#160;</a></span>deep_copy() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DstMemorySpace, class SrcMemorySpace, int DstVectorLength, int SrcVectorLength, class... FieldTags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; DstMemorySpace, DstVectorLength, FieldTags... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; SrcMemorySpace, SrcVectorLength, FieldTags... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy data between compatible <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination for the copied data. </td></tr>
    <tr><td class="paramname">src</td><td>The source of the copied data. s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae209c92053381625d4d040bb1f74682b" name="ae209c92053381625d4d040bb1f74682b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae209c92053381625d4d040bb1f74682b">&#9670;&#160;</a></span>deep_copy() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Slice_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">Slice_t &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Slice_t::value_type</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a slice with a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice to fill. </td></tr>
    <tr><td class="paramname">scalar</td><td>The scalar to assign. All slice elements will be assigned this value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b1bdb5946e4dfb5f96695e6cee6484d" name="a6b1bdb5946e4dfb5f96695e6cee6484d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1bdb5946e4dfb5f96695e6cee6484d">&#9670;&#160;</a></span>fillParameterPack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParameterPack_t, typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::fillParameterPack </td>
          <td>(</td>
          <td class="paramtype">ParameterPack_t &amp;</td>          <td class="paramname"><span class="paramname"><em>pp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types &amp;...</td>          <td class="paramname"><span class="paramname"><em>ts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill a parameter pack. Note the indexing is such that the Nth element of a parameter pack is the Nth element of the tuple. </p>

</div>
</div>
<a id="a15dca4f62c3f1f9cb7a9c869c7ae3486" name="a15dca4f62c3f1f9cb7a9c869c7ae3486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15dca4f62c3f1f9cb7a9c869c7ae3486">&#9670;&#160;</a></span>for_each_neighbor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexType, class FunctorType, class NeighborListType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void Cabana::for_each_neighbor </td>
          <td>(</td>
          <td class="paramtype">const IndexType</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>neighbor_functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute functor in serial within existing parallel kernel over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexType</td><td>The particle index type. </td></tr>
    <tr><td class="paramname">FunctorType</td><td>The neighbor functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td><a class="el" href="structCabana_1_1Particle.html" title="Single particle copy. Wraps a tuple copy of a particle.">Particle</a> index. </td></tr>
    <tr><td class="paramname">neighbor_functor</td><td>The neighbor functor to execute in parallel. </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors.</dd></dl>
<p>A "functor" is a class containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for neighbor parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> particle_index, <span class="keyword">const</span> <span class="keywordtype">int</span> neighbor_index ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>Index</code> is a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> index to a given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> element for a particle and its neighbor. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. This compares to a single iteration <code>idx</code> of a <code>for</code> loop. </p>

</div>
</div>
<a id="a366034424ecf96ad51645694c2d71676" name="a366034424ecf96ad51645694c2d71676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366034424ecf96ad51645694c2d71676">&#9670;&#160;</a></span>for_each_neighbor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexType, class FunctorType, class NeighborListType, class TeamMemberType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void Cabana::for_each_neighbor </td>
          <td>(</td>
          <td class="paramtype">const IndexType</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TeamMemberType</td>          <td class="paramname"><span class="paramname"><em>team</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>neighbor_functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute team parallel functor within existing parallel kernel over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexType</td><td>The particle index type. </td></tr>
    <tr><td class="paramname">FunctorType</td><td>The neighbor functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">TeamMemberType</td><td>Kokkos team policy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td><a class="el" href="structCabana_1_1Particle.html" title="Single particle copy. Wraps a tuple copy of a particle.">Particle</a> index. </td></tr>
    <tr><td class="paramname">team</td><td>Kokkos team. </td></tr>
    <tr><td class="paramname">neighbor_functor</td><td>The neighbor functor to execute in parallel. </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors. </dd></dl>

</div>
</div>
<a id="a75770ffe2209e474ae14436511d6b326" name="a75770ffe2209e474ae14436511d6b326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75770ffe2209e474ae14436511d6b326">&#9670;&#160;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HaloType, class ParticleDataType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::gather </td>
          <td>(</td>
          <td class="paramtype">const HaloType &amp;</td>          <td class="paramname"><span class="paramname"><em>halo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleDataType &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. This is a uniquely-owned to multiply-owned communication. </p>
<dl class="section note"><dt>Note</dt><dd>This routine allocates send and receive buffers internally. This is often not performant due to frequent buffer reallocations - consider creating and reusing <a class="el" href="classCabana_1_1Gather.html">Gather</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo to use for the gather.</td></tr>
    <tr><td class="paramname">data</td><td>The data on which to perform the gather. The slice should have a size equivalent to halo.numGhost() + halo.numLocal(). The locally owned elements are expected to appear first (i.e. in the first halo.numLocal() elements) and the ghosted elements are expected to appear second (i.e. in the next halo.numGhost() elements()). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bb075b5a602fbfea922fd1c190ddc3e" name="a8bb075b5a602fbfea922fd1c190ddc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb075b5a602fbfea922fd1c190ddc3e">&#9670;&#160;</a></span>getUniqueTopology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Cabana::getUniqueTopology </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return unique neighbor ranks, with the current rank first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>MPI communicator. </td></tr>
    <tr><td class="paramname">topology</td><td>MPI neighbor ranks in any order with possible duplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unique MPI neighbor ranks, with the current rank first. </dd></dl>

</div>
</div>
<a id="ad45fca0815618ea3fe95fcf688f38dc6" name="ad45fca0815618ea3fe95fcf688f38dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45fca0815618ea3fe95fcf688f38dc6">&#9670;&#160;</a></span>haloCheckValidSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="classCabana_1_1Halo.html">Halo</a>, class ParticleData&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Cabana::haloCheckValidSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1Halo.html">Halo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>halo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParticleData &amp;</td>          <td class="paramname"><span class="paramname"><em>particles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; <a class="el" href="classCabana_1_1Halo.html">Halo</a> &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure the particle size matches the total halo (local and ghost) size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo that will be used for the gather. Used to query import and export sizes.</td></tr>
    <tr><td class="paramname">particles</td><td>The particle data (either <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> or slice). Used to query the total size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9cb44110c8a6215d2ca62406e8aed35" name="ab9cb44110c8a6215d2ca62406e8aed35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cb44110c8a6215d2ca62406e8aed35">&#9670;&#160;</a></span>migrate() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Distributor_t, class AoSoA_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">const Distributor_t &amp;</td>          <td class="paramname"><span class="paramname"><em>distributor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;</td>          <td class="paramname"><span class="paramname"><em>aosoa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. Single <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version that will resize in-place. Note that resizing does not necessarily allocate more memory. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> memory will only increase if not enough has already been reserved/allocated for the needed number of elements. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> type - must be a distributor. </td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type - must be an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration. </td></tr>
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> containing the data to be migrated. Upon input, must have the same number of elements as the inputs used to construct the distributor. At output, it will be the same size as the number of import elements on this rank provided by the distributor. Before using this function, consider reserving enough memory in the data structure so reallocating is not necessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb10ac278624d871f6079c4e24ccb219" name="adb10ac278624d871f6079c4e24ccb219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb10ac278624d871f6079c4e24ccb219">&#9670;&#160;</a></span>migrate() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Distributor_t, class AoSoA_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">const Distributor_t &amp;</td>          <td class="paramname"><span class="paramname"><em>distributor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AoSoA_t &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. Multiple <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> type - must be a distributor. </td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type - must be an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration. </td></tr>
    <tr><td class="paramname">src</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> containing the data to be migrated. Must have the same number of elements as the inputs used to construct the distributor. </td></tr>
    <tr><td class="paramname">dst</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to which the migrated data will be written. Must be the same size as the number of imports given by the distributor on this rank. Call totalNumImport() on the distributor to get this size value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82063f55f2d0c3d17d11ba6642fb7353" name="a82063f55f2d0c3d17d11ba6642fb7353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82063f55f2d0c3d17d11ba6642fb7353">&#9670;&#160;</a></span>migrate() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Distributor_t, class Slice_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">const Distributor_t &amp;</td>          <td class="paramname"><span class="paramname"><em>distributor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Slice_t &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Slice_t &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. The user can do this in-place with the same slice but they will need to manage the resizing themselves as we can't resize slices. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> type - must be a distributor. </td></tr>
    <tr><td class="paramname">Slice_t</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type - must be an <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration. </td></tr>
    <tr><td class="paramname">src</td><td>The slice containing the data to be migrated. Must have the same number of elements as the inputs used to construct the distributor. </td></tr>
    <tr><td class="paramname">dst</td><td>The slice to which the migrated data will be written. Must be the same size as the number of imports given by the distributor on this rank. Call totalNumImport() on the distributor to get this size value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b49b38dd2be95b2b905698d063a0736" name="a4b49b38dd2be95b2b905698d063a0736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b49b38dd2be95b2b905698d063a0736">&#9670;&#160;</a></span>migrate() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace, class Distributor_t, class AoSoA_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace</td>          <td class="paramname"><span class="paramname"><em>exec_space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Distributor_t &amp;</td>          <td class="paramname"><span class="paramname"><em>distributor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;</td>          <td class="paramname"><span class="paramname"><em>aosoa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. Single <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version that will resize in-place. Note that resizing does not necessarily allocate more memory. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> memory will only increase if not enough has already been reserved/allocated for the needed number of elements. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecutionSpace</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> type - must be a distributor. </td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type - must be an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration. </td></tr>
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> containing the data to be migrated. Upon input, must have the same number of elements as the inputs used to construct the distributor. At output, it will be the same size as the number of import elements on this rank provided by the distributor. Before using this function, consider reserving enough memory in the data structure so reallocating is not necessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a83e23020e924fb010e2f5c20dbcc76" name="a7a83e23020e924fb010e2f5c20dbcc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a83e23020e924fb010e2f5c20dbcc76">&#9670;&#160;</a></span>migrate() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace, class Distributor_t, class AoSoA_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace</td>          <td class="paramname"><span class="paramname"><em>exec_space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Distributor_t &amp;</td>          <td class="paramname"><span class="paramname"><em>distributor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AoSoA_t &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. Multiple <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecutionSpace</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> type - must be a distributor. </td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type - must be an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration. </td></tr>
    <tr><td class="paramname">src</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> containing the data to be migrated. Must have the same number of elements as the inputs used to construct the distributor. </td></tr>
    <tr><td class="paramname">dst</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to which the migrated data will be written. Must be the same size as the number of imports given by the distributor on this rank. Call totalNumImport() on the distributor to get this size value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28763cb86df25a0d48011c19ddd69fc9" name="a28763cb86df25a0d48011c19ddd69fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28763cb86df25a0d48011c19ddd69fc9">&#9670;&#160;</a></span>migrate() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace, class Distributor_t, class Slice_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace</td>          <td class="paramname"><span class="paramname"><em>exec_space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Distributor_t &amp;</td>          <td class="paramname"><span class="paramname"><em>distributor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Slice_t &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Slice_t &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. The user can do this in-place with the same slice but they will need to manage the resizing themselves as we can't resize slices. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecutionSpace</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">Distributor_t</td><td>distributor type - must be a distributor. </td></tr>
    <tr><td class="paramname">Slice_t</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type - must be an <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration. </td></tr>
    <tr><td class="paramname">src</td><td>The slice containing the data to be migrated. Must have the same number of elements as the inputs used to construct the distributor. </td></tr>
    <tr><td class="paramname">dst</td><td>The slice to which the migrated data will be written. Must be the same size as the number of imports given by the distributor on this rank. Call totalNumImport() on the distributor to get this size value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9f630b4b7e635dc521ad68b849140b6" name="ad9f630b4b7e635dc521ad68b849140b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f630b4b7e635dc521ad68b849140b6">&#9670;&#160;</a></span>neighbor_parallel_for() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType, class LinkedCellType, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LinkedCellType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with thread-local serial loops over linked cell list bins and particle first neighbors in those bins. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The linked cell list over which to execute neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a> Tag indicating a serial loop strategy over neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes.</td></tr>
  </table>
  </dd>
</dl>
<p>A "functor" is a class containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for neighbor parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> particle_index, <span class="keyword">const</span> <span class="keywordtype">int</span> neighbor_index ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>Index</code> is a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> index to a given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> element for a particle and its neighbor. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. This compares to a single iteration <code>idx</code> of a <code>for</code> loop. </p>

</div>
</div>
<a id="a47fa816fbb9649b98b6765cbb9603e0b" name="a47fa816fbb9649b98b6765cbb9603e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fa816fbb9649b98b6765cbb9603e0b">&#9670;&#160;</a></span>neighbor_parallel_for() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType, class LinkedCellType, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LinkedCellType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with thread-local serial loops over linked cell list bins and team threading over particle first neighbors in those bins. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The linked cell list over which to execute neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a> Tag indicating a team parallel strategy over particle neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24b18535ed149bb8aa6c8e4217c0dff9" name="a24b18535ed149bb8aa6c8e4217c0dff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b18535ed149bb8aa6c8e4217c0dff9">&#9670;&#160;</a></span>neighbor_parallel_for() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType, class NeighborListType, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with a thread-local serial loop over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a> Tag indicating a serial loop strategy over neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes.</td></tr>
  </table>
  </dd>
</dl>
<p>A "functor" is a class containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for neighbor parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> particle_index, <span class="keyword">const</span> <span class="keywordtype">int</span> neighbor_index ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>Index</code> is a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> index to a given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> element for a particle and its neighbor. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. This compares to a single iteration <code>idx</code> of a <code>for</code> loop. </p>

</div>
</div>
<a id="aefdf5eabe42ed35aa32b9d5b5bdf87f4" name="aefdf5eabe42ed35aa32b9d5b5bdf87f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdf5eabe42ed35aa32b9d5b5bdf87f4">&#9670;&#160;</a></span>neighbor_parallel_for() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType, class NeighborListType, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a> Tag indicating a team parallel strategy over neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a805d7df1a47edd9c4daaa11d70555401" name="a805d7df1a47edd9c4daaa11d70555401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805d7df1a47edd9c4daaa11d70555401">&#9670;&#160;</a></span>neighbor_parallel_for() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType, class NeighborListType, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with thread-local serial loops over particle first and second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a> Tag indicating operations over particle first and second neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a> Tag indicating a serial loop strategy over neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a229fb2c6ed2f887d59fea0b9e2bbcb35" name="a229fb2c6ed2f887d59fea0b9e2bbcb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229fb2c6ed2f887d59fea0b9e2bbcb35">&#9670;&#160;</a></span>neighbor_parallel_for() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType, class NeighborListType, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors and serial loop over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a> Tag indicating operations over particle first and second neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a> Tag indicating a team parallel strategy over particle first neighbors and serial execution over second neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4ef15a052c4647babb9bb12229b9804" name="af4ef15a052c4647babb9bb12229b9804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ef15a052c4647babb9bb12229b9804">&#9670;&#160;</a></span>neighbor_parallel_for() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType, class NeighborListType, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors and vector loop parallelism over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a> Tag indicating operations over particle first and second neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1TeamVectorOpTag.html" title="Neighbor operations are executed with team vector parallelism.">TeamVectorOpTag</a> Tag indicating a team parallel strategy over particle first neighbors and vector parallel loop strategy over second neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29d6d642d6860adcd8a0f37f9c740b89" name="a29d6d642d6860adcd8a0f37f9c740b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d6d642d6860adcd8a0f37f9c740b89">&#9670;&#160;</a></span>neighbor_parallel_reduce() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType, class LinkedCellType, class ReduceType, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LinkedCellType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;</td>          <td class="paramname"><span class="paramname"><em>reduce_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with thread-local serial loops over linked cell list bins and particle first neighbors in those bins. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The linked cell list over which to execute neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a> Tag indicating a serial loop strategy over neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_val</td><td>the value begin reduced </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes.</td></tr>
  </table>
  </dd>
</dl>
<p>A "functor" is a class containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for neighbor parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> particle_index, <span class="keyword">const</span> <span class="keywordtype">int</span> neighbor_index ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>Index</code> is a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> index to a given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> element for a particle and its neighbor. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. This compares to a single iteration <code>idx</code> of a <code>for</code> loop. </p>

</div>
</div>
<a id="a507a2bc4113be499490095b0d956e922" name="a507a2bc4113be499490095b0d956e922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507a2bc4113be499490095b0d956e922">&#9670;&#160;</a></span>neighbor_parallel_reduce() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType, class LinkedCellType, class ReduceType, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LinkedCellType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;</td>          <td class="paramname"><span class="paramname"><em>reduce_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with thread-local serial loops over linked cell list bins and team threading over particle first neighbors in those bins. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The linked cell list over which to execute neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a> Tag indicating a team parallel strategy over particle neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_val</td><td>the value begin reduced </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5394edf96f28ccd3f77d88044c1cf46a" name="a5394edf96f28ccd3f77d88044c1cf46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5394edf96f28ccd3f77d88044c1cf46a">&#9670;&#160;</a></span>neighbor_parallel_reduce() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType, class NeighborListType, class ReduceType, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;</td>          <td class="paramname"><span class="paramname"><em>reduce_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor reduction in parallel according to the execution policy over particles with a thread-local serial loop over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters. </td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a> Tag indicating a serial loop strategy over neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes.</td></tr>
  </table>
  </dd>
</dl>
<p>A "functor" is a class containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for neighbor parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> particle_index, <span class="keyword">const</span> <span class="keywordtype">int</span> neighbor_index ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>Index</code> is a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> index to a given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> element for a particle and its neighbor. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. This compares to a single iteration <code>idx</code> of a <code>for</code> loop. </p>

</div>
</div>
<a id="ab37281baa1f9f01f2ab49ef1b7b2b059" name="ab37281baa1f9f01f2ab49ef1b7b2b059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37281baa1f9f01f2ab49ef1b7b2b059">&#9670;&#160;</a></span>neighbor_parallel_reduce() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType, class NeighborListType, class ReduceType, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;</td>          <td class="paramname"><span class="paramname"><em>reduce_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters. </td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a> Tag indicating a team parallel strategy over particle neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b7472fbee84a03c3af4cbbd85391713" name="a4b7472fbee84a03c3af4cbbd85391713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7472fbee84a03c3af4cbbd85391713">&#9670;&#160;</a></span>neighbor_parallel_reduce() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType, class NeighborListType, class ReduceType, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;</td>          <td class="paramname"><span class="paramname"><em>reduce_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor reduction in parallel according to the execution policy over particles with thread-local serial loops over particle first and second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters. </td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a> Tag indicating operations over particle first and second neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a> Tag indicating a serial loop strategy over neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e09860dc2f238e0201b091d563d4e1c" name="a2e09860dc2f238e0201b091d563d4e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e09860dc2f238e0201b091d563d4e1c">&#9670;&#160;</a></span>neighbor_parallel_reduce() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType, class NeighborListType, class ReduceType, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;</td>          <td class="paramname"><span class="paramname"><em>reduce_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors and serial loop over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters. </td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a> Tag indicating operations over particle first and second neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a> Tag indicating a team parallel strategy over particle first neighbors and serial loops over second neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75e10a632cbe3a11615c60c1ef1f8300" name="a75e10a632cbe3a11615c60c1ef1f8300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e10a632cbe3a11615c60c1ef1f8300">&#9670;&#160;</a></span>neighbor_parallel_reduce() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType, class NeighborListType, class ReduceType, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;</td>          <td class="paramname"><span class="paramname"><em>reduce_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; NeighborListType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors and vector loop parallelism over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters. </td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a> Tag indicating operations over particle first and second neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1TeamVectorOpTag.html" title="Neighbor operations are executed with team vector parallelism.">TeamVectorOpTag</a> Tag indicating a team parallel strategy over particle first neighbors and vector loops over second neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70cddd6233e137bfbe2ca4773e565e5d" name="a70cddd6233e137bfbe2ca4773e565e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cddd6233e137bfbe2ca4773e565e5d">&#9670;&#160;</a></span>neighborHistogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace, class ListType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt; int *[2], typename ListType::memory_space &gt; Cabana::neighborHistogram </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace</td>          <td class="paramname"><span class="paramname"><em>exec_space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_particles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ListType &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>num_bin</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a histogram of neighbors per particle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">num_particles</td><td>Number of particles. </td></tr>
    <tr><td class="paramname">list</td><td>Neighbor list with valid <a class="el" href="classCabana_1_1NeighborList.html" title="Neighbor list interface. Provides an interface callable at the functor level that gives access to nei...">NeighborList</a> interface. </td></tr>
    <tr><td class="paramname">num_bin</td><td>Number of bins for the histogram. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Neighbor list histogram View. </dd></dl>

</div>
</div>
<a id="a824f296314f00ca8e121e6a26e2846db" name="a824f296314f00ca8e121e6a26e2846db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824f296314f00ca8e121e6a26e2846db">&#9670;&#160;</a></span>permute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BinningDataType, class AoSoA_t, class ExecutionSpace = typename BinningDataType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">const BinningDataType &amp;</td>          <td class="paramname"><span class="paramname"><em>binning_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;</td>          <td class="paramname"><span class="paramname"><em>aosoa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(is_binning_data&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given binning data permute an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinningDataType</td><td>The binning data type. </td></tr>
    <tr><td class="paramname">AoSoA_t</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binning_data</td><td>The binning data. </td></tr>
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab44a65c22331c71ed7cee721a41c54fc" name="ab44a65c22331c71ed7cee721a41c54fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44a65c22331c71ed7cee721a41c54fc">&#9670;&#160;</a></span>permute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BinningDataType, class SliceType, class ExecutionSpace = typename BinningDataType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">const BinningDataType &amp;</td>          <td class="paramname"><span class="paramname"><em>binning_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceType &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(is_binning_data&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given binning data permute a slice. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinningDataType</td><td>The binning data type. </td></tr>
    <tr><td class="paramname">SliceType</td><td>The slice type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binning_data</td><td>The binning data. </td></tr>
    <tr><td class="paramname">slice</td><td>The slice to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f34189fb341f3228569a06d7a259766" name="a7f34189fb341f3228569a06d7a259766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f34189fb341f3228569a06d7a259766">&#9670;&#160;</a></span>permute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BinningDataType, class ViewType, class MemorySpace = typename BinningDataType::memory_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">const BinningDataType &amp;</td>          <td class="paramname"><span class="paramname"><em>binning_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>view</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(is_binning_data&lt; BinningDataType &gt;::value &amp;&amp;Kokkos::is_view&lt; ViewType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given binning data permute a View. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinningDataType</td><td>The binning data type.</td></tr>
    <tr><td class="paramname">ViewType</td><td>The view type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binning_data</td><td>The binning data.</td></tr>
    <tr><td class="paramname">view</td><td>The view to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a718a56e3bd90ee4e6b80095fd15a9db7" name="a718a56e3bd90ee4e6b80095fd15a9db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718a56e3bd90ee4e6b80095fd15a9db7">&#9670;&#160;</a></span>permute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LinkedCellListType, class PositionType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">LinkedCellListType &amp;</td>          <td class="paramname"><span class="paramname"><em>linked_cell_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionType &amp;</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellListType &gt;::value &amp;&amp;(<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; PositionType &gt;::value||<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value)), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a linked cell list permute positions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LinkedCellListType</td><td>The linked cell list type.</td></tr>
    <tr><td class="paramname">PositionType</td><td>Positions type (<a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> or <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> or Kokkos::View).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linked_cell_list</td><td>The linked cell list to permute the positions with.</td></tr>
    <tr><td class="paramname">positions</td><td>Positions to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4a8672095ebecba36332e0b0ea60f94" name="af4a8672095ebecba36332e0b0ea60f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a8672095ebecba36332e0b0ea60f94">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace, class KeepView, class ParticleAoSoA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::remove </td>
          <td>(</td>
          <td class="paramtype">const ExecutionSpace &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>num_keep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeepView &amp;</td>          <td class="paramname"><span class="paramname"><em>keep_particle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleAoSoA &amp;</td>          <td class="paramname"><span class="paramname"><em>particles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>num_particles_ignore</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>shrink_to_fit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter out empty/unneeded particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">num_keep</td><td>The total number of particles in the compaction section to keep. </td></tr>
    <tr><td class="paramname">num_particles_ignore</td><td>The number of particles to ignore (which precede those which may be kept/removed). </td></tr>
    <tr><td class="paramname">keep_particle</td><td>Boolean Kokkos View of particles to keep (true) or remove (false). </td></tr>
    <tr><td class="paramname">particles</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> containing particles. </td></tr>
    <tr><td class="paramname">shrink_to_fit</td><td>Whether to remove additional <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> capacity or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8eb6aa8da865a5ff9c1a86f1ba0a281" name="aa8eb6aa8da865a5ff9c1a86f1ba0a281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8eb6aa8da865a5ff9c1a86f1ba0a281">&#9670;&#160;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HaloType, class SliceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::scatter </td>
          <td>(</td>
          <td class="paramtype">const HaloType &amp;</td>          <td class="paramname"><span class="paramname"><em>halo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceType &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; HaloType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously scatter data from the ghosts to the local decomposition of a slice using the halo reverse communication plan. This is a multiply-owned to uniquely owned communication. </p>
<dl class="section note"><dt>Note</dt><dd>This routine allocates send and receive buffers internally. This is often not performant due to frequent buffer reallocations - consider creating and reusing <a class="el" href="classCabana_1_1Gather.html">Gather</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo to use for the scatter.</td></tr>
    <tr><td class="paramname">slice</td><td>The <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> on which to perform the scatter. The <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> should have a size equivalent to halo.numGhost() + halo.numLocal(). The locally owned elements are expected to appear first (i.e. in the first halo.numLocal() elements) and the ghosted elements are expected to appear second (i.e. in the next halo.numGhost() elements()). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7dda1a05e595dbec3f4f06e7f878d9e" name="ab7dda1a05e595dbec3f4f06e7f878d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7dda1a05e595dbec3f4f06e7f878d9e">&#9670;&#160;</a></span>simd_parallel_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType, int VectorLength, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::simd_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SimdPolicy.html">SimdPolicy</a>&lt; VectorLength, ExecParameters... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exec_policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a vectorized functor in parallel with a 2d execution policy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">VectorLength</td><td>The length of the vector over which to execute the vectorized code.</td></tr>
    <tr><td class="paramname">ExecParameters</td><td>Execution policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The 2D range policy over which to execute the functor.</td></tr>
    <tr><td class="paramname">functor</td><td>The vectorized functor to execute in parallel. Must accept both a struct and array index.</td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes.</td></tr>
  </table>
  </dd>
</dl>
<p>A "functor" is a callable object containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> <span class="keyword">struct</span>, <span class="keyword">const</span> <span class="keywordtype">int</span> array ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>struct</code> defines an index to a given AoSoA/Slice struct and array defines and index to the given array element in that struct. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. The kernel represented by the functor is intended to vectorize of the array index.</p>
<dl class="section note"><dt>Note</dt><dd>The work tag gets applied at the user functor level, not at the level of the functor in this implementation that wraps the user functor. </dd></dl>

</div>
</div>
<a id="aa14f30ab334c57448b204fc9b304289a" name="aa14f30ab334c57448b204fc9b304289a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14f30ab334c57448b204fc9b304289a">&#9670;&#160;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t M, class AoSoA_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">AoSoA_t::template member_slice_type&lt; M &gt; Cabana::slice </td>
          <td>(</td>
          <td class="paramtype">const AoSoA_t &amp;</td>          <td class="paramname"><span class="paramname"><em>aosoa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>slice_label</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a slice from an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> index. </td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aosoa</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to slice from. </td></tr>
    <tr><td class="paramname">slice_label</td><td>Optional slice label. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> </dd></dl>

</div>
</div>
<a id="a5c64ff984d2da99d6ff20d89a8ae9899" name="a5c64ff984d2da99d6ff20d89a8ae9899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c64ff984d2da99d6ff20d89a8ae9899">&#9670;&#160;</a></span>sortByKey() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType, class ExecutionSpace = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort. </td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="a73cfa6540c7adf84fb5d3546950c46e6" name="a73cfa6540c7adf84fb5d3546950c46e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cfa6540c7adf84fb5d3546950c46e6">&#9670;&#160;</a></span>sortByKey() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType, class ExecutionSpace = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="a2577949b8aa884de4873f31efa54401b" name="a2577949b8aa884de4873f31efa54401b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2577949b8aa884de4873f31efa54401b">&#9670;&#160;</a></span>sortByKey() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType, class ExecutionSpace = typename SliceType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys. </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort. </td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="a360b0f9c15911bfac904d240e7f369d7" name="a360b0f9c15911bfac904d240e7f369d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360b0f9c15911bfac904d240e7f369d7">&#9670;&#160;</a></span>sortByKey() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType, class ExecutionSpace = typename SliceType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="ac7a029626fb67b12cf279b7f3c620159" name="ac7a029626fb67b12cf279b7f3c620159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a029626fb67b12cf279b7f3c620159">&#9670;&#160;</a></span>sortByKeyWithComparator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType, class Comparator, class ExecutionSpace = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::sortByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys. </td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for sorting. Must be compatible with Kokkos::BinSort. </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort. </td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="ac8376dcbdaa0c3dad87fe19203cf1755" name="ac8376dcbdaa0c3dad87fe19203cf1755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8376dcbdaa0c3dad87fe19203cf1755">&#9670;&#160;</a></span>sortByKeyWithComparator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType, class Comparator, class ExecutionSpace = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::sortByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys. </td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for sorting. Must be compatible with Kokkos::BinSort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceCabana.html">Cabana</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
