<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cabana: Cabana Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cabana<span id="projectnumber">&#160;0.7.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Cabana Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Core: particle data structures and algorithms.  
<a href="namespaceCabana.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array-of-Struct-of-Arrays.  <a href="classCabana_1_1AoSoA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1AtomicAccessMemory.html">AtomicAccessMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic memory access. All reads and writes are atomic.  <a href="structCabana_1_1AtomicAccessMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1BinningData.html">BinningData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data describing the bin sizes and offsets resulting from a binning operation.  <a href="classCabana_1_1BinningData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1CheckMemberTypes.html">CheckMemberTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that member types are valid.  <a href="structCabana_1_1CheckMemberTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1CheckMemberTypes_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html">CheckMemberTypes&lt; MemberTypes&lt; Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that member types are valid.  <a href="structCabana_1_1CheckMemberTypes_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationData.html">CommunicationData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store communication plan and communication buffers.  <a href="classCabana_1_1CommunicationData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1CommunicationDataAoSoA.html">CommunicationDataAoSoA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> send/receive buffers.  <a href="structCabana_1_1CommunicationDataAoSoA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1CommunicationDataSlice.html">CommunicationDataSlice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store slice send/receive buffers.  <a href="structCabana_1_1CommunicationDataSlice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html">CommunicationPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Communication plan base class.  <a href="classCabana_1_1CommunicationPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1DefaultAccessMemory.html">DefaultAccessMemory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Distributor.html">Distributor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A communication plan for migrating data from one uniquely-owned decomposition to another uniquely owned decomposition.  <a href="classCabana_1_1Distributor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over particle neighbors.  <a href="classCabana_1_1FirstNeighborsTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1FullNeighborTag.html">FullNeighborTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for full neighbor lists.  <a href="classCabana_1_1FullNeighborTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Gather.html">Gather</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Gather_3_01HaloType_00_01AoSoAType_00_01typename_01std_1_1enable__if_3_01is__aoso666e08a1494152c80218c785a19e78d3.html">Gather&lt; HaloType, AoSoAType, typename std::enable_if&lt; is_aosoa&lt; AoSoAType &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version. This is a uniquely-owned to multiply-owned communication.  <a href="classCabana_1_1Gather_3_01HaloType_00_01AoSoAType_00_01typename_01std_1_1enable__if_3_01is__aoso666e08a1494152c80218c785a19e78d3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Gather_3_01HaloType_00_01SliceType_00_01typename_01std_1_1enable__if_3_01is__slica420051aad1e71fccbd290130c9a8cef.html">Gather&lt; HaloType, SliceType, typename std::enable_if&lt; is_slice&lt; SliceType &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version. This is a uniquely-owned to multiply-owned communication.  <a href="classCabana_1_1Gather_3_01HaloType_00_01SliceType_00_01typename_01std_1_1enable__if_3_01is__slica420051aad1e71fccbd290130c9a8cef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1HalfNeighborTag.html">HalfNeighborTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for half neighbor lists.  <a href="classCabana_1_1HalfNeighborTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Halo.html">Halo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A communication plan for scattering and gathering of ghosted data.  <a href="classCabana_1_1Halo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random particle initialization type tag.  <a href="structCabana_1_1InitRandom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1InitUniform.html">InitUniform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform particle initialization type tag.  <a href="structCabana_1_1InitUniform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__accessible__from.html">is_accessible_from</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__accessible__from_3_01MemorySpace_00_01ExecutionSpace_00_01std_1_1enable__if_96534d0f81e01b006272bb63cf2f3dd3.html">is_accessible_from&lt; MemorySpace, ExecutionSpace, std::enable_if_t&lt; Kokkos::SpaceAccessibility&lt; ExecutionSpace, MemorySpace &gt;::accessible &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> static type checker.  <a href="structCabana_1_1is__aosoa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__binning__data_3_01const_01BinningData_3_01MemorySpace_01_4_01_4.html">is_binning_data&lt; const BinningData&lt; MemorySpace &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1BinningData.html" title="Data describing the bin sizes and offsets resulting from a binning operation.">BinningData</a> static type checker.  <a href="structCabana_1_1is__binning__data_3_01const_01BinningData_3_01MemorySpace_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> static type checker.  <a href="structCabana_1_1is__distributor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__halo.html">is_halo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1Halo.html" title="A communication plan for scattering and gathering of ghosted data.">Halo</a> static type checker.  <a href="structCabana_1_1is__halo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1LinkedCellList.html" title="Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesia...">LinkedCellList</a> static type checker.  <a href="structCabana_1_1is__linked__cell__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__member__types.html">is_member_types</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static type checker.  <a href="structCabana_1_1is__member__types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag.html">is_memory_access_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory access type checker.  <a href="structCabana_1_1is__memory__access__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag_3_01AtomicAccessMemory_01_4.html">is_memory_access_tag&lt; AtomicAccessMemory &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag_3_01DefaultAccessMemory_01_4.html">is_memory_access_tag&lt; DefaultAccessMemory &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory access type checker.  <a href="structCabana_1_1is__memory__access__tag_3_01DefaultAccessMemory_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__memory__access__tag_3_01RandomAccessMemory_01_4.html">is_memory_access_tag&lt; RandomAccessMemory &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__parameter__pack.html">is_parameter_pack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1ParameterPack.html">ParameterPack</a> static type checker.  <a href="structCabana_1_1is__parameter__pack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__particle__list.html">is_particle_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> static type checker.  <a href="structCabana_1_1is__particle__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__particle__list__impl.html">is_particle_list_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__particle__list__impl_3_01ParticleList_3_01MemorySpace_00_01VectorLength_00_01FieldTags_8_8_8_01_4_01_4.html">is_particle_list_impl&lt; ParticleList&lt; MemorySpace, VectorLength, FieldTags... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__slice.html">is_slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> static type checker.  <a href="structCabana_1_1is__slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__soa.html">is_soa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1SoA.html">SoA</a> static type checker.  <a href="structCabana_1_1is__soa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Tuple.html">Tuple</a> static type checker.  <a href="structCabana_1_1is__tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1LinkedCellList.html">LinkedCellList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data describing the bin sizes and offsets resulting from a binning operation on a 3d regular Cartesian grid.  <a href="classCabana_1_1LinkedCellList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1MemberTypeAtIndex.html">MemberTypeAtIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the member at a given index.  <a href="structCabana_1_1MemberTypeAtIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1MemberTypeAtIndex_3_01M_00_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html">MemberTypeAtIndex&lt; M, MemberTypes&lt; Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the member at a given index.  <a href="structCabana_1_1MemberTypeAtIndex_3_01M_00_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1MemberTypes.html">MemberTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General sequence of types for <a class="el" href="structCabana_1_1SoA.html">SoA</a> and <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> member data.  <a href="structCabana_1_1MemberTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList.html">NeighborList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor list interface. Provides an interface callable at the functor level that gives access to neighbor data for particles.  <a href="classCabana_1_1NeighborList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01Experimental_1_1CrsGraph_3_01MemorySpace_00_01Tag_01_4_01_4.html">NeighborList&lt; Experimental::CrsGraph&lt; MemorySpace, Tag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">1d ArborX <a class="el" href="classCabana_1_1NeighborList.html" title="Neighbor list interface. Provides an interface callable at the functor level that gives access to nei...">NeighborList</a> interface.  <a href="classCabana_1_1NeighborList_3_01Experimental_1_1CrsGraph_3_01MemorySpace_00_01Tag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01Experimental_1_1Dense_3_01MemorySpace_00_01Tag_01_4_01_4.html">NeighborList&lt; Experimental::Dense&lt; MemorySpace, Tag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2d ArborX <a class="el" href="classCabana_1_1NeighborList.html" title="Neighbor list interface. Provides an interface callable at the functor level that gives access to nei...">NeighborList</a> interface.  <a href="classCabana_1_1NeighborList_3_01Experimental_1_1Dense_3_01MemorySpace_00_01Tag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01VerletLayout2D_00_01BuildTag_01_4_01_4.html">NeighborList&lt; VerletList&lt; MemorySpace, AlgorithmTag, VerletLayout2D, BuildTag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D <a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a 3d Cartesian grid with cells of the same...">VerletList</a> <a class="el" href="classCabana_1_1NeighborList.html" title="Neighbor list interface. Provides an interface callable at the functor level that gives access to nei...">NeighborList</a> interface.  <a href="classCabana_1_1NeighborList_3_01VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01VerletLayout2D_00_01BuildTag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1NeighborList_3_01VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01VerletLayoutCSR_00_01BuildTag_01_4_01_4.html">NeighborList&lt; VerletList&lt; MemorySpace, AlgorithmTag, VerletLayoutCSR, BuildTag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSR <a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a 3d Cartesian grid with cells of the same...">VerletList</a> <a class="el" href="classCabana_1_1NeighborList.html" title="Neighbor list interface. Provides an interface callable at the functor level that gives access to nei...">NeighborList</a> interface.  <a href="classCabana_1_1NeighborList_3_01VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01VerletLayoutCSR_00_01BuildTag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1PackTypeAtIndex.html">PackTypeAtIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type at the given index of a parameter pack.  <a href="structCabana_1_1PackTypeAtIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1ParameterPack.html">ParameterPack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1ParameterPackElement.html">ParameterPackElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter pack element.  <a href="structCabana_1_1ParameterPackElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1Particle.html">Particle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single particle copy. Wraps a tuple copy of a particle.  <a href="structCabana_1_1Particle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of particle fields stored in <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <a href="classCabana_1_1ParticleList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1ParticleTraits.html">ParticleTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> particle fields for <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a>.  <a href="structCabana_1_1ParticleTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1ParticleView.html">ParticleView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single <a class="el" href="structCabana_1_1SoA.html">SoA</a> particle view. Wraps a view of the <a class="el" href="structCabana_1_1SoA.html">SoA</a> the particle resides in.  <a href="structCabana_1_1ParticleView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1RandomAccessMemory.html">RandomAccessMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access memory. Read-only and const with limited spatial locality.  <a href="structCabana_1_1RandomAccessMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Scatter.html">Scatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously scatter data from the ghosts to the local decomposition of a slice using the halo reverse communication plan. This is a multiply-owned to uniquely owned communication.  <a href="classCabana_1_1Scatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over particle neighbors (first) and neighbor's neighbors (second)  <a href="classCabana_1_1SecondNeighborsTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor operations are executed in serial on each particle thread.  <a href="classCabana_1_1SerialOpTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1SimdPolicy.html">SimdPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution policy over a range of 2d indices.  <a href="classCabana_1_1SimdPolicy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Slice.html">Slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.  <a href="classCabana_1_1Slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1SoA.html">SoA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1SoA_3_01MemberTypes_3_01Types_8_8_8_01_4_00_01VectorLength_01_4.html">SoA&lt; MemberTypes&lt; Types... &gt;, VectorLength &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct-of-Arrays.  <a href="structCabana_1_1SoA_3_01MemberTypes_3_01Types_8_8_8_01_4_00_01VectorLength_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor operations are executed with team parallelism.  <a href="classCabana_1_1TeamOpTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor operations are executed with team vector parallelism.  <a href="classCabana_1_1TeamVectorOpTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1Tuple.html">Tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1Tuple_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html">Tuple&lt; MemberTypes&lt; Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Tuple.html">Tuple</a>.  <a href="structCabana_1_1Tuple_3_01MemberTypes_3_01Types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1TypeIndexer.html">TypeIndexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a field type within a particle type list.  <a href="structCabana_1_1TypeIndexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletLayout2D.html">VerletLayout2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D array neighbor list layout.  <a href="structCabana_1_1VerletLayout2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletLayoutCSR.html">VerletLayoutCSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSR (compressed sparse row) neighbor list layout.  <a href="structCabana_1_1VerletLayoutCSR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1VerletList.html">VerletList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor list implementation based on binning particles on a 3d Cartesian grid with cells of the same size as the interaction distance.  <a href="classCabana_1_1VerletList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletListData.html">VerletListData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletListData_3_01MemorySpace_00_01VerletLayout2D_01_4.html">VerletListData&lt; MemorySpace, VerletLayout2D &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the <a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a 3d Cartesian grid with cells of the same...">VerletList</a> 2D neighbor data.  <a href="structCabana_1_1VerletListData_3_01MemorySpace_00_01VerletLayout2D_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1VerletListData_3_01MemorySpace_00_01VerletLayoutCSR_01_4.html">VerletListData&lt; MemorySpace, VerletLayoutCSR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the <a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a 3d Cartesian grid with cells of the same...">VerletList</a> compressed sparse row (CSR) neighbor data.  <a href="structCabana_1_1VerletListData_3_01MemorySpace_00_01VerletLayoutCSR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa14f30ab334c57448b204fc9b304289a" id="r_aa14f30ab334c57448b204fc9b304289a"><td class="memTemplParams" colspan="2">template&lt;std::size_t M, class AoSoA_t &gt; </td></tr>
<tr class="memitem:aa14f30ab334c57448b204fc9b304289a"><td class="memTemplItemLeft" align="right" valign="top">AoSoA_t::template member_slice_type&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a> (const AoSoA_t &amp;aosoa, const std::string &amp;slice_label=&quot;&quot;)</td></tr>
<tr class="memdesc:aa14f30ab334c57448b204fc9b304289a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a slice from an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <br /></td></tr>
<tr class="separator:aa14f30ab334c57448b204fc9b304289a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb075b5a602fbfea922fd1c190ddc3e" id="r_a8bb075b5a602fbfea922fd1c190ddc3e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a8bb075b5a602fbfea922fd1c190ddc3e">getUniqueTopology</a> (MPI_Comm comm, std::vector&lt; int &gt; topology)</td></tr>
<tr class="memdesc:a8bb075b5a602fbfea922fd1c190ddc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return unique neighbor ranks, with the current rank first.  <br /></td></tr>
<tr class="separator:a8bb075b5a602fbfea922fd1c190ddc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbb88343c498a5e729ed54e4e845971" id="r_a0dbb88343c498a5e729ed54e4e845971"><td class="memTemplParams" colspan="2">template&lt;class Space , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:a0dbb88343c498a5e729ed54e4e845971"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a0dbb88343c498a5e729ed54e4e845971">create_mirror</a> (const Space &amp;, const SrcAoSoA &amp;src, typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:a0dbb88343c498a5e729ed54e4e845971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a mirror of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given space.  <br /></td></tr>
<tr class="separator:a0dbb88343c498a5e729ed54e4e845971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682f288aa48e84e44856d1a0b2239b43" id="r_a682f288aa48e84e44856d1a0b2239b43"><td class="memTemplParams" colspan="2">template&lt;class Space , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:a682f288aa48e84e44856d1a0b2239b43"><td class="memTemplItemLeft" align="right" valign="top">SrcAoSoA&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a682f288aa48e84e44856d1a0b2239b43">create_mirror_view</a> (const Space &amp;, const SrcAoSoA &amp;src, typename std::enable_if&lt;(std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:a682f288aa48e84e44856d1a0b2239b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given space. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <br /></td></tr>
<tr class="separator:a682f288aa48e84e44856d1a0b2239b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b0a5aebc7bad1d55552382aa1cd853" id="r_a72b0a5aebc7bad1d55552382aa1cd853"><td class="memTemplParams" colspan="2">template&lt;class Space , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:a72b0a5aebc7bad1d55552382aa1cd853"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a72b0a5aebc7bad1d55552382aa1cd853">create_mirror_view</a> (const Space &amp;space, const SrcAoSoA &amp;src, typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:a72b0a5aebc7bad1d55552382aa1cd853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <br /></td></tr>
<tr class="separator:a72b0a5aebc7bad1d55552382aa1cd853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe27556a6136fe14b11c7c2f943aa63c" id="r_abe27556a6136fe14b11c7c2f943aa63c"><td class="memTemplParams" colspan="2">template&lt;class Space , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:abe27556a6136fe14b11c7c2f943aa63c"><td class="memTemplItemLeft" align="right" valign="top">SrcAoSoA&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#abe27556a6136fe14b11c7c2f943aa63c">create_mirror_view_and_copy</a> (const Space &amp;, const SrcAoSoA &amp;src, typename std::enable_if&lt;(std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:abe27556a6136fe14b11c7c2f943aa63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and copy the contents of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <br /></td></tr>
<tr class="separator:abe27556a6136fe14b11c7c2f943aa63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2750b69be547c4aa520c3ac6c1d033" id="r_a3e2750b69be547c4aa520c3ac6c1d033"><td class="memTemplParams" colspan="2">template&lt;class Space , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:a3e2750b69be547c4aa520c3ac6c1d033"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a3e2750b69be547c4aa520c3ac6c1d033">create_mirror_view_and_copy</a> (const Space &amp;space, const SrcAoSoA &amp;src, typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:a3e2750b69be547c4aa520c3ac6c1d033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and deep copy the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> into the mirror. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> and performs the deep copy.  <br /></td></tr>
<tr class="separator:a3e2750b69be547c4aa520c3ac6c1d033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1932d2c9be351d64dfcb6e2d22fc68c8" id="r_a1932d2c9be351d64dfcb6e2d22fc68c8"><td class="memTemplParams" colspan="2">template&lt;class DstAoSoA , class SrcAoSoA &gt; </td></tr>
<tr class="memitem:a1932d2c9be351d64dfcb6e2d22fc68c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a1932d2c9be351d64dfcb6e2d22fc68c8">deep_copy</a> (DstAoSoA &amp;dst, const SrcAoSoA &amp;src, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; DstAoSoA &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:a1932d2c9be351d64dfcb6e2d22fc68c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy data between compatible <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> objects.  <br /></td></tr>
<tr class="separator:a1932d2c9be351d64dfcb6e2d22fc68c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282d00b9649753ef39fef91b8c73141c" id="r_a282d00b9649753ef39fef91b8c73141c"><td class="memTemplParams" colspan="2">template&lt;class DstMemorySpace , class SrcMemorySpace , int VectorLength, class... FieldTags&gt; </td></tr>
<tr class="memitem:a282d00b9649753ef39fef91b8c73141c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a282d00b9649753ef39fef91b8c73141c">deep_copy</a> (<a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; DstMemorySpace, VectorLength, FieldTags... &gt; &amp;dst, const <a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; SrcMemorySpace, VectorLength, FieldTags... &gt; &amp;src)</td></tr>
<tr class="memdesc:a282d00b9649753ef39fef91b8c73141c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy data between compatible <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> objects.  <br /></td></tr>
<tr class="separator:a282d00b9649753ef39fef91b8c73141c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f82fe027dec446d5ff114b36e2a30be" id="r_a0f82fe027dec446d5ff114b36e2a30be"><td class="memTemplParams" colspan="2">template&lt;class AoSoA_t &gt; </td></tr>
<tr class="memitem:a0f82fe027dec446d5ff114b36e2a30be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a0f82fe027dec446d5ff114b36e2a30be">deep_copy</a> (AoSoA_t &amp;aosoa, const typename AoSoA_t::tuple_type &amp;tuple)</td></tr>
<tr class="memdesc:a0f82fe027dec446d5ff114b36e2a30be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> with a tuple.  <br /></td></tr>
<tr class="separator:a0f82fe027dec446d5ff114b36e2a30be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c2588c68205d46f36b60be2afff96e" id="r_ab6c2588c68205d46f36b60be2afff96e"><td class="memTemplParams" colspan="2">template&lt;class DstSlice , class SrcSlice &gt; </td></tr>
<tr class="memitem:ab6c2588c68205d46f36b60be2afff96e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab6c2588c68205d46f36b60be2afff96e">deep_copy</a> (DstSlice &amp;dst, const SrcSlice &amp;src, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; DstSlice &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SrcSlice &gt;::value)&gt;::type *=0)</td></tr>
<tr class="memdesc:ab6c2588c68205d46f36b60be2afff96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy data between compatible <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> objects.  <br /></td></tr>
<tr class="separator:ab6c2588c68205d46f36b60be2afff96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae209c92053381625d4d040bb1f74682b" id="r_ae209c92053381625d4d040bb1f74682b"><td class="memTemplParams" colspan="2">template&lt;class Slice_t &gt; </td></tr>
<tr class="memitem:ae209c92053381625d4d040bb1f74682b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ae209c92053381625d4d040bb1f74682b">deep_copy</a> (Slice_t &amp;<a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, const typename Slice_t::value_type scalar)</td></tr>
<tr class="memdesc:ae209c92053381625d4d040bb1f74682b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a slice with a scalar.  <br /></td></tr>
<tr class="separator:ae209c92053381625d4d040bb1f74682b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cf6454bb46dba9eaebb258b8e8159c" id="r_a32cf6454bb46dba9eaebb258b8e8159c"><td class="memTemplParams" colspan="2">template&lt;class DstMemorySpace , class SrcMemorySpace , int VectorLength, class... FieldTags&gt; </td></tr>
<tr class="memitem:a32cf6454bb46dba9eaebb258b8e8159c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a32cf6454bb46dba9eaebb258b8e8159c">create_mirror_view_and_copy</a> (DstMemorySpace, <a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; SrcMemorySpace, VectorLength, FieldTags... &gt; plist_src, typename std::enable_if&lt; std::is_same&lt; SrcMemorySpace, DstMemorySpace &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a32cf6454bb46dba9eaebb258b8e8159c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror of the given <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> in the given memory space.  <br /></td></tr>
<tr class="separator:a32cf6454bb46dba9eaebb258b8e8159c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad31a14a5dc06156d369960c5834574" id="r_adad31a14a5dc06156d369960c5834574"><td class="memTemplParams" colspan="2">template&lt;class DstMemorySpace , class SrcMemorySpace , int VectorLength, class... FieldTags&gt; </td></tr>
<tr class="memitem:adad31a14a5dc06156d369960c5834574"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#adad31a14a5dc06156d369960c5834574">create_mirror_view_and_copy</a> (DstMemorySpace, <a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; SrcMemorySpace, VectorLength, FieldTags... &gt; plist_src, typename std::enable_if&lt; !std::is_same&lt; SrcMemorySpace, DstMemorySpace &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:adad31a14a5dc06156d369960c5834574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mirror of the given <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> in the given memory space.  <br /></td></tr>
<tr class="separator:adad31a14a5dc06156d369960c5834574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a83e23020e924fb010e2f5c20dbcc76" id="r_a7a83e23020e924fb010e2f5c20dbcc76"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class Distributor_t , class AoSoA_t &gt; </td></tr>
<tr class="memitem:a7a83e23020e924fb010e2f5c20dbcc76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a7a83e23020e924fb010e2f5c20dbcc76">migrate</a> (ExecutionSpace exec_space, const Distributor_t &amp;distributor, const AoSoA_t &amp;src, AoSoA_t &amp;dst, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a7a83e23020e924fb010e2f5c20dbcc76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. Multiple <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version.  <br /></td></tr>
<tr class="separator:a7a83e23020e924fb010e2f5c20dbcc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb10ac278624d871f6079c4e24ccb219" id="r_adb10ac278624d871f6079c4e24ccb219"><td class="memTemplParams" colspan="2">template&lt;class Distributor_t , class AoSoA_t &gt; </td></tr>
<tr class="memitem:adb10ac278624d871f6079c4e24ccb219"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#adb10ac278624d871f6079c4e24ccb219">migrate</a> (const Distributor_t &amp;distributor, const AoSoA_t &amp;src, AoSoA_t &amp;dst, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:adb10ac278624d871f6079c4e24ccb219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. Multiple <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version.  <br /></td></tr>
<tr class="separator:adb10ac278624d871f6079c4e24ccb219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b49b38dd2be95b2b905698d063a0736" id="r_a4b49b38dd2be95b2b905698d063a0736"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class Distributor_t , class AoSoA_t &gt; </td></tr>
<tr class="memitem:a4b49b38dd2be95b2b905698d063a0736"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a4b49b38dd2be95b2b905698d063a0736">migrate</a> (ExecutionSpace exec_space, const Distributor_t &amp;distributor, AoSoA_t &amp;aosoa, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a4b49b38dd2be95b2b905698d063a0736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. Single <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version that will resize in-place. Note that resizing does not necessarily allocate more memory. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> memory will only increase if not enough has already been reserved/allocated for the needed number of elements.  <br /></td></tr>
<tr class="separator:a4b49b38dd2be95b2b905698d063a0736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cb44110c8a6215d2ca62406e8aed35" id="r_ab9cb44110c8a6215d2ca62406e8aed35"><td class="memTemplParams" colspan="2">template&lt;class Distributor_t , class AoSoA_t &gt; </td></tr>
<tr class="memitem:ab9cb44110c8a6215d2ca62406e8aed35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab9cb44110c8a6215d2ca62406e8aed35">migrate</a> (const Distributor_t &amp;distributor, AoSoA_t &amp;aosoa, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ab9cb44110c8a6215d2ca62406e8aed35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. Single <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version that will resize in-place. Note that resizing does not necessarily allocate more memory. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> memory will only increase if not enough has already been reserved/allocated for the needed number of elements.  <br /></td></tr>
<tr class="separator:ab9cb44110c8a6215d2ca62406e8aed35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34db3aa66674d749b54de31d8c2590e9" id="r_a34db3aa66674d749b54de31d8c2590e9"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class Distributor_t , class Slice_t &gt; </td></tr>
<tr class="memitem:a34db3aa66674d749b54de31d8c2590e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a34db3aa66674d749b54de31d8c2590e9">migrate</a> (ExecutionSpace, const Distributor_t &amp;distributor, const Slice_t &amp;src, Slice_t &amp;dst, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a34db3aa66674d749b54de31d8c2590e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. The user can do this in-place with the same slice but they will need to manage the resizing themselves as we can't resize slices.  <br /></td></tr>
<tr class="separator:a34db3aa66674d749b54de31d8c2590e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82063f55f2d0c3d17d11ba6642fb7353" id="r_a82063f55f2d0c3d17d11ba6642fb7353"><td class="memTemplParams" colspan="2">template&lt;class Distributor_t , class Slice_t &gt; </td></tr>
<tr class="memitem:a82063f55f2d0c3d17d11ba6642fb7353"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a82063f55f2d0c3d17d11ba6642fb7353">migrate</a> (const Distributor_t &amp;distributor, const Slice_t &amp;src, Slice_t &amp;dst, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a82063f55f2d0c3d17d11ba6642fb7353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously migrate data between two different decompositions using the distributor forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. The user can do this in-place with the same slice but they will need to manage the resizing themselves as we can't resize slices.  <br /></td></tr>
<tr class="separator:a82063f55f2d0c3d17d11ba6642fb7353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45fca0815618ea3fe95fcf688f38dc6" id="r_ad45fca0815618ea3fe95fcf688f38dc6"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classCabana_1_1Halo.html">Halo</a> , class ParticleData &gt; </td></tr>
<tr class="memitem:ad45fca0815618ea3fe95fcf688f38dc6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ad45fca0815618ea3fe95fcf688f38dc6">haloCheckValidSize</a> (const <a class="el" href="classCabana_1_1Halo.html">Halo</a> &amp;halo, const ParticleData &amp;particles, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; <a class="el" href="classCabana_1_1Halo.html">Halo</a> &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ad45fca0815618ea3fe95fcf688f38dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure the particle size matches the total halo (local and ghost) size.  <br /></td></tr>
<tr class="separator:ad45fca0815618ea3fe95fcf688f38dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe4862a55c2c1e611de4447db7cbedb" id="r_acfe4862a55c2c1e611de4447db7cbedb"><td class="memTemplParams" colspan="2">template&lt;class HaloType , class ParticleDataType &gt; </td></tr>
<tr class="memitem:acfe4862a55c2c1e611de4447db7cbedb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#acfe4862a55c2c1e611de4447db7cbedb">createGather</a> (const HaloType &amp;halo, const ParticleDataType &amp;data, const double overallocation=1.0)</td></tr>
<tr class="memdesc:acfe4862a55c2c1e611de4447db7cbedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the gather.  <br /></td></tr>
<tr class="separator:acfe4862a55c2c1e611de4447db7cbedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75770ffe2209e474ae14436511d6b326" id="r_a75770ffe2209e474ae14436511d6b326"><td class="memTemplParams" colspan="2">template&lt;class HaloType , class ParticleDataType &gt; </td></tr>
<tr class="memitem:a75770ffe2209e474ae14436511d6b326"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a75770ffe2209e474ae14436511d6b326">gather</a> (const HaloType &amp;halo, ParticleDataType &amp;data)</td></tr>
<tr class="memdesc:a75770ffe2209e474ae14436511d6b326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. This is a uniquely-owned to multiply-owned communication.  <br /></td></tr>
<tr class="separator:a75770ffe2209e474ae14436511d6b326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc228ac6b568dd1c43f84dee0093b3fd" id="r_abc228ac6b568dd1c43f84dee0093b3fd"><td class="memTemplParams" colspan="2">template&lt;class HaloType , class SliceType &gt; </td></tr>
<tr class="memitem:abc228ac6b568dd1c43f84dee0093b3fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#abc228ac6b568dd1c43f84dee0093b3fd">createScatter</a> (const HaloType &amp;halo, const SliceType &amp;<a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, const double overallocation=1.0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; HaloType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:abc228ac6b568dd1c43f84dee0093b3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the scatter.  <br /></td></tr>
<tr class="separator:abc228ac6b568dd1c43f84dee0093b3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8eb6aa8da865a5ff9c1a86f1ba0a281" id="r_aa8eb6aa8da865a5ff9c1a86f1ba0a281"><td class="memTemplParams" colspan="2">template&lt;class HaloType , class SliceType &gt; </td></tr>
<tr class="memitem:aa8eb6aa8da865a5ff9c1a86f1ba0a281"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#aa8eb6aa8da865a5ff9c1a86f1ba0a281">scatter</a> (const HaloType &amp;halo, SliceType &amp;<a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; HaloType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:aa8eb6aa8da865a5ff9c1a86f1ba0a281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously scatter data from the ghosts to the local decomposition of a slice using the halo reverse communication plan. This is a multiply-owned to uniquely owned communication.  <br /></td></tr>
<tr class="separator:aa8eb6aa8da865a5ff9c1a86f1ba0a281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c3a57c3cd27a75094bbfa1be56145b" id="r_a02c3a57c3cd27a75094bbfa1be56145b"><td class="memTemplParams" colspan="2">template&lt;class LinkedCellListType , class AoSoA_t &gt; </td></tr>
<tr class="memitem:a02c3a57c3cd27a75094bbfa1be56145b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a02c3a57c3cd27a75094bbfa1be56145b">permute</a> (const LinkedCellListType &amp;linked_cell_list, AoSoA_t &amp;aosoa, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellListType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a02c3a57c3cd27a75094bbfa1be56145b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a linked cell list permute an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <br /></td></tr>
<tr class="separator:a02c3a57c3cd27a75094bbfa1be56145b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1ce7155c5c1185f46071b20d4dd332" id="r_a5a1ce7155c5c1185f46071b20d4dd332"><td class="memTemplParams" colspan="2">template&lt;class LinkedCellListType , class SliceType &gt; </td></tr>
<tr class="memitem:a5a1ce7155c5c1185f46071b20d4dd332"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a5a1ce7155c5c1185f46071b20d4dd332">permute</a> (const LinkedCellListType &amp;linked_cell_list, SliceType &amp;<a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellListType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a5a1ce7155c5c1185f46071b20d4dd332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a linked cell list permute a slice.  <br /></td></tr>
<tr class="separator:a5a1ce7155c5c1185f46071b20d4dd332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cddd6233e137bfbe2ca4773e565e5d" id="r_a70cddd6233e137bfbe2ca4773e565e5d"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class ListType &gt; </td></tr>
<tr class="memitem:a70cddd6233e137bfbe2ca4773e565e5d"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; int *[2], typename ListType::memory_space &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a70cddd6233e137bfbe2ca4773e565e5d">neighborHistogram</a> (ExecutionSpace exec_space, const std::size_t num_particles, const ListType &amp;list, const int num_bin)</td></tr>
<tr class="memdesc:a70cddd6233e137bfbe2ca4773e565e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a histogram of neighbors per particle.  <br /></td></tr>
<tr class="separator:a70cddd6233e137bfbe2ca4773e565e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dda1a05e595dbec3f4f06e7f878d9e" id="r_ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , int VectorLength, class... ExecParameters&gt; </td></tr>
<tr class="memitem:ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab7dda1a05e595dbec3f4f06e7f878d9e">simd_parallel_for</a> (const <a class="el" href="classCabana_1_1SimdPolicy.html">SimdPolicy</a>&lt; VectorLength, ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a vectorized functor in parallel with a 2d execution policy.  <br /></td></tr>
<tr class="separator:ab7dda1a05e595dbec3f4f06e7f878d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb924882c14a90b695a56065f4106c22" id="r_acb924882c14a90b695a56065f4106c22"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:acb924882c14a90b695a56065f4106c22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#acb924882c14a90b695a56065f4106c22">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:acb924882c14a90b695a56065f4106c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with a thread-local serial loop over particle first neighbors.  <br /></td></tr>
<tr class="separator:acb924882c14a90b695a56065f4106c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10eeaa254bbc26461eadae4d9a0a1598" id="r_a10eeaa254bbc26461eadae4d9a0a1598"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:a10eeaa254bbc26461eadae4d9a0a1598"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a10eeaa254bbc26461eadae4d9a0a1598">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:a10eeaa254bbc26461eadae4d9a0a1598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with thread-local serial loops over particle first and second neighbors.  <br /></td></tr>
<tr class="separator:a10eeaa254bbc26461eadae4d9a0a1598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cb6955452842c7903e86a845329e7c" id="r_ac2cb6955452842c7903e86a845329e7c"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:ac2cb6955452842c7903e86a845329e7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ac2cb6955452842c7903e86a845329e7c">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:ac2cb6955452842c7903e86a845329e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors.  <br /></td></tr>
<tr class="separator:ac2cb6955452842c7903e86a845329e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca1d55078d6cfea288c6cec130ef204" id="r_acca1d55078d6cfea288c6cec130ef204"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:acca1d55078d6cfea288c6cec130ef204"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#acca1d55078d6cfea288c6cec130ef204">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:acca1d55078d6cfea288c6cec130ef204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors and serial loop over second neighbors.  <br /></td></tr>
<tr class="separator:acca1d55078d6cfea288c6cec130ef204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dae9114f1f2ede7f1925a0c73c7639b" id="r_a3dae9114f1f2ede7f1925a0c73c7639b"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:a3dae9114f1f2ede7f1925a0c73c7639b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a3dae9114f1f2ede7f1925a0c73c7639b">neighbor_parallel_for</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a>, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:a3dae9114f1f2ede7f1925a0c73c7639b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors and vector loop parallelism over second neighbors.  <br /></td></tr>
<tr class="separator:a3dae9114f1f2ede7f1925a0c73c7639b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e94d9a9c1af171bdbb8c4362c23aa0" id="r_af7e94d9a9c1af171bdbb8c4362c23aa0"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:af7e94d9a9c1af171bdbb8c4362c23aa0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#af7e94d9a9c1af171bdbb8c4362c23aa0">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:af7e94d9a9c1af171bdbb8c4362c23aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor reduction in parallel according to the execution policy over particles with a thread-local serial loop over particle first neighbors.  <br /></td></tr>
<tr class="separator:af7e94d9a9c1af171bdbb8c4362c23aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949a3b9f4fd10c8f6b05267870eca331" id="r_a949a3b9f4fd10c8f6b05267870eca331"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:a949a3b9f4fd10c8f6b05267870eca331"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a949a3b9f4fd10c8f6b05267870eca331">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:a949a3b9f4fd10c8f6b05267870eca331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor reduction in parallel according to the execution policy over particles with thread-local serial loops over particle first and second neighbors.  <br /></td></tr>
<tr class="separator:a949a3b9f4fd10c8f6b05267870eca331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2295a3434a7b25d87832e522474f91" id="r_abb2295a3434a7b25d87832e522474f91"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:abb2295a3434a7b25d87832e522474f91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#abb2295a3434a7b25d87832e522474f91">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:abb2295a3434a7b25d87832e522474f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors.  <br /></td></tr>
<tr class="separator:abb2295a3434a7b25d87832e522474f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad67e6a4c72546175d974afd501a5fb" id="r_afad67e6a4c72546175d974afd501a5fb"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:afad67e6a4c72546175d974afd501a5fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#afad67e6a4c72546175d974afd501a5fb">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:afad67e6a4c72546175d974afd501a5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors and serial loop over second neighbors.  <br /></td></tr>
<tr class="separator:afad67e6a4c72546175d974afd501a5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd64556212553a3ada775f74735afe30" id="r_afd64556212553a3ada775f74735afe30"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </td></tr>
<tr class="memitem:afd64556212553a3ada775f74735afe30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#afd64556212553a3ada775f74735afe30">neighbor_parallel_reduce</a> (const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;exec_policy, const FunctorType &amp;functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>, const <a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a>, ReduceType &amp;reduce_val, const std::string &amp;str=&quot;&quot;)</td></tr>
<tr class="memdesc:afd64556212553a3ada775f74735afe30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors and vector loop parallelism over second neighbors.  <br /></td></tr>
<tr class="separator:afd64556212553a3ada775f74735afe30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15dca4f62c3f1f9cb7a9c869c7ae3486" id="r_a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="memTemplParams" colspan="2">template&lt;class IndexType , class FunctorType , class NeighborListType &gt; </td></tr>
<tr class="memitem:a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a15dca4f62c3f1f9cb7a9c869c7ae3486">for_each_neighbor</a> (const IndexType i, const FunctorType &amp;neighbor_functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>)</td></tr>
<tr class="memdesc:a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute functor in serial within existing parallel kernel over particle first neighbors.  <br /></td></tr>
<tr class="separator:a15dca4f62c3f1f9cb7a9c869c7ae3486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366034424ecf96ad51645694c2d71676" id="r_a366034424ecf96ad51645694c2d71676"><td class="memTemplParams" colspan="2">template&lt;class IndexType , class FunctorType , class NeighborListType , class TeamMemberType &gt; </td></tr>
<tr class="memitem:a366034424ecf96ad51645694c2d71676"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a366034424ecf96ad51645694c2d71676">for_each_neighbor</a> (const IndexType i, const TeamMemberType team, const FunctorType &amp;neighbor_functor, const NeighborListType &amp;list, const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>)</td></tr>
<tr class="memdesc:a366034424ecf96ad51645694c2d71676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute team parallel functor within existing parallel kernel over particle first neighbors.  <br /></td></tr>
<tr class="separator:a366034424ecf96ad51645694c2d71676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4f420020f1eb963c2012491a90d259" id="r_adb4f420020f1eb963c2012491a90d259"><td class="memTemplParams" colspan="2"><a id="adb4f420020f1eb963c2012491a90d259" name="adb4f420020f1eb963c2012491a90d259"></a>
template&lt;std::size_t N, class ParameterPack_t &gt; </td></tr>
<tr class="memitem:adb4f420020f1eb963c2012491a90d259"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__parameter__pack.html">is_parameter_pack</a>&lt; ParameterPack_t &gt;::value, typenameParameterPack_t::templatevalue_type&lt; N &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (ParameterPack_t &amp;pp)</td></tr>
<tr class="memdesc:adb4f420020f1eb963c2012491a90d259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an element from a parameter pack. <br /></td></tr>
<tr class="separator:adb4f420020f1eb963c2012491a90d259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14251895a18c9d8412d0c06857190d38" id="r_a14251895a18c9d8412d0c06857190d38"><td class="memTemplParams" colspan="2"><a id="a14251895a18c9d8412d0c06857190d38" name="a14251895a18c9d8412d0c06857190d38"></a>
template&lt;std::size_t N, class ParameterPack_t &gt; </td></tr>
<tr class="memitem:a14251895a18c9d8412d0c06857190d38"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__parameter__pack.html">is_parameter_pack</a>&lt; ParameterPack_t &gt;::value, consttypenameParameterPack_t::templatevalue_type&lt; N &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const ParameterPack_t &amp;pp)</td></tr>
<tr class="memdesc:a14251895a18c9d8412d0c06857190d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an element from a parameter pack. <br /></td></tr>
<tr class="separator:a14251895a18c9d8412d0c06857190d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1bdb5946e4dfb5f96695e6cee6484d" id="r_a6b1bdb5946e4dfb5f96695e6cee6484d"><td class="memTemplParams" colspan="2">template&lt;typename ParameterPack_t , typename... Types&gt; </td></tr>
<tr class="memitem:a6b1bdb5946e4dfb5f96695e6cee6484d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a6b1bdb5946e4dfb5f96695e6cee6484d">fillParameterPack</a> (ParameterPack_t &amp;pp, const Types &amp;... ts)</td></tr>
<tr class="separator:a6b1bdb5946e4dfb5f96695e6cee6484d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b83ffcd0599afe7840925786c8ecdc2" id="r_a7b83ffcd0599afe7840925786c8ecdc2"><td class="memTemplParams" colspan="2"><a id="a7b83ffcd0599afe7840925786c8ecdc2" name="a7b83ffcd0599afe7840925786c8ecdc2"></a>
template&lt;typename ParameterPack_t &gt; </td></tr>
<tr class="memitem:a7b83ffcd0599afe7840925786c8ecdc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fillParameterPack</b> (ParameterPack_t &amp;)</td></tr>
<tr class="memdesc:a7b83ffcd0599afe7840925786c8ecdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty case - fill a parameter pack. <br /></td></tr>
<tr class="separator:a7b83ffcd0599afe7840925786c8ecdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaaf4e113887600b1f87d8ca86cb787" id="r_a6eaaf4e113887600b1f87d8ca86cb787"><td class="memTemplParams" colspan="2"><a id="a6eaaf4e113887600b1f87d8ca86cb787" name="a6eaaf4e113887600b1f87d8ca86cb787"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a6eaaf4e113887600b1f87d8ca86cb787"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCabana_1_1ParameterPack.html">ParameterPack</a>&lt; Types... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeParameterPack</b> (const Types &amp;... ts)</td></tr>
<tr class="memdesc:a6eaaf4e113887600b1f87d8ca86cb787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a parameter pack. <br /></td></tr>
<tr class="separator:a6eaaf4e113887600b1f87d8ca86cb787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9c418e8de2a8cc415fca572a44f4ae" id="r_a6a9c418e8de2a8cc415fca572a44f4ae"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class InitFunctor , class ParticleListType , class ArrayType &gt; </td></tr>
<tr class="memitem:a6a9c418e8de2a8cc415fca572a44f4ae"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a6a9c418e8de2a8cc415fca572a44f4ae">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a>, ExecutionSpace exec_space, const InitFunctor &amp;create_functor, ParticleListType &amp;particle_list, const std::size_t num_particles, const ArrayType box_min, const ArrayType box_max, const std::size_t previous_num_particles=0, const bool shrink_to_fit=true, const uint64_t seed=342343901, typename std::enable_if&lt; <a class="el" href="structCabana_1_1is__particle__list.html">is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *=0)</td></tr>
<tr class="memdesc:a6a9c418e8de2a8cc415fca572a44f4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles given an initialization functor.  <br /></td></tr>
<tr class="separator:a6a9c418e8de2a8cc415fca572a44f4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ec5c5bb6dac97cbc833cfafb4dd037" id="r_a24ec5c5bb6dac97cbc833cfafb4dd037"><td class="memTemplParams" colspan="2">template&lt;class InitFunctor , class ParticleListType , class ArrayType &gt; </td></tr>
<tr class="memitem:a24ec5c5bb6dac97cbc833cfafb4dd037"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a24ec5c5bb6dac97cbc833cfafb4dd037">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a> tag, const InitFunctor &amp;create_functor, ParticleListType &amp;particle_list, const std::size_t num_particles, const ArrayType box_min, const ArrayType box_max, const std::size_t previous_num_particles=0, const bool shrink_to_fit=true, const uint64_t seed=342343901)</td></tr>
<tr class="memdesc:a24ec5c5bb6dac97cbc833cfafb4dd037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles given an initialization functor.  <br /></td></tr>
<tr class="separator:a24ec5c5bb6dac97cbc833cfafb4dd037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5974645edaa6d0ab40737c15b26026d" id="r_ae5974645edaa6d0ab40737c15b26026d"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class PositionType , class ArrayType &gt; </td></tr>
<tr class="memitem:ae5974645edaa6d0ab40737c15b26026d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ae5974645edaa6d0ab40737c15b26026d">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a>, ExecutionSpace exec_space, PositionType &amp;positions, const std::size_t num_particles, const ArrayType box_min, const ArrayType box_max, const std::size_t previous_num_particles=0, const uint64_t seed=342343901, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ae5974645edaa6d0ab40737c15b26026d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles.  <br /></td></tr>
<tr class="separator:ae5974645edaa6d0ab40737c15b26026d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af769ed0be27ed435e3c26b52711b8826" id="r_af769ed0be27ed435e3c26b52711b8826"><td class="memTemplParams" colspan="2">template&lt;class PositionType , class ArrayType &gt; </td></tr>
<tr class="memitem:af769ed0be27ed435e3c26b52711b8826"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#af769ed0be27ed435e3c26b52711b8826">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a> tag, PositionType &amp;positions, const std::size_t num_particles, const ArrayType box_min, const ArrayType box_max, const std::size_t previous_num_particles=0, const uint64_t seed=342343901, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:af769ed0be27ed435e3c26b52711b8826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles.  <br /></td></tr>
<tr class="separator:af769ed0be27ed435e3c26b52711b8826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c28984688c3da4922a55dbafee6c55b" id="r_a1c28984688c3da4922a55dbafee6c55b"><td class="memTemplParams" colspan="2"><a id="a1c28984688c3da4922a55dbafee6c55b" name="a1c28984688c3da4922a55dbafee6c55b"></a>
template&lt;class ExecutionSpace , class PositionType &gt; </td></tr>
<tr class="memitem:a1c28984688c3da4922a55dbafee6c55b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createRandomParticles</b> (ExecutionSpace exec_space, PositionType &amp;positions, const std::size_t num_particles, const double box_min, const double box_max)</td></tr>
<tr class="memdesc:a1c28984688c3da4922a55dbafee6c55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random particles. <br /></td></tr>
<tr class="separator:a1c28984688c3da4922a55dbafee6c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab460bf0f1b72014755b0bd79426b9df8" id="r_ab460bf0f1b72014755b0bd79426b9df8"><td class="memTemplParams" colspan="2">template&lt;class PositionType &gt; </td></tr>
<tr class="memitem:ab460bf0f1b72014755b0bd79426b9df8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab460bf0f1b72014755b0bd79426b9df8">createRandomParticles</a> (PositionType &amp;positions, const std::size_t num_particles, const double box_min, const double box_max)</td></tr>
<tr class="separator:ab460bf0f1b72014755b0bd79426b9df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c4bf4f3365c05b7e56452d0dd7b0ff" id="r_ac0c4bf4f3365c05b7e56452d0dd7b0ff"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class InitFunctor , class ParticleListType , class PositionTag , class ArrayType &gt; </td></tr>
<tr class="memitem:ac0c4bf4f3365c05b7e56452d0dd7b0ff"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ac0c4bf4f3365c05b7e56452d0dd7b0ff">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a> tag, ExecutionSpace exec_space, const InitFunctor &amp;create_functor, ParticleListType &amp;particle_list, PositionTag position_tag, const std::size_t num_particles, const double min_dist, const ArrayType box_min, const ArrayType box_max, const std::size_t previous_num_particles=0, const bool shrink_to_fit=true, const uint64_t seed=342343901, typename std::enable_if&lt; <a class="el" href="structCabana_1_1is__particle__list.html">is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *=0)</td></tr>
<tr class="memdesc:ac0c4bf4f3365c05b7e56452d0dd7b0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles with minimum separation.  <br /></td></tr>
<tr class="separator:ac0c4bf4f3365c05b7e56452d0dd7b0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370d939addeb7bb7dc2600f6d793f053" id="r_a370d939addeb7bb7dc2600f6d793f053"><td class="memTemplParams" colspan="2">template&lt;class InitFunctor , class ParticleListType , class PositionTag , class ArrayType &gt; </td></tr>
<tr class="memitem:a370d939addeb7bb7dc2600f6d793f053"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a370d939addeb7bb7dc2600f6d793f053">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a> tag, const InitFunctor &amp;create_functor, ParticleListType &amp;particle_list, PositionTag position_tag, const std::size_t num_particles, const double min_dist, const ArrayType box_min, const ArrayType box_max, const std::size_t previous_num_particles=0, const bool shrink_to_fit=true, const uint64_t seed=342343901)</td></tr>
<tr class="memdesc:a370d939addeb7bb7dc2600f6d793f053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles with minimum separation.  <br /></td></tr>
<tr class="separator:a370d939addeb7bb7dc2600f6d793f053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0ca04a76c59609d5f9985bc5f0f87d" id="r_a9f0ca04a76c59609d5f9985bc5f0f87d"><td class="memTemplParams" colspan="2">template&lt;class PositionType &gt; </td></tr>
<tr class="memitem:a9f0ca04a76c59609d5f9985bc5f0f87d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a9f0ca04a76c59609d5f9985bc5f0f87d">createRandomParticlesMinDistance</a> (PositionType &amp;positions, const std::size_t num_particles, const double box_min, const double box_max, const double min_dist)</td></tr>
<tr class="memdesc:a9f0ca04a76c59609d5f9985bc5f0f87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random particles with minimum distance between neighbors.  <br /></td></tr>
<tr class="separator:a9f0ca04a76c59609d5f9985bc5f0f87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9bf6af7ca442f63d15778373064c34" id="r_abb9bf6af7ca442f63d15778373064c34"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class PositionType &gt; </td></tr>
<tr class="memitem:abb9bf6af7ca442f63d15778373064c34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#abb9bf6af7ca442f63d15778373064c34">createRandomParticlesMinDistance</a> (ExecutionSpace exec_space, PositionType &amp;positions, const std::size_t num_particles, const double box_min, const double box_max, const double min_dist)</td></tr>
<tr class="memdesc:abb9bf6af7ca442f63d15778373064c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random particles with minimum distance between neighbors.  <br /></td></tr>
<tr class="separator:abb9bf6af7ca442f63d15778373064c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c67163e307376c05b8136c34e98c65" id="r_a62c67163e307376c05b8136c34e98c65"><td class="memTemplParams" colspan="2"><a id="a62c67163e307376c05b8136c34e98c65" name="a62c67163e307376c05b8136c34e98c65"></a>
template&lt;class FieldTag , class... FieldTags, class... IndexTypes&gt; </td></tr>
<tr class="memitem:a62c67163e307376c05b8136c34e98c65"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; sizeof...(IndexTypes)==FieldTag::rank, typenameParticle&lt; FieldTags... &gt;::tuple_type::templatemember_const_reference_type&lt; <a class="el" href="structCabana_1_1TypeIndexer.html">TypeIndexer</a>&lt; FieldTag, FieldTags... &gt;::index &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="structCabana_1_1Particle.html">Particle</a>&lt; FieldTags... &gt; &amp;particle, FieldTag, IndexTypes... indices)</td></tr>
<tr class="memdesc:a62c67163e307376c05b8136c34e98c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a single element of a single field from indices. <br /></td></tr>
<tr class="separator:a62c67163e307376c05b8136c34e98c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ea7024be0d46c66d9b7dada37dd67f" id="r_a65ea7024be0d46c66d9b7dada37dd67f"><td class="memTemplParams" colspan="2"><a id="a65ea7024be0d46c66d9b7dada37dd67f" name="a65ea7024be0d46c66d9b7dada37dd67f"></a>
template&lt;class FieldTag , class... FieldTags, class... IndexTypes&gt; </td></tr>
<tr class="memitem:a65ea7024be0d46c66d9b7dada37dd67f"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; sizeof...(IndexTypes)==FieldTag::rank, typenameParticle&lt; FieldTags... &gt;::tuple_type::templatemember_reference_type&lt; <a class="el" href="structCabana_1_1TypeIndexer.html">TypeIndexer</a>&lt; FieldTag, FieldTags... &gt;::index &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="structCabana_1_1Particle.html">Particle</a>&lt; FieldTags... &gt; &amp;particle, FieldTag, IndexTypes... indices)</td></tr>
<tr class="memdesc:a65ea7024be0d46c66d9b7dada37dd67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a single element of a single field from indices. <br /></td></tr>
<tr class="separator:a65ea7024be0d46c66d9b7dada37dd67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c63d17c98d8be087c36aa47fd0bc76" id="r_ad3c63d17c98d8be087c36aa47fd0bc76"><td class="memTemplParams" colspan="2"><a id="ad3c63d17c98d8be087c36aa47fd0bc76" name="ad3c63d17c98d8be087c36aa47fd0bc76"></a>
template&lt;class FieldTag , class... FieldTags, class... IndexTypes, int VectorLength&gt; </td></tr>
<tr class="memitem:ad3c63d17c98d8be087c36aa47fd0bc76"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; sizeof...(IndexTypes)==FieldTag::rank, typenameParticleView&lt; VectorLength, FieldTags... &gt;::soa_type::templatemember_const_reference_type&lt; <a class="el" href="structCabana_1_1TypeIndexer.html">TypeIndexer</a>&lt; FieldTag, FieldTags... &gt;::index &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="structCabana_1_1ParticleView.html">ParticleView</a>&lt; VectorLength, FieldTags... &gt; &amp;particle, FieldTag, IndexTypes... indices)</td></tr>
<tr class="memdesc:ad3c63d17c98d8be087c36aa47fd0bc76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a single element of a single field from indices. <br /></td></tr>
<tr class="separator:ad3c63d17c98d8be087c36aa47fd0bc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a6fd2968bf1e1dd4a0c88d8b1846e5" id="r_a68a6fd2968bf1e1dd4a0c88d8b1846e5"><td class="memTemplParams" colspan="2"><a id="a68a6fd2968bf1e1dd4a0c88d8b1846e5" name="a68a6fd2968bf1e1dd4a0c88d8b1846e5"></a>
template&lt;class FieldTag , class... FieldTags, class... IndexTypes, int VectorLength&gt; </td></tr>
<tr class="memitem:a68a6fd2968bf1e1dd4a0c88d8b1846e5"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; sizeof...(IndexTypes)==FieldTag::rank, typenameParticleView&lt; VectorLength, FieldTags... &gt;::soa_type::templatemember_reference_type&lt; <a class="el" href="structCabana_1_1TypeIndexer.html">TypeIndexer</a>&lt; FieldTag, FieldTags... &gt;::index &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="structCabana_1_1ParticleView.html">ParticleView</a>&lt; VectorLength, FieldTags... &gt; &amp;particle, FieldTag, IndexTypes... indices)</td></tr>
<tr class="memdesc:a68a6fd2968bf1e1dd4a0c88d8b1846e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a single element of a single field from indices. <br /></td></tr>
<tr class="separator:a68a6fd2968bf1e1dd4a0c88d8b1846e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17482f78ec93101044be7fc5747e9f72" id="r_a17482f78ec93101044be7fc5747e9f72"><td class="memTemplParams" colspan="2">template&lt;class MemorySpace , int VectorLength, class... FieldTags&gt; </td></tr>
<tr class="memitem:a17482f78ec93101044be7fc5747e9f72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a17482f78ec93101044be7fc5747e9f72">createParticleList</a> (const std::string &amp;label, <a class="el" href="structCabana_1_1ParticleTraits.html">ParticleTraits</a>&lt; FieldTags... &gt;)</td></tr>
<tr class="memdesc:a17482f78ec93101044be7fc5747e9f72"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> creation function.  <br /></td></tr>
<tr class="separator:a17482f78ec93101044be7fc5747e9f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbf302d54f1080dc3fbb2fe74f69bdb" id="r_accbf302d54f1080dc3fbb2fe74f69bdb"><td class="memTemplParams" colspan="2">template&lt;class MemorySpace , class... FieldTags&gt; </td></tr>
<tr class="memitem:accbf302d54f1080dc3fbb2fe74f69bdb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#accbf302d54f1080dc3fbb2fe74f69bdb">createParticleList</a> (const std::string &amp;label, <a class="el" href="structCabana_1_1ParticleTraits.html">ParticleTraits</a>&lt; FieldTags... &gt;)</td></tr>
<tr class="memdesc:accbf302d54f1080dc3fbb2fe74f69bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> creation function with default vector length.  <br /></td></tr>
<tr class="separator:accbf302d54f1080dc3fbb2fe74f69bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f062f7dc8d19daf0c5b3830c04c51e" id="r_a55f062f7dc8d19daf0c5b3830c04c51e"><td class="memTemplParams" colspan="2"><a id="a55f062f7dc8d19daf0c5b3830c04c51e" name="a55f062f7dc8d19daf0c5b3830c04c51e"></a>
template&lt;class ExecutionSpace , class ViewType , class SliceType &gt; </td></tr>
<tr class="memitem:a55f062f7dc8d19daf0c5b3830c04c51e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copySliceToView</b> (ExecutionSpace exec_space, ViewType &amp;view, const SliceType &amp;<a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, const std::size_t begin, const std::size_t end, typename std::enable_if&lt; 2==SliceType::kokkos_view::traits::dimension::rank, int * &gt;::type=0)</td></tr>
<tr class="memdesc:a55f062f7dc8d19daf0c5b3830c04c51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from slice to View. Rank-0. <br /></td></tr>
<tr class="separator:a55f062f7dc8d19daf0c5b3830c04c51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39be444dae0eb366bd8f1482ce3a554" id="r_ac39be444dae0eb366bd8f1482ce3a554"><td class="memTemplParams" colspan="2"><a id="ac39be444dae0eb366bd8f1482ce3a554" name="ac39be444dae0eb366bd8f1482ce3a554"></a>
template&lt;class ExecutionSpace , class ViewType , class SliceType &gt; </td></tr>
<tr class="memitem:ac39be444dae0eb366bd8f1482ce3a554"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copySliceToView</b> (ExecutionSpace exec_space, ViewType &amp;view, const SliceType &amp;<a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, const std::size_t begin, const std::size_t end, typename std::enable_if&lt; 3==SliceType::kokkos_view::traits::dimension::rank, int * &gt;::type=0)</td></tr>
<tr class="memdesc:ac39be444dae0eb366bd8f1482ce3a554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from slice to View. Rank-1. <br /></td></tr>
<tr class="separator:ac39be444dae0eb366bd8f1482ce3a554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22dd879aa043dc81e11e15189e407bb" id="r_ac22dd879aa043dc81e11e15189e407bb"><td class="memTemplParams" colspan="2"><a id="ac22dd879aa043dc81e11e15189e407bb" name="ac22dd879aa043dc81e11e15189e407bb"></a>
template&lt;class ExecutionSpace , class ViewType , class SliceType &gt; </td></tr>
<tr class="memitem:ac22dd879aa043dc81e11e15189e407bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copySliceToView</b> (ExecutionSpace exec_space, ViewType &amp;view, const SliceType &amp;<a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, const std::size_t begin, const std::size_t end, typename std::enable_if&lt; 4==SliceType::kokkos_view::traits::dimension::rank, int * &gt;::type=0)</td></tr>
<tr class="memdesc:ac22dd879aa043dc81e11e15189e407bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from slice to View. Rank-2. <br /></td></tr>
<tr class="separator:ac22dd879aa043dc81e11e15189e407bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4351abc308d1deabc7450a5f37d2cad9" id="r_a4351abc308d1deabc7450a5f37d2cad9"><td class="memTemplParams" colspan="2"><a id="a4351abc308d1deabc7450a5f37d2cad9" name="a4351abc308d1deabc7450a5f37d2cad9"></a>
template&lt;class ViewType , class SliceType &gt; </td></tr>
<tr class="memitem:a4351abc308d1deabc7450a5f37d2cad9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copySliceToView</b> (ViewType &amp;view, const SliceType &amp;<a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, const std::size_t begin, const std::size_t end)</td></tr>
<tr class="memdesc:a4351abc308d1deabc7450a5f37d2cad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from slice to View with default execution space. <br /></td></tr>
<tr class="separator:a4351abc308d1deabc7450a5f37d2cad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bc1515cae7d5da7248006fdf113849" id="r_a44bc1515cae7d5da7248006fdf113849"><td class="memTemplParams" colspan="2"><a id="a44bc1515cae7d5da7248006fdf113849" name="a44bc1515cae7d5da7248006fdf113849"></a>
template&lt;class ExecutionSpace , class SliceType , class ViewType &gt; </td></tr>
<tr class="memitem:a44bc1515cae7d5da7248006fdf113849"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copyViewToSlice</b> (ExecutionSpace exec_space, SliceType &amp;<a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, const ViewType &amp;view, const std::size_t begin, const std::size_t end, typename std::enable_if&lt; 2==SliceType::kokkos_view::traits::dimension::rank, int * &gt;::type=0)</td></tr>
<tr class="memdesc:a44bc1515cae7d5da7248006fdf113849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from slice to View. Rank-0. <br /></td></tr>
<tr class="separator:a44bc1515cae7d5da7248006fdf113849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0938a572be03d7c205d58f9e81caf3" id="r_aae0938a572be03d7c205d58f9e81caf3"><td class="memTemplParams" colspan="2"><a id="aae0938a572be03d7c205d58f9e81caf3" name="aae0938a572be03d7c205d58f9e81caf3"></a>
template&lt;class ExecutionSpace , class SliceType , class ViewType &gt; </td></tr>
<tr class="memitem:aae0938a572be03d7c205d58f9e81caf3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copyViewToSlice</b> (ExecutionSpace exec_space, SliceType &amp;<a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, const ViewType &amp;view, const std::size_t begin, const std::size_t end, typename std::enable_if&lt; 3==SliceType::kokkos_view::traits::dimension::rank, int * &gt;::type=0)</td></tr>
<tr class="memdesc:aae0938a572be03d7c205d58f9e81caf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from slice to View. Rank-1. <br /></td></tr>
<tr class="separator:aae0938a572be03d7c205d58f9e81caf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3f27002f8056b1d72b94aa2301ba5e" id="r_aea3f27002f8056b1d72b94aa2301ba5e"><td class="memTemplParams" colspan="2"><a id="aea3f27002f8056b1d72b94aa2301ba5e" name="aea3f27002f8056b1d72b94aa2301ba5e"></a>
template&lt;class ExecutionSpace , class SliceType , class ViewType &gt; </td></tr>
<tr class="memitem:aea3f27002f8056b1d72b94aa2301ba5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copyViewToSlice</b> (ExecutionSpace exec_space, SliceType &amp;<a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, const ViewType &amp;view, const std::size_t begin, const std::size_t end, typename std::enable_if&lt; 4==SliceType::kokkos_view::traits::dimension::rank, int * &gt;::type=0)</td></tr>
<tr class="memdesc:aea3f27002f8056b1d72b94aa2301ba5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from slice to View. Rank-2. <br /></td></tr>
<tr class="separator:aea3f27002f8056b1d72b94aa2301ba5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e71e536095b8fc903bc357a66abd4e" id="r_aa4e71e536095b8fc903bc357a66abd4e"><td class="memTemplParams" colspan="2"><a id="aa4e71e536095b8fc903bc357a66abd4e" name="aa4e71e536095b8fc903bc357a66abd4e"></a>
template&lt;class ViewType , class SliceType &gt; </td></tr>
<tr class="memitem:aa4e71e536095b8fc903bc357a66abd4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copyViewToSlice</b> (ViewType &amp;view, const SliceType &amp;<a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, const std::size_t begin, const std::size_t end)</td></tr>
<tr class="memdesc:aa4e71e536095b8fc903bc357a66abd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from slice to View with default execution space. <br /></td></tr>
<tr class="separator:aa4e71e536095b8fc903bc357a66abd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f231f2743761433164d02ce538341c" id="r_ae0f231f2743761433164d02ce538341c"><td class="memTemplParams" colspan="2"><a id="ae0f231f2743761433164d02ce538341c" name="ae0f231f2743761433164d02ce538341c"></a>
template&lt;class SliceType &gt; </td></tr>
<tr class="memitem:ae0f231f2743761433164d02ce538341c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>checkSize</b> (SliceType <a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, const std::size_t size, typename std::enable_if&lt; <a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value, int &gt;::type *=0)</td></tr>
<tr class="memdesc:ae0f231f2743761433164d02ce538341c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check slice size (differs from Kokkos View). <br /></td></tr>
<tr class="separator:ae0f231f2743761433164d02ce538341c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1950445268d5bdacd831883349a68456" id="r_a1950445268d5bdacd831883349a68456"><td class="memTemplParams" colspan="2"><a id="a1950445268d5bdacd831883349a68456" name="a1950445268d5bdacd831883349a68456"></a>
template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a1950445268d5bdacd831883349a68456"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>checkSize</b> (ViewType view, const std::size_t size, typename std::enable_if&lt; Kokkos::is_view&lt; ViewType &gt;::value, int &gt;::type *=0)</td></tr>
<tr class="memdesc:a1950445268d5bdacd831883349a68456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check View size (differs from <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>). <br /></td></tr>
<tr class="separator:a1950445268d5bdacd831883349a68456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85294bbc93aca84a04e821c0ed46e84e" id="r_a85294bbc93aca84a04e821c0ed46e84e"><td class="memTemplParams" colspan="2"><a id="a85294bbc93aca84a04e821c0ed46e84e" name="a85294bbc93aca84a04e821c0ed46e84e"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a85294bbc93aca84a04e821c0ed46e84e"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (SoA_t &amp;soa, const std::size_t a)</td></tr>
<tr class="memdesc:a85294bbc93aca84a04e821c0ed46e84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-0 non-const. <br /></td></tr>
<tr class="separator:a85294bbc93aca84a04e821c0ed46e84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3357c86eceab49b5c32fd8b0a8f4088f" id="r_a3357c86eceab49b5c32fd8b0a8f4088f"><td class="memTemplParams" colspan="2"><a id="a3357c86eceab49b5c32fd8b0a8f4088f" name="a3357c86eceab49b5c32fd8b0a8f4088f"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a3357c86eceab49b5c32fd8b0a8f4088f"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const SoA_t &amp;soa, const std::size_t a)</td></tr>
<tr class="memdesc:a3357c86eceab49b5c32fd8b0a8f4088f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-0 const. <br /></td></tr>
<tr class="separator:a3357c86eceab49b5c32fd8b0a8f4088f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6d311d8e00835d1f21ccdddacd9ff5" id="r_a7f6d311d8e00835d1f21ccdddacd9ff5"><td class="memTemplParams" colspan="2"><a id="a7f6d311d8e00835d1f21ccdddacd9ff5" name="a7f6d311d8e00835d1f21ccdddacd9ff5"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a7f6d311d8e00835d1f21ccdddacd9ff5"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (SoA_t &amp;soa, const std::size_t a, const std::size_t d0)</td></tr>
<tr class="memdesc:a7f6d311d8e00835d1f21ccdddacd9ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-1 non-const. <br /></td></tr>
<tr class="separator:a7f6d311d8e00835d1f21ccdddacd9ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65cc1ee9d46c3ae289d992aee7ac781" id="r_ab65cc1ee9d46c3ae289d992aee7ac781"><td class="memTemplParams" colspan="2"><a id="ab65cc1ee9d46c3ae289d992aee7ac781" name="ab65cc1ee9d46c3ae289d992aee7ac781"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:ab65cc1ee9d46c3ae289d992aee7ac781"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const SoA_t &amp;soa, const std::size_t a, const std::size_t d0)</td></tr>
<tr class="memdesc:ab65cc1ee9d46c3ae289d992aee7ac781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-1 const. <br /></td></tr>
<tr class="separator:ab65cc1ee9d46c3ae289d992aee7ac781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef903ab252f568a515a36f90170e6a2" id="r_aeef903ab252f568a515a36f90170e6a2"><td class="memTemplParams" colspan="2"><a id="aeef903ab252f568a515a36f90170e6a2" name="aeef903ab252f568a515a36f90170e6a2"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:aeef903ab252f568a515a36f90170e6a2"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="memdesc:aeef903ab252f568a515a36f90170e6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-2 non-const. <br /></td></tr>
<tr class="separator:aeef903ab252f568a515a36f90170e6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5c50ab1cf04c4943457f440b83a890" id="r_a0b5c50ab1cf04c4943457f440b83a890"><td class="memTemplParams" colspan="2"><a id="a0b5c50ab1cf04c4943457f440b83a890" name="a0b5c50ab1cf04c4943457f440b83a890"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a0b5c50ab1cf04c4943457f440b83a890"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="memdesc:a0b5c50ab1cf04c4943457f440b83a890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-2 const. <br /></td></tr>
<tr class="separator:a0b5c50ab1cf04c4943457f440b83a890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ef47d136bbb461cac2ad4a9cb2d18c" id="r_a76ef47d136bbb461cac2ad4a9cb2d18c"><td class="memTemplParams" colspan="2"><a id="a76ef47d136bbb461cac2ad4a9cb2d18c" name="a76ef47d136bbb461cac2ad4a9cb2d18c"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a76ef47d136bbb461cac2ad4a9cb2d18c"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="memdesc:a76ef47d136bbb461cac2ad4a9cb2d18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-3 non-const. <br /></td></tr>
<tr class="separator:a76ef47d136bbb461cac2ad4a9cb2d18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881c500026c8556353cc7a4130f18204" id="r_a881c500026c8556353cc7a4130f18204"><td class="memTemplParams" colspan="2"><a id="a881c500026c8556353cc7a4130f18204" name="a881c500026c8556353cc7a4130f18204"></a>
template&lt;std::size_t M, class SoA_t &gt; </td></tr>
<tr class="memitem:a881c500026c8556353cc7a4130f18204"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__soa.html">is_soa</a>&lt; SoA_t &gt;::value, typenameSoA_t::templatemember_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const SoA_t &amp;soa, const std::size_t a, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="memdesc:a881c500026c8556353cc7a4130f18204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-3 const. <br /></td></tr>
<tr class="separator:a881c500026c8556353cc7a4130f18204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a029626fb67b12cf279b7f3c620159" id="r_ac7a029626fb67b12cf279b7f3c620159"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class Comparator , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:ac7a029626fb67b12cf279b7f3c620159"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ac7a029626fb67b12cf279b7f3c620159">sortByKeyWithComparator</a> (KeyViewType keys, Comparator comp, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ac7a029626fb67b12cf279b7f3c620159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys.  <br /></td></tr>
<tr class="separator:ac7a029626fb67b12cf279b7f3c620159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8376dcbdaa0c3dad87fe19203cf1755" id="r_ac8376dcbdaa0c3dad87fe19203cf1755"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class Comparator , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:ac8376dcbdaa0c3dad87fe19203cf1755"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ac8376dcbdaa0c3dad87fe19203cf1755">sortByKeyWithComparator</a> (KeyViewType keys, Comparator comp, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ac8376dcbdaa0c3dad87fe19203cf1755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys.  <br /></td></tr>
<tr class="separator:ac8376dcbdaa0c3dad87fe19203cf1755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc22b2013d39364f39f91677a589cb8f" id="r_adc22b2013d39364f39f91677a589cb8f"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class Comparator , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:adc22b2013d39364f39f91677a589cb8f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#adc22b2013d39364f39f91677a589cb8f">binByKeyWithComparator</a> (KeyViewType keys, Comparator comp, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:adc22b2013d39364f39f91677a589cb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys.  <br /></td></tr>
<tr class="separator:adc22b2013d39364f39f91677a589cb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e404c2997ca696faff2f84caf97691" id="r_a70e404c2997ca696faff2f84caf97691"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class Comparator , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:a70e404c2997ca696faff2f84caf97691"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a70e404c2997ca696faff2f84caf97691">binByKeyWithComparator</a> (KeyViewType keys, Comparator comp, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a70e404c2997ca696faff2f84caf97691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys.  <br /></td></tr>
<tr class="separator:a70e404c2997ca696faff2f84caf97691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c64ff984d2da99d6ff20d89a8ae9899" id="r_a5c64ff984d2da99d6ff20d89a8ae9899"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:a5c64ff984d2da99d6ff20d89a8ae9899"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a5c64ff984d2da99d6ff20d89a8ae9899">sortByKey</a> (KeyViewType keys, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a5c64ff984d2da99d6ff20d89a8ae9899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values.  <br /></td></tr>
<tr class="separator:a5c64ff984d2da99d6ff20d89a8ae9899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cfa6540c7adf84fb5d3546950c46e6" id="r_a73cfa6540c7adf84fb5d3546950c46e6"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:a73cfa6540c7adf84fb5d3546950c46e6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a73cfa6540c7adf84fb5d3546950c46e6">sortByKey</a> (KeyViewType keys, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a73cfa6540c7adf84fb5d3546950c46e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values.  <br /></td></tr>
<tr class="separator:a73cfa6540c7adf84fb5d3546950c46e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d805b955e236c9c87c50f76c4dde7c" id="r_a07d805b955e236c9c87c50f76c4dde7c"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:a07d805b955e236c9c87c50f76c4dde7c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a07d805b955e236c9c87c50f76c4dde7c">binByKey</a> (KeyViewType keys, const int nbin, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a07d805b955e236c9c87c50f76c4dde7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values and number of bins. The bins are evenly divided over the range of key values.  <br /></td></tr>
<tr class="separator:a07d805b955e236c9c87c50f76c4dde7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefadc00186eb5240413c19ffcc11556b" id="r_aefadc00186eb5240413c19ffcc11556b"><td class="memTemplParams" colspan="2">template&lt;class KeyViewType , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </td></tr>
<tr class="memitem:aefadc00186eb5240413c19ffcc11556b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#aefadc00186eb5240413c19ffcc11556b">binByKey</a> (KeyViewType keys, const int nbin, typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:aefadc00186eb5240413c19ffcc11556b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values and number of bins. The bins are evenly divided over the range of key values.  <br /></td></tr>
<tr class="separator:aefadc00186eb5240413c19ffcc11556b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2577949b8aa884de4873f31efa54401b" id="r_a2577949b8aa884de4873f31efa54401b"><td class="memTemplParams" colspan="2">template&lt;class SliceType , class ExecutionSpace  = typename SliceType::execution_space&gt; </td></tr>
<tr class="memitem:a2577949b8aa884de4873f31efa54401b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a2577949b8aa884de4873f31efa54401b">sortByKey</a> (SliceType <a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a2577949b8aa884de4873f31efa54401b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys.  <br /></td></tr>
<tr class="separator:a2577949b8aa884de4873f31efa54401b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360b0f9c15911bfac904d240e7f369d7" id="r_a360b0f9c15911bfac904d240e7f369d7"><td class="memTemplParams" colspan="2">template&lt;class SliceType , class ExecutionSpace  = typename SliceType::execution_space&gt; </td></tr>
<tr class="memitem:a360b0f9c15911bfac904d240e7f369d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a360b0f9c15911bfac904d240e7f369d7">sortByKey</a> (SliceType <a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a360b0f9c15911bfac904d240e7f369d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys.  <br /></td></tr>
<tr class="separator:a360b0f9c15911bfac904d240e7f369d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb53c51408767f5539610cab2fae20f" id="r_a0bb53c51408767f5539610cab2fae20f"><td class="memTemplParams" colspan="2">template&lt;class SliceType , class ExecutionSpace  = typename SliceType::execution_space&gt; </td></tr>
<tr class="memitem:a0bb53c51408767f5539610cab2fae20f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a0bb53c51408767f5539610cab2fae20f">binByKey</a> (SliceType <a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, const int nbin, const std::size_t begin, const std::size_t end, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a0bb53c51408767f5539610cab2fae20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys.  <br /></td></tr>
<tr class="separator:a0bb53c51408767f5539610cab2fae20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1893b963c55a3dc6612d27999acc71b0" id="r_a1893b963c55a3dc6612d27999acc71b0"><td class="memTemplParams" colspan="2">template&lt;class SliceType , class ExecutionSpace  = typename SliceType::execution_space&gt; </td></tr>
<tr class="memitem:a1893b963c55a3dc6612d27999acc71b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a1893b963c55a3dc6612d27999acc71b0">binByKey</a> (SliceType <a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, const int nbin, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a1893b963c55a3dc6612d27999acc71b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys.  <br /></td></tr>
<tr class="separator:a1893b963c55a3dc6612d27999acc71b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824f296314f00ca8e121e6a26e2846db" id="r_a824f296314f00ca8e121e6a26e2846db"><td class="memTemplParams" colspan="2">template&lt;class BinningDataType , class AoSoA_t , class ExecutionSpace  = typename BinningDataType::execution_space&gt; </td></tr>
<tr class="memitem:a824f296314f00ca8e121e6a26e2846db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#a824f296314f00ca8e121e6a26e2846db">permute</a> (const BinningDataType &amp;binning_data, AoSoA_t &amp;aosoa, typename std::enable_if&lt;(is_binning_data&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a824f296314f00ca8e121e6a26e2846db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given binning data permute an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.  <br /></td></tr>
<tr class="separator:a824f296314f00ca8e121e6a26e2846db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44a65c22331c71ed7cee721a41c54fc" id="r_ab44a65c22331c71ed7cee721a41c54fc"><td class="memTemplParams" colspan="2">template&lt;class BinningDataType , class SliceType , class ExecutionSpace  = typename BinningDataType::execution_space&gt; </td></tr>
<tr class="memitem:ab44a65c22331c71ed7cee721a41c54fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCabana.html#ab44a65c22331c71ed7cee721a41c54fc">permute</a> (const BinningDataType &amp;binning_data, SliceType &amp;<a class="el" href="namespaceCabana.html#aa14f30ab334c57448b204fc9b304289a">slice</a>, typename std::enable_if&lt;(is_binning_data&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ab44a65c22331c71ed7cee721a41c54fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given binning data permute a slice.  <br /></td></tr>
<tr class="separator:ab44a65c22331c71ed7cee721a41c54fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9c5039bd9d6602e2b586eadb908623" id="r_a7e9c5039bd9d6602e2b586eadb908623"><td class="memTemplParams" colspan="2"><a id="a7e9c5039bd9d6602e2b586eadb908623" name="a7e9c5039bd9d6602e2b586eadb908623"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a7e9c5039bd9d6602e2b586eadb908623"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typenameTuple_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (Tuple_t &amp;tp)</td></tr>
<tr class="memdesc:a7e9c5039bd9d6602e2b586eadb908623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-0 non-const. <br /></td></tr>
<tr class="separator:a7e9c5039bd9d6602e2b586eadb908623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a6d3bbad24474f5761de911322cbc4" id="r_ad0a6d3bbad24474f5761de911322cbc4"><td class="memTemplParams" colspan="2"><a id="ad0a6d3bbad24474f5761de911322cbc4" name="ad0a6d3bbad24474f5761de911322cbc4"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:ad0a6d3bbad24474f5761de911322cbc4"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION Tuple_t::template member_const_reference_type&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const Tuple_t &amp;tp)</td></tr>
<tr class="memdesc:ad0a6d3bbad24474f5761de911322cbc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-0 const. <br /></td></tr>
<tr class="separator:ad0a6d3bbad24474f5761de911322cbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d016aef05b4da27fc6c3275eb14a75" id="r_a33d016aef05b4da27fc6c3275eb14a75"><td class="memTemplParams" colspan="2"><a id="a33d016aef05b4da27fc6c3275eb14a75" name="a33d016aef05b4da27fc6c3275eb14a75"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a33d016aef05b4da27fc6c3275eb14a75"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typenameTuple_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (Tuple_t &amp;tp, const std::size_t d0)</td></tr>
<tr class="memdesc:a33d016aef05b4da27fc6c3275eb14a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-1 non-const. <br /></td></tr>
<tr class="separator:a33d016aef05b4da27fc6c3275eb14a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd3fb43c2f7c126d5694273fc5743fc" id="r_a6fd3fb43c2f7c126d5694273fc5743fc"><td class="memTemplParams" colspan="2"><a id="a6fd3fb43c2f7c126d5694273fc5743fc" name="a6fd3fb43c2f7c126d5694273fc5743fc"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a6fd3fb43c2f7c126d5694273fc5743fc"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typenameTuple_t::templatemember_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const Tuple_t &amp;tp, const std::size_t d0)</td></tr>
<tr class="memdesc:a6fd3fb43c2f7c126d5694273fc5743fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-1 const. <br /></td></tr>
<tr class="separator:a6fd3fb43c2f7c126d5694273fc5743fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf89383ed7ae249eb730aebc572b28b1" id="r_abf89383ed7ae249eb730aebc572b28b1"><td class="memTemplParams" colspan="2"><a id="abf89383ed7ae249eb730aebc572b28b1" name="abf89383ed7ae249eb730aebc572b28b1"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:abf89383ed7ae249eb730aebc572b28b1"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typenameTuple_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="memdesc:abf89383ed7ae249eb730aebc572b28b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-2 non-const. <br /></td></tr>
<tr class="separator:abf89383ed7ae249eb730aebc572b28b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45a73b3aba7da567fd0a1e50337c45a" id="r_aa45a73b3aba7da567fd0a1e50337c45a"><td class="memTemplParams" colspan="2"><a id="aa45a73b3aba7da567fd0a1e50337c45a" name="aa45a73b3aba7da567fd0a1e50337c45a"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:aa45a73b3aba7da567fd0a1e50337c45a"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typenameTuple_t::templatemember_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1)</td></tr>
<tr class="memdesc:aa45a73b3aba7da567fd0a1e50337c45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-2 const. <br /></td></tr>
<tr class="separator:aa45a73b3aba7da567fd0a1e50337c45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05881b3162977f27382ec15f3b4cfd89" id="r_a05881b3162977f27382ec15f3b4cfd89"><td class="memTemplParams" colspan="2"><a id="a05881b3162977f27382ec15f3b4cfd89" name="a05881b3162977f27382ec15f3b4cfd89"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:a05881b3162977f27382ec15f3b4cfd89"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typenameTuple_t::templatemember_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="memdesc:a05881b3162977f27382ec15f3b4cfd89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-3 non-const. <br /></td></tr>
<tr class="separator:a05881b3162977f27382ec15f3b4cfd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92e62b3f67a0e4deeb5aff8dcdcfae2" id="r_aa92e62b3f67a0e4deeb5aff8dcdcfae2"><td class="memTemplParams" colspan="2"><a id="aa92e62b3f67a0e4deeb5aff8dcdcfae2" name="aa92e62b3f67a0e4deeb5aff8dcdcfae2"></a>
template&lt;std::size_t M, class Tuple_t &gt; </td></tr>
<tr class="memitem:aa92e62b3f67a0e4deeb5aff8dcdcfae2"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION std::enable_if&lt; <a class="el" href="structCabana_1_1is__tuple.html">is_tuple</a>&lt; Tuple_t &gt;::value, typenameTuple_t::templatemember_const_reference_type&lt; M &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const Tuple_t &amp;tp, const std::size_t d0, const std::size_t d1, const std::size_t d2)</td></tr>
<tr class="memdesc:aa92e62b3f67a0e4deeb5aff8dcdcfae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rank-3 const. <br /></td></tr>
<tr class="separator:aa92e62b3f67a0e4deeb5aff8dcdcfae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f45805f16a42f9f6f048d2e88cd940" id="r_a94f45805f16a42f9f6f048d2e88cd940"><td class="memItemLeft" align="right" valign="top"><a id="a94f45805f16a42f9f6f048d2e88cd940" name="a94f45805f16a42f9f6f048d2e88cd940"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>version</b> ()</td></tr>
<tr class="memdesc:a94f45805f16a42f9f6f048d2e88cd940"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> version. <br /></td></tr>
<tr class="separator:a94f45805f16a42f9f6f048d2e88cd940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad181bcaca8bec0b53a05927aff3120" id="r_afad181bcaca8bec0b53a05927aff3120"><td class="memItemLeft" align="right" valign="top"><a id="afad181bcaca8bec0b53a05927aff3120" name="afad181bcaca8bec0b53a05927aff3120"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>git_commit_hash</b> ()</td></tr>
<tr class="memdesc:afad181bcaca8bec0b53a05927aff3120"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> git hash. <br /></td></tr>
<tr class="separator:afad181bcaca8bec0b53a05927aff3120"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Core: particle data structures and algorithms. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a07d805b955e236c9c87c50f76c4dde7c" name="a07d805b955e236c9c87c50f76c4dde7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d805b955e236c9c87c50f76c4dde7c">&#9670;&#160;</a></span>binByKey() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values and number of bins. The bins are evenly divided over the range of key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins. </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin. </td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="aefadc00186eb5240413c19ffcc11556b" name="aefadc00186eb5240413c19ffcc11556b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefadc00186eb5240413c19ffcc11556b">&#9670;&#160;</a></span>binByKey() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values and number of bins. The bins are evenly divided over the range of key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="a0bb53c51408767f5539610cab2fae20f" name="a0bb53c51408767f5539610cab2fae20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb53c51408767f5539610cab2fae20f">&#9670;&#160;</a></span>binByKey() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType , class ExecutionSpace  = typename SliceType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys. </td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins. </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin. </td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="a1893b963c55a3dc6612d27999acc71b0" name="a1893b963c55a3dc6612d27999acc71b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1893b963c55a3dc6612d27999acc71b0">&#9670;&#160;</a></span>binByKey() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType , class ExecutionSpace  = typename SliceType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::binByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys. </td></tr>
    <tr><td class="paramname">nbin</td><td>The number of bins to use for binning. The range of key values will subdivided equally by the number of bins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="adc22b2013d39364f39f91677a589cb8f" name="adc22b2013d39364f39f91677a589cb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc22b2013d39364f39f91677a589cb8f">&#9670;&#160;</a></span>binByKeyWithComparator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class Comparator , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::binByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys. </td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for binning. Must be compatible with Kokkos::BinSort. </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin. </td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to bin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="a70e404c2997ca696faff2f84caf97691" name="a70e404c2997ca696faff2f84caf97691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e404c2997ca696faff2f84caf97691">&#9670;&#160;</a></span>binByKeyWithComparator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class Comparator , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::binByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bin an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for binning. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for binning. Must be compatible with Kokkos::BinSort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binning data (e.g. bin sizes and offsets). </dd></dl>

</div>
</div>
<a id="a0dbb88343c498a5e729ed54e4e845971" name="a0dbb88343c498a5e729ed54e4e845971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbb88343c498a5e729ed54e4e845971">&#9670;&#160;</a></span>create_mirror()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt; Cabana::create_mirror </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a mirror of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given space. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the new space. </dd></dl>

</div>
</div>
<a id="a682f288aa48e84e44856d1a0b2239b43" name="a682f288aa48e84e44856d1a0b2239b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682f288aa48e84e44856d1a0b2239b43">&#9670;&#160;</a></span>create_mirror_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SrcAoSoA Cabana::create_mirror_view </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given space. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="a72b0a5aebc7bad1d55552382aa1cd853" name="a72b0a5aebc7bad1d55552382aa1cd853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b0a5aebc7bad1d55552382aa1cd853">&#9670;&#160;</a></span>create_mirror_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt; Cabana::create_mirror_view </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the new space.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="abe27556a6136fe14b11c7c2f943aa63c" name="abe27556a6136fe14b11c7c2f943aa63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe27556a6136fe14b11c7c2f943aa63c">&#9670;&#160;</a></span>create_mirror_view_and_copy() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SrcAoSoA Cabana::create_mirror_view_and_copy </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror view of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and copy the contents of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. Same space specialization returns the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="a3e2750b69be547c4aa520c3ac6c1d033" name="a3e2750b69be547c4aa520c3ac6c1d033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2750b69be547c4aa520c3ac6c1d033">&#9670;&#160;</a></span>create_mirror_view_and_copy() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Space , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; typename SrcAoSoA::member_types, Space, SrcAoSoA::vector_length &gt; Cabana::create_mirror_view_and_copy </td>
          <td>(</td>
          <td class="paramtype">const Space &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(!std::is_same&lt; typename SrcAoSoA::memory_space, typename Space::memory_space &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mirror of the given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> in the given memory space and deep copy the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> into the mirror. Different space specialization allocates a new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> and performs the deep copy. </p>
<dl class="section return"><dt>Returns</dt><dd>The new <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> (e.g. a view of that <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) is returned. </dd></dl>

</div>
</div>
<a id="adad31a14a5dc06156d369960c5834574" name="adad31a14a5dc06156d369960c5834574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad31a14a5dc06156d369960c5834574">&#9670;&#160;</a></span>create_mirror_view_and_copy() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DstMemorySpace , class SrcMemorySpace , int VectorLength, class... FieldTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::create_mirror_view_and_copy </td>
          <td>(</td>
          <td class="paramtype">DstMemorySpace&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; SrcMemorySpace, VectorLength, FieldTags... &gt;&#160;</td>
          <td class="paramname"><em>plist_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; !std::is_same&lt; SrcMemorySpace, DstMemorySpace &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mirror of the given <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> in the given memory space. </p>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> is returned. </dd></dl>

</div>
</div>
<a id="a32cf6454bb46dba9eaebb258b8e8159c" name="a32cf6454bb46dba9eaebb258b8e8159c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cf6454bb46dba9eaebb258b8e8159c">&#9670;&#160;</a></span>create_mirror_view_and_copy() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DstMemorySpace , class SrcMemorySpace , int VectorLength, class... FieldTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::create_mirror_view_and_copy </td>
          <td>(</td>
          <td class="paramtype">DstMemorySpace&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; SrcMemorySpace, VectorLength, FieldTags... &gt;&#160;</td>
          <td class="paramname"><em>plist_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_same&lt; SrcMemorySpace, DstMemorySpace &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mirror of the given <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> in the given memory space. </p>
<dl class="section note"><dt>Note</dt><dd>Memory allocation will only occur if the requested mirror memory space is different from that of the input <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. If they are the same, the original <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> is returned. </dd></dl>

</div>
</div>
<a id="acfe4862a55c2c1e611de4447db7cbedb" name="acfe4862a55c2c1e611de4447db7cbedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe4862a55c2c1e611de4447db7cbedb">&#9670;&#160;</a></span>createGather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HaloType , class ParticleDataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createGather </td>
          <td>(</td>
          <td class="paramtype">const HaloType &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParticleDataType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>overallocation</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the gather. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo to use for the gather. </td></tr>
    <tr><td class="paramname">data</td><td>The data on which to perform the gather. The slice should have a size equivalent to halo.numGhost() + halo.numLocal(). The locally owned elements are expected to appear first (i.e. in the first halo.numLocal() elements) and the ghosted elements are expected to appear second (i.e. in the next halo.numGhost() elements()). </td></tr>
    <tr><td class="paramname">overallocation</td><td>An optional factor to keep extra space in the buffers to avoid frequent resizing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1Gather.html">Gather</a> </dd></dl>

</div>
</div>
<a id="a17482f78ec93101044be7fc5747e9f72" name="a17482f78ec93101044be7fc5747e9f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17482f78ec93101044be7fc5747e9f72">&#9670;&#160;</a></span>createParticleList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , int VectorLength, class... FieldTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createParticleList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCabana_1_1ParticleTraits.html">ParticleTraits</a>&lt; FieldTags... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> creation function. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> </dd></dl>

</div>
</div>
<a id="accbf302d54f1080dc3fbb2fe74f69bdb" name="accbf302d54f1080dc3fbb2fe74f69bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbf302d54f1080dc3fbb2fe74f69bdb">&#9670;&#160;</a></span>createParticleList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class... FieldTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createParticleList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCabana_1_1ParticleTraits.html">ParticleTraits</a>&lt; FieldTags... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> creation function with default vector length. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> </dd></dl>

</div>
</div>
<a id="a24ec5c5bb6dac97cbc833cfafb4dd037" name="a24ec5c5bb6dac97cbc833cfafb4dd037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ec5c5bb6dac97cbc833cfafb4dd037">&#9670;&#160;</a></span>createParticles() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InitFunctor , class ParticleListType , class ArrayType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InitFunctor &amp;&#160;</td>
          <td class="paramname"><em>create_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleListType &amp;&#160;</td>
          <td class="paramname"><em>particle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&#160;</td>
          <td class="paramname"><em>box_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&#160;</td>
          <td class="paramname"><em>box_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>previous_num_particles</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shrink_to_fit</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>342343901</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles given an initialization functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">create_functor</td><td>A functor which populates a particle given the logical position of a particle. This functor returns true if a particle was created and false if it was not giving the signature: <pre class="fragment">bool createFunctor( const double pid, const double px[3], const double pv,
                    typename ParticleAoSoA::tuple_type&amp; particle );
</pre> </td></tr>
    <tr><td class="paramname">particle_list</td><td>The <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> to populate. This will be filled with particles and resized to a size equal to the number of particles created. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">box_min</td><td>Array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>Array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">shrink_to_fit</td><td>Optionally remove unused allocated space after creation. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of particles created. </dd></dl>

</div>
</div>
<a id="a370d939addeb7bb7dc2600f6d793f053" name="a370d939addeb7bb7dc2600f6d793f053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370d939addeb7bb7dc2600f6d793f053">&#9670;&#160;</a></span>createParticles() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InitFunctor , class ParticleListType , class PositionTag , class ArrayType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InitFunctor &amp;&#160;</td>
          <td class="paramname"><em>create_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleListType &amp;&#160;</td>
          <td class="paramname"><em>particle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionTag&#160;</td>
          <td class="paramname"><em>position_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&#160;</td>
          <td class="paramname"><em>box_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&#160;</td>
          <td class="paramname"><em>box_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>previous_num_particles</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shrink_to_fit</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>342343901</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles with minimum separation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">create_functor</td><td>A functor which populates a particle given the logical position of a particle. This functor returns true if a particle was created and false if it was not giving the signature: <pre class="fragment">bool createFunctor( const double pid, const double px[3], const double pv,
                    typename ParticleAoSoA::tuple_type&amp; particle );
</pre> </td></tr>
    <tr><td class="paramname">particle_list</td><td>The <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> to populate. This will be filled with particles and resized to a size equal to the number of particles created. </td></tr>
    <tr><td class="paramname">position_tag</td><td>Position particle list type tag. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">min_dist</td><td>Minimum separation distance between particles. Potential particles created within this distance of an existing particle are rejected. </td></tr>
    <tr><td class="paramname">box_min</td><td>Array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>Array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">shrink_to_fit</td><td>Optionally remove unused allocated space after creation. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of particles created.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This approximates many physical scenarios, e.g. atomic simulations. </dd></dl>

</div>
</div>
<a id="ac0c4bf4f3365c05b7e56452d0dd7b0ff" name="ac0c4bf4f3365c05b7e56452d0dd7b0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c4bf4f3365c05b7e56452d0dd7b0ff">&#9670;&#160;</a></span>createParticles() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class InitFunctor , class ParticleListType , class PositionTag , class ArrayType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionSpace&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InitFunctor &amp;&#160;</td>
          <td class="paramname"><em>create_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleListType &amp;&#160;</td>
          <td class="paramname"><em>particle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionTag&#160;</td>
          <td class="paramname"><em>position_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&#160;</td>
          <td class="paramname"><em>box_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&#160;</td>
          <td class="paramname"><em>box_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>previous_num_particles</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shrink_to_fit</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>342343901</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structCabana_1_1is__particle__list.html">is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles with minimum separation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">create_functor</td><td>A functor which populates a particle given the logical position of a particle. This functor returns true if a particle was created and false if it was not giving the signature: <pre class="fragment">bool createFunctor( const double pid, const double px[3], const double pv,
                    typename ParticleAoSoA::tuple_type&amp; particle );
</pre> </td></tr>
    <tr><td class="paramname">particle_list</td><td>The <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> to populate. This will be filled with particles and resized to a size equal to the number of particles created. </td></tr>
    <tr><td class="paramname">position_tag</td><td>Position particle list type tag. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">min_dist</td><td>Minimum separation distance between particles. Potential particles created within this distance of an existing particle are rejected. </td></tr>
    <tr><td class="paramname">box_min</td><td>Array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>Array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">shrink_to_fit</td><td>Optionally remove unused allocated space after creation. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of particles created.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This approximates many physical scenarios, e.g. atomic simulations. </dd></dl>

</div>
</div>
<a id="af769ed0be27ed435e3c26b52711b8826" name="af769ed0be27ed435e3c26b52711b8826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af769ed0be27ed435e3c26b52711b8826">&#9670;&#160;</a></span>createParticles() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType , class ArrayType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&#160;</td>
          <td class="paramname"><em>box_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&#160;</td>
          <td class="paramname"><em>box_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>previous_num_particles</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>342343901</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">positions</td><td><a class="el" href="structCabana_1_1Particle.html" title="Single particle copy. Wraps a tuple copy of a particle.">Particle</a> positions slice. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">box_min</td><td>Array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>Array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a9c418e8de2a8cc415fca572a44f4ae" name="a6a9c418e8de2a8cc415fca572a44f4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9c418e8de2a8cc415fca572a44f4ae">&#9670;&#160;</a></span>createParticles() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class InitFunctor , class ParticleListType , class ArrayType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionSpace&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InitFunctor &amp;&#160;</td>
          <td class="paramname"><em>create_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleListType &amp;&#160;</td>
          <td class="paramname"><em>particle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&#160;</td>
          <td class="paramname"><em>box_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&#160;</td>
          <td class="paramname"><em>box_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>previous_num_particles</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shrink_to_fit</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>342343901</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structCabana_1_1is__particle__list.html">is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles given an initialization functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">create_functor</td><td>A functor which populates a particle given the logical position of a particle. This functor returns true if a particle was created and false if it was not giving the signature: <pre class="fragment">bool createFunctor( const double pid, const double px[3], const double pv,
                    typename ParticleAoSoA::tuple_type&amp; particle );
</pre> </td></tr>
    <tr><td class="paramname">particle_list</td><td>The <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> to populate. This will be filled with particles and resized to a size equal to the number of particles created. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">box_min</td><td>Array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>Array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">shrink_to_fit</td><td>Optionally remove unused allocated space after creation. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of particles created. </dd></dl>

</div>
</div>
<a id="ae5974645edaa6d0ab40737c15b26026d" name="ae5974645edaa6d0ab40737c15b26026d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5974645edaa6d0ab40737c15b26026d">&#9670;&#160;</a></span>createParticles() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class PositionType , class ArrayType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">InitRandom</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionSpace&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&#160;</td>
          <td class="paramname"><em>box_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&#160;</td>
          <td class="paramname"><em>box_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>previous_num_particles</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>342343901</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">positions</td><td><a class="el" href="structCabana_1_1Particle.html" title="Single particle copy. Wraps a tuple copy of a particle.">Particle</a> positions slice. </td></tr>
    <tr><td class="paramname">num_particles</td><td>The number of particles to create. </td></tr>
    <tr><td class="paramname">box_min</td><td>Array specifying lower corner to create particles within. </td></tr>
    <tr><td class="paramname">box_max</td><td>Array specifying upper corner to create particles within. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab460bf0f1b72014755b0bd79426b9df8" name="ab460bf0f1b72014755b0bd79426b9df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab460bf0f1b72014755b0bd79426b9df8">&#9670;&#160;</a></span>createRandomParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::createRandomParticles </td>
          <td>(</td>
          <td class="paramtype">PositionType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>box_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>box_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate random particles. Default execution space. </p>

</div>
</div>
<a id="abb9bf6af7ca442f63d15778373064c34" name="abb9bf6af7ca442f63d15778373064c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9bf6af7ca442f63d15778373064c34">&#9670;&#160;</a></span>createRandomParticlesMinDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class PositionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::createRandomParticlesMinDistance </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>box_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>box_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate random particles with minimum distance between neighbors. </p>
<dl class="section note"><dt>Note</dt><dd>This approximates many physical scenarios, e.g. atomic simulations.</dd></dl>
<p>This version will continue sampling until the number of selected particles is created. This can be extremely slow based on the requested box size and minimum separation distance. </p>

</div>
</div>
<a id="a9f0ca04a76c59609d5f9985bc5f0f87d" name="a9f0ca04a76c59609d5f9985bc5f0f87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0ca04a76c59609d5f9985bc5f0f87d">&#9670;&#160;</a></span>createRandomParticlesMinDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::createRandomParticlesMinDistance </td>
          <td>(</td>
          <td class="paramtype">PositionType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>box_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>box_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate random particles with minimum distance between neighbors. </p>
<dl class="section note"><dt>Note</dt><dd>This approximates many physical scenarios, e.g. atomic simulations.</dd>
<dd>
This version will continue sampling until the number of selected particles is created. This can be extremely slow based on the requested box size and minimum separation distance. </dd></dl>

</div>
</div>
<a id="abc228ac6b568dd1c43f84dee0093b3fd" name="abc228ac6b568dd1c43f84dee0093b3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc228ac6b568dd1c43f84dee0093b3fd">&#9670;&#160;</a></span>createScatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HaloType , class SliceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::createScatter </td>
          <td>(</td>
          <td class="paramtype">const HaloType &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SliceType &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>overallocation</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; HaloType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the scatter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo to use for the scatter. </td></tr>
    <tr><td class="paramname">slice</td><td>The slice on which to perform the scatter. The slice should have a size equivalent to halo.numGhost() + halo.numLocal(). The locally owned elements are expected to appear first (i.e. in the first halo.numLocal() elements) and the ghosted elements are expected to appear second (i.e. in the next halo.numGhost() elements()). </td></tr>
    <tr><td class="paramname">overallocation</td><td>An optional factor to keep extra space in the buffers to avoid frequent resizing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1Scatter.html" title="Synchronously scatter data from the ghosts to the local decomposition of a slice using the halo rever...">Scatter</a> </dd></dl>

</div>
</div>
<a id="a0f82fe027dec446d5ff114b36e2a30be" name="a0f82fe027dec446d5ff114b36e2a30be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f82fe027dec446d5ff114b36e2a30be">&#9670;&#160;</a></span>deep_copy() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AoSoA_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AoSoA_t::tuple_type &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> with a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to fill. </td></tr>
    <tr><td class="paramname">tuple</td><td>The tuple to assign. All <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> elements will be assigned this value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1932d2c9be351d64dfcb6e2d22fc68c8" name="a1932d2c9be351d64dfcb6e2d22fc68c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1932d2c9be351d64dfcb6e2d22fc68c8">&#9670;&#160;</a></span>deep_copy() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DstAoSoA , class SrcAoSoA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">DstAoSoA &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcAoSoA &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; DstAoSoA &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; SrcAoSoA &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy data between compatible <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination for the copied data. </td></tr>
    <tr><td class="paramname">src</td><td>The source of the copied data.</td></tr>
  </table>
  </dd>
</dl>
<p>Only <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> objects with the same set of member data types and size may be copied. </p>

</div>
</div>
<a id="ab6c2588c68205d46f36b60be2afff96e" name="ab6c2588c68205d46f36b60be2afff96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c2588c68205d46f36b60be2afff96e">&#9670;&#160;</a></span>deep_copy() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DstSlice , class SrcSlice &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">DstSlice &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcSlice &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; DstSlice &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SrcSlice &gt;::value)&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy data between compatible <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination for the copied data. </td></tr>
    <tr><td class="paramname">src</td><td>The source of the copied data.</td></tr>
  </table>
  </dd>
</dl>
<p>Only <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> objects with the same set of member data types and size may be copied. </p>

</div>
</div>
<a id="a282d00b9649753ef39fef91b8c73141c" name="a282d00b9649753ef39fef91b8c73141c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282d00b9649753ef39fef91b8c73141c">&#9670;&#160;</a></span>deep_copy() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DstMemorySpace , class SrcMemorySpace , int VectorLength, class... FieldTags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; DstMemorySpace, VectorLength, FieldTags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1ParticleList.html">ParticleList</a>&lt; SrcMemorySpace, VectorLength, FieldTags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy data between compatible <a class="el" href="classCabana_1_1ParticleList.html" title="List of particle fields stored in AoSoA.">ParticleList</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination for the copied data. </td></tr>
    <tr><td class="paramname">src</td><td>The source of the copied data. s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae209c92053381625d4d040bb1f74682b" name="ae209c92053381625d4d040bb1f74682b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae209c92053381625d4d040bb1f74682b">&#9670;&#160;</a></span>deep_copy() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Slice_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::deep_copy </td>
          <td>(</td>
          <td class="paramtype">Slice_t &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Slice_t::value_type&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a slice with a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice to fill. </td></tr>
    <tr><td class="paramname">scalar</td><td>The scalar to assign. All slice elements will be assigned this value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b1bdb5946e4dfb5f96695e6cee6484d" name="a6b1bdb5946e4dfb5f96695e6cee6484d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1bdb5946e4dfb5f96695e6cee6484d">&#9670;&#160;</a></span>fillParameterPack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParameterPack_t , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::fillParameterPack </td>
          <td>(</td>
          <td class="paramtype">ParameterPack_t &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types &amp;...&#160;</td>
          <td class="paramname"><em>ts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill a parameter pack. Note the indexing is such that the Nth element of a parameter pack is the Nth element of the tuple. </p>

</div>
</div>
<a id="a15dca4f62c3f1f9cb7a9c869c7ae3486" name="a15dca4f62c3f1f9cb7a9c869c7ae3486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15dca4f62c3f1f9cb7a9c869c7ae3486">&#9670;&#160;</a></span>for_each_neighbor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexType , class FunctorType , class NeighborListType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void Cabana::for_each_neighbor </td>
          <td>(</td>
          <td class="paramtype">const IndexType&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>neighbor_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute functor in serial within existing parallel kernel over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexType</td><td>The particle index type. </td></tr>
    <tr><td class="paramname">FunctorType</td><td>The neighbor functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td><a class="el" href="structCabana_1_1Particle.html" title="Single particle copy. Wraps a tuple copy of a particle.">Particle</a> index. </td></tr>
    <tr><td class="paramname">neighbor_functor</td><td>The neighbor functor to execute in parallel. </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors.</dd></dl>
<p>A "functor" is a class containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for neighbor parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> particle_index, <span class="keyword">const</span> <span class="keywordtype">int</span> neighbor_index ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>Index</code> is a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> index to a given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> element for a particle and its neighbor. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. This compares to a single iteration <code>idx</code> of a <code>for</code> loop. </p>

</div>
</div>
<a id="a366034424ecf96ad51645694c2d71676" name="a366034424ecf96ad51645694c2d71676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366034424ecf96ad51645694c2d71676">&#9670;&#160;</a></span>for_each_neighbor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexType , class FunctorType , class NeighborListType , class TeamMemberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void Cabana::for_each_neighbor </td>
          <td>(</td>
          <td class="paramtype">const IndexType&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TeamMemberType&#160;</td>
          <td class="paramname"><em>team</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>neighbor_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute team parallel functor within existing parallel kernel over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexType</td><td>The particle index type. </td></tr>
    <tr><td class="paramname">FunctorType</td><td>The neighbor functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">TeamMemberType</td><td>Kokkos team policy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td><a class="el" href="structCabana_1_1Particle.html" title="Single particle copy. Wraps a tuple copy of a particle.">Particle</a> index. </td></tr>
    <tr><td class="paramname">team</td><td>Kokkos team. </td></tr>
    <tr><td class="paramname">neighbor_functor</td><td>The neighbor functor to execute in parallel. </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors. </dd></dl>

</div>
</div>
<a id="a75770ffe2209e474ae14436511d6b326" name="a75770ffe2209e474ae14436511d6b326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75770ffe2209e474ae14436511d6b326">&#9670;&#160;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HaloType , class ParticleDataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::gather </td>
          <td>(</td>
          <td class="paramtype">const HaloType &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleDataType &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously gather data from the local decomposition to the ghosts using the halo forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. This is a uniquely-owned to multiply-owned communication. </p>
<dl class="section note"><dt>Note</dt><dd>This routine allocates send and receive buffers internally. This is often not performant due to frequent buffer reallocations - consider creating and reusing <a class="el" href="classCabana_1_1Gather.html">Gather</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo to use for the gather.</td></tr>
    <tr><td class="paramname">data</td><td>The data on which to perform the gather. The slice should have a size equivalent to halo.numGhost() + halo.numLocal(). The locally owned elements are expected to appear first (i.e. in the first halo.numLocal() elements) and the ghosted elements are expected to appear second (i.e. in the next halo.numGhost() elements()). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bb075b5a602fbfea922fd1c190ddc3e" name="a8bb075b5a602fbfea922fd1c190ddc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb075b5a602fbfea922fd1c190ddc3e">&#9670;&#160;</a></span>getUniqueTopology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Cabana::getUniqueTopology </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>topology</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return unique neighbor ranks, with the current rank first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>MPI communicator. </td></tr>
    <tr><td class="paramname">topology</td><td>MPI neighbor ranks in any order with possible duplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unique MPI neighbor ranks, with the current rank first. </dd></dl>

</div>
</div>
<a id="ad45fca0815618ea3fe95fcf688f38dc6" name="ad45fca0815618ea3fe95fcf688f38dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45fca0815618ea3fe95fcf688f38dc6">&#9670;&#160;</a></span>haloCheckValidSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="classCabana_1_1Halo.html">Halo</a> , class ParticleData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Cabana::haloCheckValidSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1Halo.html">Halo</a> &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParticleData &amp;&#160;</td>
          <td class="paramname"><em>particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; <a class="el" href="classCabana_1_1Halo.html">Halo</a> &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure the particle size matches the total halo (local and ghost) size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo that will be used for the gather. Used to query import and export sizes.</td></tr>
    <tr><td class="paramname">particles</td><td>The particle data (either <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> or slice). Used to query the total size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9cb44110c8a6215d2ca62406e8aed35" name="ab9cb44110c8a6215d2ca62406e8aed35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cb44110c8a6215d2ca62406e8aed35">&#9670;&#160;</a></span>migrate() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Distributor_t , class AoSoA_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">const Distributor_t &amp;&#160;</td>
          <td class="paramname"><em>distributor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. Single <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version that will resize in-place. Note that resizing does not necessarily allocate more memory. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> memory will only increase if not enough has already been reserved/allocated for the needed number of elements. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> type - must be a distributor. </td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type - must be an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration. </td></tr>
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> containing the data to be migrated. Upon input, must have the same number of elements as the inputs used to construct the destributor. At output, it will be the same size as th enumber of import elements on this rank provided by the distributor. Before using this function, consider reserving enough memory in the data structure so reallocating is not necessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb10ac278624d871f6079c4e24ccb219" name="adb10ac278624d871f6079c4e24ccb219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb10ac278624d871f6079c4e24ccb219">&#9670;&#160;</a></span>migrate() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Distributor_t , class AoSoA_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">const Distributor_t &amp;&#160;</td>
          <td class="paramname"><em>distributor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. Multiple <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> type - must be a distributor. </td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type - must be an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration. </td></tr>
    <tr><td class="paramname">src</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> containing the data to be migrated. Must have the same number of elements as the inputs used to construct the distributor. </td></tr>
    <tr><td class="paramname">dst</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to which the migrated data will be written. Must be the same size as the number of imports given by the distributor on this rank. Call totalNumImport() on the distributor to get this size value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82063f55f2d0c3d17d11ba6642fb7353" name="a82063f55f2d0c3d17d11ba6642fb7353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82063f55f2d0c3d17d11ba6642fb7353">&#9670;&#160;</a></span>migrate() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Distributor_t , class Slice_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">const Distributor_t &amp;&#160;</td>
          <td class="paramname"><em>distributor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Slice_t &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Slice_t &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. The user can do this in-place with the same slice but they will need to manage the resizing themselves as we can't resize slices. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> type - must be a distributor. </td></tr>
    <tr><td class="paramname">Slice_t</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type - must be an <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration. </td></tr>
    <tr><td class="paramname">src</td><td>The slice containing the data to be migrated. Must have the same number of elements as the inputs used to construct the destributor. </td></tr>
    <tr><td class="paramname">dst</td><td>The slice to which the migrated data will be written. Must be the same size as the number of imports given by the distributor on this rank. Call totalNumImport() on the distributor to get this size value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b49b38dd2be95b2b905698d063a0736" name="a4b49b38dd2be95b2b905698d063a0736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b49b38dd2be95b2b905698d063a0736">&#9670;&#160;</a></span>migrate() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class Distributor_t , class AoSoA_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Distributor_t &amp;&#160;</td>
          <td class="paramname"><em>distributor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. Single <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version that will resize in-place. Note that resizing does not necessarily allocate more memory. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> memory will only increase if not enough has already been reserved/allocated for the needed number of elements. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecutionSpace</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> type - must be a distributor. </td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type - must be an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration. </td></tr>
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> containing the data to be migrated. Upon input, must have the same number of elements as the inputs used to construct the destributor. At output, it will be the same size as th enumber of import elements on this rank provided by the distributor. Before using this function, consider reserving enough memory in the data structure so reallocating is not necessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a83e23020e924fb010e2f5c20dbcc76" name="a7a83e23020e924fb010e2f5c20dbcc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a83e23020e924fb010e2f5c20dbcc76">&#9670;&#160;</a></span>migrate() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class Distributor_t , class AoSoA_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Distributor_t &amp;&#160;</td>
          <td class="paramname"><em>distributor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. Multiple <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> version. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecutionSpace</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> type - must be a distributor. </td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type - must be an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration. </td></tr>
    <tr><td class="paramname">src</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> containing the data to be migrated. Must have the same number of elements as the inputs used to construct the distributor. </td></tr>
    <tr><td class="paramname">dst</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to which the migrated data will be written. Must be the same size as the number of imports given by the distributor on this rank. Call totalNumImport() on the distributor to get this size value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34db3aa66674d749b54de31d8c2590e9" name="a34db3aa66674d749b54de31d8c2590e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34db3aa66674d749b54de31d8c2590e9">&#9670;&#160;</a></span>migrate() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class Distributor_t , class Slice_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::migrate </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Distributor_t &amp;&#160;</td>
          <td class="paramname"><em>distributor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Slice_t &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Slice_t &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__distributor.html">is_distributor</a>&lt; Distributor_t &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; Slice_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously migrate data between two different decompositions using the distributor forward communication plan. <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> version. The user can do this in-place with the same slice but they will need to manage the resizing themselves as we can't resize slices. </p>
<p>Migrate moves all data to a new distribution that is uniquely owned - each element will only have a single destination rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecutionSpace</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">Distributor_t</td><td><a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> type - must be a distributor. </td></tr>
    <tr><td class="paramname">Slice_t</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type - must be an <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distributor</td><td>The distributor to use for the migration. </td></tr>
    <tr><td class="paramname">src</td><td>The slice containing the data to be migrated. Must have the same number of elements as the inputs used to construct the destributor. </td></tr>
    <tr><td class="paramname">dst</td><td>The slice to which the migrated data will be written. Must be the same size as the number of imports given by the distributor on this rank. Call totalNumImport() on the distributor to get this size value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb924882c14a90b695a56065f4106c22" name="acb924882c14a90b695a56065f4106c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb924882c14a90b695a56065f4106c22">&#9670;&#160;</a></span>neighbor_parallel_for() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with a thread-local serial loop over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a> Tag indicating a serial loop strategy over neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes.</td></tr>
  </table>
  </dd>
</dl>
<p>A "functor" is a class containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for neighbor parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> particle_index, <span class="keyword">const</span> <span class="keywordtype">int</span> neighbor_index ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>Index</code> is a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> index to a given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> element for a particle and its neighbor. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. This compares to a single iteration <code>idx</code> of a <code>for</code> loop. </p>

</div>
</div>
<a id="ac2cb6955452842c7903e86a845329e7c" name="ac2cb6955452842c7903e86a845329e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cb6955452842c7903e86a845329e7c">&#9670;&#160;</a></span>neighbor_parallel_for() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a> Tag indicating a team parallel strategy over neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10eeaa254bbc26461eadae4d9a0a1598" name="a10eeaa254bbc26461eadae4d9a0a1598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10eeaa254bbc26461eadae4d9a0a1598">&#9670;&#160;</a></span>neighbor_parallel_for() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with thread-local serial loops over particle first and second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a> Tag indicating operations over particle first and second neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a> Tag indicating a serial loop strategy over neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acca1d55078d6cfea288c6cec130ef204" name="acca1d55078d6cfea288c6cec130ef204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca1d55078d6cfea288c6cec130ef204">&#9670;&#160;</a></span>neighbor_parallel_for() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors and serial loop over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a> Tag indicating operations over particle first and second neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a> Tag indicating a team parallel strategy over particle first neighbors and serial execution over second neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dae9114f1f2ede7f1925a0c73c7639b" name="a3dae9114f1f2ede7f1925a0c73c7639b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dae9114f1f2ede7f1925a0c73c7639b">&#9670;&#160;</a></span>neighbor_parallel_for() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor in parallel according to the execution policy over particles with team parallelism over particle first neighbors and vector loop parallelism over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a> Tag indicating operations over particle first and second neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1TeamVectorOpTag.html" title="Neighbor operations are executed with team vector parallelism.">TeamVectorOpTag</a> Tag indicating a team parallel strategy over particle first neighbors and vector parallel loop strategy over second neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7e94d9a9c1af171bdbb8c4362c23aa0" name="af7e94d9a9c1af171bdbb8c4362c23aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e94d9a9c1af171bdbb8c4362c23aa0">&#9670;&#160;</a></span>neighbor_parallel_reduce() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reduce_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor reduction in parallel according to the execution policy over particles with a thread-local serial loop over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters. </td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a> Tag indicating a serial loop strategy over neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes.</td></tr>
  </table>
  </dd>
</dl>
<p>A "functor" is a class containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for neighbor parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> particle_index, <span class="keyword">const</span> <span class="keywordtype">int</span> neighbor_index ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>Index</code> is a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> index to a given <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> element for a particle and its neighbor. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. This compares to a single iteration <code>idx</code> of a <code>for</code> loop. </p>

</div>
</div>
<a id="abb2295a3434a7b25d87832e522474f91" name="abb2295a3434a7b25d87832e522474f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2295a3434a7b25d87832e522474f91">&#9670;&#160;</a></span>neighbor_parallel_reduce() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1FirstNeighborsTag.html">FirstNeighborsTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reduce_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters. </td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1FirstNeighborsTag.html" title="Loop over particle neighbors.">FirstNeighborsTag</a> Tag indicating operations over particle first neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a> Tag indicating a team parallel strategy over particle neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a949a3b9f4fd10c8f6b05267870eca331" name="a949a3b9f4fd10c8f6b05267870eca331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949a3b9f4fd10c8f6b05267870eca331">&#9670;&#160;</a></span>neighbor_parallel_reduce() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SerialOpTag.html">SerialOpTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reduce_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor reduction in parallel according to the execution policy over particles with thread-local serial loops over particle first and second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters. </td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a> Tag indicating operations over particle first and second neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1SerialOpTag.html" title="Neighbor operations are executed in serial on each particle thread.">SerialOpTag</a> Tag indicating a serial loop strategy over neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afad67e6a4c72546175d974afd501a5fb" name="afad67e6a4c72546175d974afd501a5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad67e6a4c72546175d974afd501a5fb">&#9670;&#160;</a></span>neighbor_parallel_reduce() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1TeamOpTag.html">TeamOpTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reduce_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors and serial loop over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters. </td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a> Tag indicating operations over particle first and second neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1TeamOpTag.html" title="Neighbor operations are executed with team parallelism.">TeamOpTag</a> Tag indicating a team parallel strategy over particle first neighbors and serial loops over second neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd64556212553a3ada775f74735afe30" name="afd64556212553a3ada775f74735afe30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd64556212553a3ada775f74735afe30">&#9670;&#160;</a></span>neighbor_parallel_reduce() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class NeighborListType , class ReduceType , class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::neighbor_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::RangePolicy&lt; ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NeighborListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SecondNeighborsTag.html">SecondNeighborsTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1TeamVectorOpTag.html">TeamVectorOpTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reduce_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute functor reduction in parallel according to the execution policy over particles with team parallelism over particle first neighbors and vector loop parallelism over second neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute. </td></tr>
    <tr><td class="paramname">NeighborListType</td><td>The neighbor list type. </td></tr>
    <tr><td class="paramname">ExecParams</td><td>The Kokkos range policy parameters. </td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The policy over which to execute the functor. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute in parallel </td></tr>
    <tr><td class="paramname">list</td><td>The neighbor list over which to execute the neighbor operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCabana_1_1SecondNeighborsTag.html" title="Loop over particle neighbors (first) and neighbor&#39;s neighbors (second)">SecondNeighborsTag</a> Tag indicating operations over particle first and second neighbors. </dd>
<dd>
<a class="el" href="classCabana_1_1TeamVectorOpTag.html" title="Neighbor operations are executed with team vector parallelism.">TeamVectorOpTag</a> Tag indicating a team parallel strategy over particle first neighbors and vector loops over second neighbors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_val</td><td>Scalar to be reduced across particles and neighbors. </td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_reduce called by this code and can be used for identification and profiling purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70cddd6233e137bfbe2ca4773e565e5d" name="a70cddd6233e137bfbe2ca4773e565e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cddd6233e137bfbe2ca4773e565e5d">&#9670;&#160;</a></span>neighborHistogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class ListType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt; int *[2], typename ListType::memory_space &gt; Cabana::neighborHistogram </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ListType &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_bin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a histogram of neighbors per particle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">num_particles</td><td>Number of particles. </td></tr>
    <tr><td class="paramname">list</td><td>Neighbor list with valid <a class="el" href="classCabana_1_1NeighborList.html" title="Neighbor list interface. Provides an interface callable at the functor level that gives access to nei...">NeighborList</a> interface. </td></tr>
    <tr><td class="paramname">num_bin</td><td>Number of bins for the histogram. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Neighbor list histogram View. </dd></dl>

</div>
</div>
<a id="a824f296314f00ca8e121e6a26e2846db" name="a824f296314f00ca8e121e6a26e2846db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824f296314f00ca8e121e6a26e2846db">&#9670;&#160;</a></span>permute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BinningDataType , class AoSoA_t , class ExecutionSpace  = typename BinningDataType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">const BinningDataType &amp;&#160;</td>
          <td class="paramname"><em>binning_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(is_binning_data&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given binning data permute an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinningDataType</td><td>The binning data type. </td></tr>
    <tr><td class="paramname">AoSoA_t</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binning_data</td><td>The binning data. </td></tr>
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab44a65c22331c71ed7cee721a41c54fc" name="ab44a65c22331c71ed7cee721a41c54fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44a65c22331c71ed7cee721a41c54fc">&#9670;&#160;</a></span>permute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BinningDataType , class SliceType , class ExecutionSpace  = typename BinningDataType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">const BinningDataType &amp;&#160;</td>
          <td class="paramname"><em>binning_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceType &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(is_binning_data&lt; BinningDataType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given binning data permute a slice. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinningDataType</td><td>The binning data type. </td></tr>
    <tr><td class="paramname">SliceType</td><td>The slice type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binning_data</td><td>The binning data. </td></tr>
    <tr><td class="paramname">slice</td><td>The slice to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02c3a57c3cd27a75094bbfa1be56145b" name="a02c3a57c3cd27a75094bbfa1be56145b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c3a57c3cd27a75094bbfa1be56145b">&#9670;&#160;</a></span>permute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LinkedCellListType , class AoSoA_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">const LinkedCellListType &amp;&#160;</td>
          <td class="paramname"><em>linked_cell_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellListType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__aosoa.html">is_aosoa</a>&lt; AoSoA_t &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a linked cell list permute an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LinkedCellListType</td><td>The linked cell list type.</td></tr>
    <tr><td class="paramname">AoSoA_t</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linked_cell_list</td><td>The linked cell list to permute the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> with.</td></tr>
    <tr><td class="paramname">aosoa</td><td>The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a1ce7155c5c1185f46071b20d4dd332" name="a5a1ce7155c5c1185f46071b20d4dd332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1ce7155c5c1185f46071b20d4dd332">&#9670;&#160;</a></span>permute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LinkedCellListType , class SliceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::permute </td>
          <td>(</td>
          <td class="paramtype">const LinkedCellListType &amp;&#160;</td>
          <td class="paramname"><em>linked_cell_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceType &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__linked__cell__list.html">is_linked_cell_list</a>&lt; LinkedCellListType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a linked cell list permute a slice. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LinkedCellListType</td><td>The linked cell list type.</td></tr>
    <tr><td class="paramname">SliceType</td><td>The slice type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linked_cell_list</td><td>The linked cell list to permute the slice with.</td></tr>
    <tr><td class="paramname">slice</td><td>The slice to permute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8eb6aa8da865a5ff9c1a86f1ba0a281" name="aa8eb6aa8da865a5ff9c1a86f1ba0a281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8eb6aa8da865a5ff9c1a86f1ba0a281">&#9670;&#160;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HaloType , class SliceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::scatter </td>
          <td>(</td>
          <td class="paramtype">const HaloType &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceType &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__halo.html">is_halo</a>&lt; HaloType &gt;::value &amp;&amp;<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously scatter data from the ghosts to the local decomposition of a slice using the halo reverse communication plan. This is a multiply-owned to uniquely owned communication. </p>
<dl class="section note"><dt>Note</dt><dd>This routine allocates send and receive buffers internally. This is often not performant due to frequent buffer reallocations - consider creating and reusing <a class="el" href="classCabana_1_1Gather.html">Gather</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halo</td><td>The halo to use for the scatter.</td></tr>
    <tr><td class="paramname">slice</td><td>The <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> on which to perform the scatter. The <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> should have a size equivalent to halo.numGhost() + halo.numLocal(). The locally owned elements are expected to appear first (i.e. in the first halo.numLocal() elements) and the ghosted elements are expected to appear second (i.e. in the next halo.numGhost() elements()). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7dda1a05e595dbec3f4f06e7f878d9e" name="ab7dda1a05e595dbec3f4f06e7f878d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7dda1a05e595dbec3f4f06e7f878d9e">&#9670;&#160;</a></span>simd_parallel_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , int VectorLength, class... ExecParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cabana::simd_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1SimdPolicy.html">SimdPolicy</a>&lt; VectorLength, ExecParameters... &gt; &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a vectorized functor in parallel with a 2d execution policy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">VectorLength</td><td>The length of the vector over which to execute the vectorized code.</td></tr>
    <tr><td class="paramname">ExecParameters</td><td>Execution policy parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_policy</td><td>The 2D range policy over which to execute the functor.</td></tr>
    <tr><td class="paramname">functor</td><td>The vectorized functor to execute in parallel. Must accept both a struct and array index.</td></tr>
    <tr><td class="paramname">str</td><td>Optional name for the functor. Will be forwarded if non-empty to the Kokkos::parallel_for called by this code and can be used for identification and profiling purposes.</td></tr>
  </table>
  </dd>
</dl>
<p>A "functor" is a callable object containing the function to execute in parallel, data needed for that execution, and an optional <code>execution_space</code> typedef. Here is an example functor for parallel_for:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FunctorType {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keyword">typedef</span>  ...  execution_space ;</div>
<div class="line"><span class="keywordtype">void</span> operator() ( <span class="keyword">const</span> <span class="keywordtype">int</span> <span class="keyword">struct</span>, <span class="keyword">const</span> <span class="keywordtype">int</span> array ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>struct</code> defines an index to a given AoSoA/Slice struct and array defines and index to the given array element in that struct. Its <code>operator()</code> method defines the operation to parallelize, over the range of indices <code>idx=[begin,end]</code>. The kernel represented by the functor is intended to vectorize of the array index.</p>
<dl class="section note"><dt>Note</dt><dd>The work tag gets applied at the user functor level, not at the level of the functor in this implementation that wraps the user functor. </dd></dl>

</div>
</div>
<a id="aa14f30ab334c57448b204fc9b304289a" name="aa14f30ab334c57448b204fc9b304289a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14f30ab334c57448b204fc9b304289a">&#9670;&#160;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t M, class AoSoA_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">AoSoA_t::template member_slice_type&lt; M &gt; Cabana::slice </td>
          <td>(</td>
          <td class="paramtype">const AoSoA_t &amp;&#160;</td>
          <td class="paramname"><em>aosoa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>slice_label</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a slice from an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> index. </td></tr>
    <tr><td class="paramname">AoSoA_t</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aosoa</td><td><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> to slice from. </td></tr>
    <tr><td class="paramname">slice_label</td><td>Optional slice label. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> </dd></dl>

</div>
</div>
<a id="a5c64ff984d2da99d6ff20d89a8ae9899" name="a5c64ff984d2da99d6ff20d89a8ae9899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c64ff984d2da99d6ff20d89a8ae9899">&#9670;&#160;</a></span>sortByKey() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort. </td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="a73cfa6540c7adf84fb5d3546950c46e6" name="a73cfa6540c7adf84fb5d3546950c46e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cfa6540c7adf84fb5d3546950c46e6">&#9670;&#160;</a></span>sortByKey() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated key values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="a2577949b8aa884de4873f31efa54401b" name="a2577949b8aa884de4873f31efa54401b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2577949b8aa884de4873f31efa54401b">&#9670;&#160;</a></span>sortByKey() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType , class ExecutionSpace  = typename SliceType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys. </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort. </td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="a360b0f9c15911bfac904d240e7f369d7" name="a360b0f9c15911bfac904d240e7f369d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360b0f9c15911bfac904d240e7f369d7">&#9670;&#160;</a></span>sortByKey() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SliceType , class ExecutionSpace  = typename SliceType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::sortByKey </td>
          <td>(</td>
          <td class="paramtype">SliceType&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; SliceType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> based on the associated slice of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SliceType</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> type for keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td><a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a> of keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="ac7a029626fb67b12cf279b7f3c620159" name="ac7a029626fb67b12cf279b7f3c620159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a029626fb67b12cf279b7f3c620159">&#9670;&#160;</a></span>sortByKeyWithComparator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class Comparator , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::sortByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> over a subset of its range using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys. </td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for sorting. Must be compatible with Kokkos::BinSort. </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort. </td></tr>
    <tr><td class="paramname">end</td><td>The end index of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> range to sort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
<a id="ac8376dcbdaa0c3dad87fe19203cf1755" name="ac8376dcbdaa0c3dad87fe19203cf1755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8376dcbdaa0c3dad87fe19203cf1755">&#9670;&#160;</a></span>sortByKeyWithComparator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyViewType , class Comparator , class ExecutionSpace  = typename KeyViewType::execution_space&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cabana::sortByKeyWithComparator </td>
          <td>(</td>
          <td class="paramtype">KeyViewType&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(Kokkos::is_view&lt; KeyViewType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an entire <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> using a general comparator over the given Kokkos View of keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyViewType</td><td>The Kokkos::View type for keys. </td></tr>
    <tr><td class="paramname">Comparator</td><td>Kokkos::BinSort compatible comparator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The key values to use for sorting. A key value is needed for every element of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>. </td></tr>
    <tr><td class="paramname">comp</td><td>The comparator to use for sorting. Must be compatible with Kokkos::BinSort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector associated with the sorting. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
