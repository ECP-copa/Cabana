<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cabana: Cabana::Grid::Experimental::SparseHalo&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cabana<span id="projectnumber">&#160;0.7.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceCabana.html">Cabana</a></li><li class="navelem"><b>Grid</b></li><li class="navelem"><b>Experimental</b></li><li class="navelem"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">SparseHalo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Cabana::Grid::Experimental::SparseHalo&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Cabana__Grid__SparseHalo_8hpp_source.html">Cabana_Grid_SparseHalo.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7899e2f7b731ecef19cfeb9db6ba14d4"><td class="memItemLeft" align="right" valign="top"><a id="a7899e2f7b731ecef19cfeb9db6ba14d4" name="a7899e2f7b731ecef19cfeb9db6ba14d4"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a7899e2f7b731ecef19cfeb9db6ba14d4">KeyValue</a> { <b>invalid_key</b> = ~static_cast&lt;key_type&gt;( 0 )
 }</td></tr>
<tr class="memdesc:a7899e2f7b731ecef19cfeb9db6ba14d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">invalid key in sparse map <br /></td></tr>
<tr class="separator:a7899e2f7b731ecef19cfeb9db6ba14d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f8aad0e897cd2b25125a6826de095b"><td class="memItemLeft" align="right" valign="top"><a id="a29f8aad0e897cd2b25125a6826de095b" name="a29f8aad0e897cd2b25125a6826de095b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a29f8aad0e897cd2b25125a6826de095b">Index</a> { <b>own</b> = 0
, <b>ghost</b> = 1
, <b>total</b> = 2
 }</td></tr>
<tr class="memdesc:a29f8aad0e897cd2b25125a6826de095b"><td class="mdescLeft">&#160;</td><td class="mdescRight">index (own or ghost) <br /></td></tr>
<tr class="separator:a29f8aad0e897cd2b25125a6826de095b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb96682e4c8e546d2cff1cc21e0e3f06"><td class="memItemLeft" align="right" valign="top"><a id="aeb96682e4c8e546d2cff1cc21e0e3f06" name="aeb96682e4c8e546d2cff1cc21e0e3f06"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>memory_space</b> = MemorySpace</td></tr>
<tr class="memdesc:aeb96682e4c8e546d2cff1cc21e0e3f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory space to store the sparse grid <br /></td></tr>
<tr class="separator:aeb96682e4c8e546d2cff1cc21e0e3f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e3692c0d00eb18c13d370483565a0c"><td class="memItemLeft" align="right" valign="top"><a id="a59e3692c0d00eb18c13d370483565a0c" name="a59e3692c0d00eb18c13d370483565a0c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>entity_type</b> = EntityType</td></tr>
<tr class="memdesc:a59e3692c0d00eb18c13d370483565a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">entity type on sparse grid <br /></td></tr>
<tr class="separator:a59e3692c0d00eb18c13d370483565a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c69f1cf7b9a82406a5a7b3f4ab20c57"><td class="memItemLeft" align="right" valign="top"><a id="a9c69f1cf7b9a82406a5a7b3f4ab20c57" name="a9c69f1cf7b9a82406a5a7b3f4ab20c57"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>halo_pattern_type</b> = <a class="el" href="classCabana_1_1Grid_1_1NodeHaloPattern.html">NodeHaloPattern</a>&lt; NumSpaceDim &gt;</td></tr>
<tr class="memdesc:a9c69f1cf7b9a82406a5a7b3f4ab20c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">sparse grid halo pattern (TODO currently reusing <a class="el" href="classCabana_1_1Grid_1_1Halo.html">Halo</a>'s <a class="el" href="structCabana_1_1Grid_1_1Node.html" title="Mesh node tag.">Node</a> pattern) <br /></td></tr>
<tr class="separator:a9c69f1cf7b9a82406a5a7b3f4ab20c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdec0a4be7c19fc6724d6beb3def28cb"><td class="memItemLeft" align="right" valign="top"><a id="abdec0a4be7c19fc6724d6beb3def28cb" name="abdec0a4be7c19fc6724d6beb3def28cb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = Value</td></tr>
<tr class="memdesc:abdec0a4be7c19fc6724d6beb3def28cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type of entities on sparse grid <br /></td></tr>
<tr class="separator:abdec0a4be7c19fc6724d6beb3def28cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a85e610d96eef07d0146ae3f9640a52"><td class="memItemLeft" align="right" valign="top"><a id="a8a85e610d96eef07d0146ae3f9640a52" name="a8a85e610d96eef07d0146ae3f9640a52"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = Key</td></tr>
<tr class="memdesc:a8a85e610d96eef07d0146ae3f9640a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">key type in sparse map <br /></td></tr>
<tr class="separator:a8a85e610d96eef07d0146ae3f9640a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd24bee2466db38b3757b02716b2843"><td class="memItemLeft" align="right" valign="top"><a id="a0dd24bee2466db38b3757b02716b2843" name="a0dd24bee2466db38b3757b02716b2843"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>aosoa_member_types</b> = DataTypes</td></tr>
<tr class="memdesc:a0dd24bee2466db38b3757b02716b2843"><td class="mdescLeft">&#160;</td><td class="mdescRight">data members in <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> structure <br /></td></tr>
<tr class="separator:a0dd24bee2466db38b3757b02716b2843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad396715ca570fa51ffd5484bd37a0682"><td class="memItemLeft" align="right" valign="top"><a id="ad396715ca570fa51ffd5484bd37a0682" name="ad396715ca570fa51ffd5484bd37a0682"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>tuple_type</b> = <a class="el" href="structCabana_1_1Tuple.html">Cabana::Tuple</a>&lt; <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a0dd24bee2466db38b3757b02716b2843">aosoa_member_types</a> &gt;</td></tr>
<tr class="memdesc:ad396715ca570fa51ffd5484bd37a0682"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> tuple type. <br /></td></tr>
<tr class="separator:ad396715ca570fa51ffd5484bd37a0682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82172fd994aa865a4041063a1a454e3e"><td class="memTemplParams" colspan="2"><a id="a82172fd994aa865a4041063a1a454e3e" name="a82172fd994aa865a4041063a1a454e3e"></a>
template&lt;std::size_t M&gt; </td></tr>
<tr class="memitem:a82172fd994aa865a4041063a1a454e3e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>member_data_type</b> = typename <a class="el" href="structCabana_1_1MemberTypeAtIndex.html">Cabana::MemberTypeAtIndex</a>&lt; M, <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a0dd24bee2466db38b3757b02716b2843">aosoa_member_types</a> &gt;::type</td></tr>
<tr class="memdesc:a82172fd994aa865a4041063a1a454e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> member data type. <br /></td></tr>
<tr class="separator:a82172fd994aa865a4041063a1a454e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee005ea512fdbd9acb04d1546c006ef"><td class="memItemLeft" align="right" valign="top"><a id="adee005ea512fdbd9acb04d1546c006ef" name="adee005ea512fdbd9acb04d1546c006ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_view</b> = Kokkos::View&lt; <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ad396715ca570fa51ffd5484bd37a0682">tuple_type</a> *, <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#aeb96682e4c8e546d2cff1cc21e0e3f06">memory_space</a> &gt;</td></tr>
<tr class="memdesc:adee005ea512fdbd9acb04d1546c006ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">communication data buffer view type <br /></td></tr>
<tr class="separator:adee005ea512fdbd9acb04d1546c006ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20aa8f28c2201f4689177ab548fc8cfb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a20aa8f28c2201f4689177ab548fc8cfb">steering_view</a> = Kokkos::View&lt; <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a8a85e610d96eef07d0146ae3f9640a52">key_type</a> *, <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#aeb96682e4c8e546d2cff1cc21e0e3f06">memory_space</a> &gt;</td></tr>
<tr class="separator:a20aa8f28c2201f4689177ab548fc8cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2ebe2999d6043666bbd15137b7f98c"><td class="memItemLeft" align="right" valign="top"><a id="a6b2ebe2999d6043666bbd15137b7f98c" name="a6b2ebe2999d6043666bbd15137b7f98c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>tile_index_space</b> = <a class="el" href="classCabana_1_1Grid_1_1TileIndexSpace.html">TileIndexSpace</a>&lt; <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ac4b64da890c7ea16a8156d1545888a59">num_space_dim</a>, <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#afb4e06ee0e7d95e311c1a2693efbe15d">cell_bits_per_tile_dim</a> &gt;</td></tr>
<tr class="memdesc:a6b2ebe2999d6043666bbd15137b7f98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">tile index space type TODO <br /></td></tr>
<tr class="separator:a6b2ebe2999d6043666bbd15137b7f98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbe527e983289cc64276301e307930c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a3fbe527e983289cc64276301e307930c">counting_view</a> = Kokkos::View&lt; int[2], <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#aeb96682e4c8e546d2cff1cc21e0e3f06">memory_space</a>, Kokkos::MemoryTraits&lt; Kokkos::Atomic &gt; &gt;</td></tr>
<tr class="separator:a3fbe527e983289cc64276301e307930c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a74def75cb71b9416099791f01cfeef91"><td class="memTemplParams" colspan="2">template&lt;class SparseArrayType &gt; </td></tr>
<tr class="memitem:a74def75cb71b9416099791f01cfeef91"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a74def75cb71b9416099791f01cfeef91">SparseHalo</a> (const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a9c69f1cf7b9a82406a5a7b3f4ab20c57">halo_pattern_type</a> pattern, const std::shared_ptr&lt; SparseArrayType &gt; &amp;sparse_array)</td></tr>
<tr class="memdesc:a74def75cb71b9416099791f01cfeef91"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <br /></td></tr>
<tr class="separator:a74def75cb71b9416099791f01cfeef91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad00adbd80abdfda2e57e6e8a1e82d74"><td class="memTemplParams" colspan="2"><a id="aad00adbd80abdfda2e57e6e8a1e82d74" name="aad00adbd80abdfda2e57e6e8a1e82d74"></a>
template&lt;class SparseArrayType &gt; </td></tr>
<tr class="memitem:aad00adbd80abdfda2e57e6e8a1e82d74"><td class="memTemplItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getComm</b> (const SparseArrayType sparse_array) const</td></tr>
<tr class="memdesc:aad00adbd80abdfda2e57e6e8a1e82d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the communicator. <br /></td></tr>
<tr class="separator:aad00adbd80abdfda2e57e6e8a1e82d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ffb0bd4753e9c4f8011e4b7ef0a750"><td class="memTemplParams" colspan="2">template&lt;class DecompositionTag , class LocalGridType &gt; </td></tr>
<tr class="memitem:ac5ffb0bd4753e9c4f8011e4b7ef0a750"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ac5ffb0bd4753e9c4f8011e4b7ef0a750">buildCommData</a> (DecompositionTag decomposition_tag, const std::shared_ptr&lt; LocalGridType &gt; &amp;local_grid, const std::array&lt; int, <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ac4b64da890c7ea16a8156d1545888a59">num_space_dim</a> &gt; &amp;nid, std::vector&lt; <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#adee005ea512fdbd9acb04d1546c006ef">buffer_view</a> &gt; &amp;buffers, std::vector&lt; <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a20aa8f28c2201f4689177ab548fc8cfb">steering_view</a> &gt; &amp;steering, std::vector&lt; <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a6b2ebe2999d6043666bbd15137b7f98c">tile_index_space</a> &gt; &amp;spaces)</td></tr>
<tr class="memdesc:ac5ffb0bd4753e9c4f8011e4b7ef0a750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build communication data.  <br /></td></tr>
<tr class="separator:ac5ffb0bd4753e9c4f8011e4b7ef0a750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ea1af92073388e8f6de0b47def606b"><td class="memTemplParams" colspan="2">template&lt;class LocalGridType &gt; </td></tr>
<tr class="memitem:a44ea1af92073388e8f6de0b47def606b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a44ea1af92073388e8f6de0b47def606b">updateTileSpace</a> (const std::shared_ptr&lt; LocalGridType &gt; &amp;local_grid)</td></tr>
<tr class="memdesc:a44ea1af92073388e8f6de0b47def606b"><td class="mdescLeft">&#160;</td><td class="mdescRight">update tile index space according to current partition  <br /></td></tr>
<tr class="separator:a44ea1af92073388e8f6de0b47def606b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c10b47c3380102e3c80b878b3671c4"><td class="memTemplParams" colspan="2">template&lt;class ExecSpace , class SparseMapType &gt; </td></tr>
<tr class="memitem:a21c10b47c3380102e3c80b878b3671c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a21c10b47c3380102e3c80b878b3671c4">register_halo</a> (SparseMapType &amp;map)</td></tr>
<tr class="memdesc:a21c10b47c3380102e3c80b878b3671c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">register valid halos (according to grid activation status in sparse map) in the steerings  <br /></td></tr>
<tr class="separator:a21c10b47c3380102e3c80b878b3671c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf6ce3c5dadc8c41efe394683b65a2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#aadf6ce3c5dadc8c41efe394683b65a2c">clear</a> (MPI_Comm comm)</td></tr>
<tr class="memdesc:aadf6ce3c5dadc8c41efe394683b65a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear guiding information in sparse halo,  <br /></td></tr>
<tr class="separator:aadf6ce3c5dadc8c41efe394683b65a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5e84d5a926275dfe2743d9514b875e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#abf5e84d5a926275dfe2743d9514b875e">collectNeighborCounting</a> (MPI_Comm comm, const bool is_neighbor_counting_collected=false) const</td></tr>
<tr class="memdesc:abf5e84d5a926275dfe2743d9514b875e"><td class="mdescLeft">&#160;</td><td class="mdescRight">neighbor tile counting, communication needed only if the counting is non-zero  <br /></td></tr>
<tr class="separator:abf5e84d5a926275dfe2743d9514b875e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25ae7ddc9cf17d0cc9f911209c20c1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ac25ae7ddc9cf17d0cc9f911209c20c1e">scatterValidSendAndRecvRanks</a> (MPI_Comm comm, std::vector&lt; int &gt; &amp;valid_sends, std::vector&lt; int &gt; &amp;valid_recvs, const bool is_neighbor_counting_collected=false) const</td></tr>
<tr class="memdesc:ac25ae7ddc9cf17d0cc9f911209c20c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">collect all valid ranks for sparse grid scatter operations  <br /></td></tr>
<tr class="separator:ac25ae7ddc9cf17d0cc9f911209c20c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a569ba6f225cbe72ebd0d4e6f3ca645"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a4a569ba6f225cbe72ebd0d4e6f3ca645">gatherValidSendAndRecvRanks</a> (MPI_Comm comm, std::vector&lt; int &gt; &amp;valid_sends, std::vector&lt; int &gt; &amp;valid_recvs, const bool is_neighbor_counting_collected=false) const</td></tr>
<tr class="memdesc:a4a569ba6f225cbe72ebd0d4e6f3ca645"><td class="mdescLeft">&#160;</td><td class="mdescRight">collect all valid ranks for sparse grid gather operations  <br /></td></tr>
<tr class="separator:a4a569ba6f225cbe72ebd0d4e6f3ca645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063fe877e39f21ba3137b17c024bf0ac"><td class="memTemplParams" colspan="2">template&lt;class ExecSpace , class SparseArrayType &gt; </td></tr>
<tr class="memitem:a063fe877e39f21ba3137b17c024bf0ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a063fe877e39f21ba3137b17c024bf0ac">gather</a> (const ExecSpace &amp;exec_space, SparseArrayType &amp;sparse_array, const bool is_neighbor_counting_collected=false) const</td></tr>
<tr class="memdesc:a063fe877e39f21ba3137b17c024bf0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1Gather.html">Gather</a> data into our ghosted share space from their owners.  <br /></td></tr>
<tr class="separator:a063fe877e39f21ba3137b17c024bf0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47864a58a44132ec9bfcc7fc6647eb8f"><td class="memTemplParams" colspan="2">template&lt;class ExecSpace , class ReduceOp , class SparseArrayType &gt; </td></tr>
<tr class="memitem:a47864a58a44132ec9bfcc7fc6647eb8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a47864a58a44132ec9bfcc7fc6647eb8f">scatter</a> (const ExecSpace &amp;exec_space, const ReduceOp &amp;reduce_op, SparseArrayType &amp;sparse_array, const bool is_neighbor_counting_collected=false) const</td></tr>
<tr class="memdesc:a47864a58a44132ec9bfcc7fc6647eb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1Scatter.html" title="Synchronously scatter data from the ghosts to the local decomposition of a slice using the halo rever...">Scatter</a> data from our ghosts to their owners using the given type of reduce operation.  <br /></td></tr>
<tr class="separator:a47864a58a44132ec9bfcc7fc6647eb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac905a4b8bfae8e4fb6e8bfe60c704cc5"><td class="memTemplParams" colspan="2">template&lt;class ExecSpace , class SparseArrayType , class CountType &gt; </td></tr>
<tr class="memitem:ac905a4b8bfae8e4fb6e8bfe60c704cc5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ac905a4b8bfae8e4fb6e8bfe60c704cc5">packBuffer</a> (const ExecSpace &amp;exec_space, const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#adee005ea512fdbd9acb04d1546c006ef">buffer_view</a> &amp;buffer, const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a20aa8f28c2201f4689177ab548fc8cfb">steering_view</a> &amp;tile_steering, SparseArrayType &amp;sparse_array, const CountType count) const</td></tr>
<tr class="memdesc:ac905a4b8bfae8e4fb6e8bfe60c704cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack sparse arrays at halo regions into a buffer.  <br /></td></tr>
<tr class="separator:ac905a4b8bfae8e4fb6e8bfe60c704cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dc08768a3a8c2c5f363eed5e123500"><td class="memTemplParams" colspan="2">template&lt;class ReduceOp , class ExecSpace , class SparseArrayType , class SparseMapType , class CountType &gt; </td></tr>
<tr class="memitem:a38dc08768a3a8c2c5f363eed5e123500"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a38dc08768a3a8c2c5f363eed5e123500">unpackBuffer</a> (const ReduceOp &amp;reduce_op, const ExecSpace &amp;exec_space, const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#adee005ea512fdbd9acb04d1546c006ef">buffer_view</a> &amp;buffer, const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a20aa8f28c2201f4689177ab548fc8cfb">steering_view</a> &amp;tile_steering, const SparseArrayType &amp;sparse_array, SparseMapType &amp;map, const CountType count) const</td></tr>
<tr class="memdesc:a38dc08768a3a8c2c5f363eed5e123500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a sparse array communication buffer.  <br /></td></tr>
<tr class="separator:a38dc08768a3a8c2c5f363eed5e123500"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa72a4d7dd8733c99fffe6cd1e51cd8b5"><td class="memTemplParams" colspan="2"><a id="aa72a4d7dd8733c99fffe6cd1e51cd8b5" name="aa72a4d7dd8733c99fffe6cd1e51cd8b5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa72a4d7dd8733c99fffe6cd1e51cd8b5"><td class="memTemplItemLeft" align="right" valign="top">static KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unpackOp</b> (<a class="el" href="structCabana_1_1Grid_1_1ScatterReduce_1_1Sum.html">ScatterReduce::Sum</a>, const T &amp;buffer_val, T &amp;array_val)</td></tr>
<tr class="memdesc:aa72a4d7dd8733c99fffe6cd1e51cd8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an element into the buffer. Sum reduction. <br /></td></tr>
<tr class="separator:aa72a4d7dd8733c99fffe6cd1e51cd8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ef3fd7adff9a55c36979706c36f6f0"><td class="memTemplParams" colspan="2"><a id="a05ef3fd7adff9a55c36979706c36f6f0" name="a05ef3fd7adff9a55c36979706c36f6f0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a05ef3fd7adff9a55c36979706c36f6f0"><td class="memTemplItemLeft" align="right" valign="top">static KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unpackOp</b> (<a class="el" href="structCabana_1_1Grid_1_1ScatterReduce_1_1Min.html">ScatterReduce::Min</a>, const T &amp;buffer_val, T &amp;array_val)</td></tr>
<tr class="memdesc:a05ef3fd7adff9a55c36979706c36f6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an element into the buffer. Min reduction. <br /></td></tr>
<tr class="separator:a05ef3fd7adff9a55c36979706c36f6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6c3942db5ce79f4404cfd8f2dd8177"><td class="memTemplParams" colspan="2"><a id="aed6c3942db5ce79f4404cfd8f2dd8177" name="aed6c3942db5ce79f4404cfd8f2dd8177"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aed6c3942db5ce79f4404cfd8f2dd8177"><td class="memTemplItemLeft" align="right" valign="top">static KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unpackOp</b> (<a class="el" href="structCabana_1_1Grid_1_1ScatterReduce_1_1Max.html">ScatterReduce::Max</a>, const T &amp;buffer_val, T &amp;array_val)</td></tr>
<tr class="memdesc:aed6c3942db5ce79f4404cfd8f2dd8177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an element into the buffer. Max reduction. <br /></td></tr>
<tr class="separator:aed6c3942db5ce79f4404cfd8f2dd8177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4335970e891a9d31a5d800b1540c0b0c"><td class="memTemplParams" colspan="2"><a id="a4335970e891a9d31a5d800b1540c0b0c" name="a4335970e891a9d31a5d800b1540c0b0c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4335970e891a9d31a5d800b1540c0b0c"><td class="memTemplItemLeft" align="right" valign="top">static KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unpackOp</b> (<a class="el" href="structCabana_1_1Grid_1_1ScatterReduce_1_1Replace.html">ScatterReduce::Replace</a>, const T &amp;buffer_val, T &amp;array_val)</td></tr>
<tr class="memdesc:a4335970e891a9d31a5d800b1540c0b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an element into the buffer. Replace reduction. <br /></td></tr>
<tr class="separator:a4335970e891a9d31a5d800b1540c0b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dbb3106ef8173c2fc3c70932603c18"><td class="memTemplParams" colspan="2">template&lt;class ReduceOp , std::size_t N, std::size_t M, class SoAType &gt; </td></tr>
<tr class="memitem:a41dbb3106ef8173c2fc3c70932603c18"><td class="memTemplItemLeft" align="right" valign="top">static KOKKOS_FORCEINLINE_FUNCTION std::enable_if_t&lt; 3==M, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a41dbb3106ef8173c2fc3c70932603c18">unpackTupleMember</a> (const ReduceOp &amp;reduce_op, const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ad396715ca570fa51ffd5484bd37a0682">tuple_type</a> &amp;src_tuple, SoAType &amp;dst_soa, const int soa_idx, const Kokkos::Array&lt; std::size_t, M &gt; &amp;extents, const std::integral_constant&lt; std::size_t, N &gt;, const std::integral_constant&lt; std::size_t, M &gt;)</td></tr>
<tr class="memdesc:a41dbb3106ef8173c2fc3c70932603c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a sparse arrays element (a tuple) in a buffer (for case tuple members with rank == 3)  <br /></td></tr>
<tr class="separator:a41dbb3106ef8173c2fc3c70932603c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a7877f6aa505b9a063e7b8018a83fd"><td class="memTemplParams" colspan="2">template&lt;class ReduceOp , std::size_t N, std::size_t M, class SoAType &gt; </td></tr>
<tr class="memitem:a11a7877f6aa505b9a063e7b8018a83fd"><td class="memTemplItemLeft" align="right" valign="top">static KOKKOS_FORCEINLINE_FUNCTION std::enable_if_t&lt; 2==M, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a11a7877f6aa505b9a063e7b8018a83fd">unpackTupleMember</a> (const ReduceOp &amp;reduce_op, const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ad396715ca570fa51ffd5484bd37a0682">tuple_type</a> &amp;src_tuple, SoAType &amp;dst_soa, const int soa_idx, const Kokkos::Array&lt; std::size_t, M &gt; &amp;extents, const std::integral_constant&lt; std::size_t, N &gt;, const std::integral_constant&lt; std::size_t, M &gt;)</td></tr>
<tr class="memdesc:a11a7877f6aa505b9a063e7b8018a83fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a sparse arrays element (a tuple) in a buffer (for case tuple members with rank == 2)  <br /></td></tr>
<tr class="separator:a11a7877f6aa505b9a063e7b8018a83fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b3bc1ebfcefbf57bbda99663fa5869"><td class="memTemplParams" colspan="2">template&lt;class ReduceOp , std::size_t N, std::size_t M, class SoAType &gt; </td></tr>
<tr class="memitem:ae2b3bc1ebfcefbf57bbda99663fa5869"><td class="memTemplItemLeft" align="right" valign="top">static KOKKOS_FORCEINLINE_FUNCTION std::enable_if_t&lt; 1==M, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ae2b3bc1ebfcefbf57bbda99663fa5869">unpackTupleMember</a> (const ReduceOp &amp;reduce_op, const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ad396715ca570fa51ffd5484bd37a0682">tuple_type</a> &amp;src_tuple, SoAType &amp;dst_soa, const int soa_idx, const Kokkos::Array&lt; std::size_t, M &gt; &amp;extents, const std::integral_constant&lt; std::size_t, N &gt;, const std::integral_constant&lt; std::size_t, M &gt;)</td></tr>
<tr class="memdesc:ae2b3bc1ebfcefbf57bbda99663fa5869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a sparse arrays element (a tuple) in a buffer (for case tuple members with rank == 1)  <br /></td></tr>
<tr class="separator:ae2b3bc1ebfcefbf57bbda99663fa5869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ba27d5ad22ba54232c29cfc39fec0b"><td class="memTemplParams" colspan="2">template&lt;class ReduceOp , std::size_t N, std::size_t M, class SoAType &gt; </td></tr>
<tr class="memitem:a43ba27d5ad22ba54232c29cfc39fec0b"><td class="memTemplItemLeft" align="right" valign="top">static KOKKOS_FORCEINLINE_FUNCTION std::enable_if_t&lt; 0==M, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a43ba27d5ad22ba54232c29cfc39fec0b">unpackTupleMember</a> (const ReduceOp &amp;reduce_op, const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ad396715ca570fa51ffd5484bd37a0682">tuple_type</a> &amp;src_tuple, SoAType &amp;dst_soa, const int soa_idx, const Kokkos::Array&lt; std::size_t, M &gt; &amp;, const std::integral_constant&lt; std::size_t, N &gt;, const std::integral_constant&lt; std::size_t, M &gt;)</td></tr>
<tr class="memdesc:a43ba27d5ad22ba54232c29cfc39fec0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a sparse arrays element (a tuple) in a buffer (for case tuple members with rank == 0)  <br /></td></tr>
<tr class="separator:a43ba27d5ad22ba54232c29cfc39fec0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aeac20ab5a7e0d5aa71f3497ea663b6"><td class="memTemplParams" colspan="2">template&lt;class ReduceOp , class SoAType &gt; </td></tr>
<tr class="memitem:a9aeac20ab5a7e0d5aa71f3497ea663b6"><td class="memTemplItemLeft" align="right" valign="top">static KOKKOS_FORCEINLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a9aeac20ab5a7e0d5aa71f3497ea663b6">unpackTuple</a> (const ReduceOp &amp;reduce_op, const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ad396715ca570fa51ffd5484bd37a0682">tuple_type</a> &amp;src_tuple, SoAType &amp;dst_soa, const int soa_idx, const std::integral_constant&lt; std::size_t, 0 &gt;)</td></tr>
<tr class="memdesc:a9aeac20ab5a7e0d5aa71f3497ea663b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a sparse arrays tuple for it's member with index 0.  <br /></td></tr>
<tr class="separator:a9aeac20ab5a7e0d5aa71f3497ea663b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36df4dfaccc333a9a7b4715b0443054"><td class="memTemplParams" colspan="2">template&lt;class ReduceOp , std::size_t N, class SoAType &gt; </td></tr>
<tr class="memitem:ae36df4dfaccc333a9a7b4715b0443054"><td class="memTemplItemLeft" align="right" valign="top">static KOKKOS_FORCEINLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ae36df4dfaccc333a9a7b4715b0443054">unpackTuple</a> (const ReduceOp &amp;reduce_op, const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ad396715ca570fa51ffd5484bd37a0682">tuple_type</a> &amp;src_tuple, SoAType &amp;dst_soa, const int soa_idx, const std::integral_constant&lt; std::size_t, N &gt;)</td></tr>
<tr class="memdesc:ae36df4dfaccc333a9a7b4715b0443054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a sparse arrays tuple for all members when element ID!=0.  <br /></td></tr>
<tr class="separator:ae36df4dfaccc333a9a7b4715b0443054"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac4b64da890c7ea16a8156d1545888a59"><td class="memItemLeft" align="right" valign="top"><a id="ac4b64da890c7ea16a8156d1545888a59" name="ac4b64da890c7ea16a8156d1545888a59"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_space_dim</b> = NumSpaceDim</td></tr>
<tr class="memdesc:ac4b64da890c7ea16a8156d1545888a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">sparse array dimension number <br /></td></tr>
<tr class="separator:ac4b64da890c7ea16a8156d1545888a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd7a0d498fbeedabf4badd69f908be5"><td class="memItemLeft" align="right" valign="top"><a id="a4dd7a0d498fbeedabf4badd69f908be5" name="a4dd7a0d498fbeedabf4badd69f908be5"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>member_num</b> = aosoa_member_types::size</td></tr>
<tr class="memdesc:a4dd7a0d498fbeedabf4badd69f908be5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> member #. <br /></td></tr>
<tr class="separator:a4dd7a0d498fbeedabf4badd69f908be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4e06ee0e7d95e311c1a2693efbe15d"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#afb4e06ee0e7d95e311c1a2693efbe15d">cell_bits_per_tile_dim</a></td></tr>
<tr class="memdesc:afb4e06ee0e7d95e311c1a2693efbe15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">sparse grid hierarchy: cell id bit# per dimension  <br /></td></tr>
<tr class="separator:afb4e06ee0e7d95e311c1a2693efbe15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea91000b0ba3f493d69241b4f581e5a"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#aeea91000b0ba3f493d69241b4f581e5a">cell_num_per_tile</a></td></tr>
<tr class="memdesc:aeea91000b0ba3f493d69241b4f581e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">sparse grid hierarchy: cell # per dimension  <br /></td></tr>
<tr class="separator:aeea91000b0ba3f493d69241b4f581e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class MemorySpace, class DataTypes, class EntityType, std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value = int, typename Key = uint64_t&gt;<br />
class Cabana::Grid::Experimental::SparseHalo&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;</div><p>General multiple array halo communication plan for migrating shared data between sparse grid blocks. Arrays may be defined on different entity types and have different data types.</p>
<p>The halo operates on an arbitrary set of arrays. Each of these arrays must be defined on the same local grid meaning they that share the same communicator and halo size. The arrays must also reside in the same memory space. These requirements are checked at construction. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3fbe527e983289cc64276301e307930c" name="a3fbe527e983289cc64276301e307930c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbe527e983289cc64276301e307930c">&#9670;&#160;</a></span>counting_view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::counting_view =  Kokkos::View&lt;int[2], <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#aeb96682e4c8e546d2cff1cc21e0e3f06">memory_space</a>, Kokkos::MemoryTraits&lt;Kokkos::Atomic&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>view type used to count common sparse grid # with neighbors [0] shared_owned_num [1] shared_ghost_num </p>

</div>
</div>
<a id="a20aa8f28c2201f4689177ab548fc8cfb" name="a20aa8f28c2201f4689177ab548fc8cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20aa8f28c2201f4689177ab548fc8cfb">&#9670;&#160;</a></span>steering_view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::steering_view =  Kokkos::View&lt;<a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a8a85e610d96eef07d0146ae3f9640a52">key_type</a>*, <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#aeb96682e4c8e546d2cff1cc21e0e3f06">memory_space</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>communication steering view type, used to check whether there are common sparse grids in the halo region </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a74def75cb71b9416099791f01cfeef91" name="a74def75cb71b9416099791f01cfeef91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74def75cb71b9416099791f01cfeef91">&#9670;&#160;</a></span>SparseHalo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<div class="memtemplate">
template&lt;class SparseArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::SparseHalo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a9c69f1cf7b9a82406a5a7b3f4ab20c57">halo_pattern_type</a>&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; SparseArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>sparse_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LocalGridType</td><td>local grid type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The halo pattern to use for halo communication </td></tr>
    <tr><td class="paramname">sparse_array</td><td>Sparse array to communicate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac5ffb0bd4753e9c4f8011e4b7ef0a750" name="ac5ffb0bd4753e9c4f8011e4b7ef0a750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ffb0bd4753e9c4f8011e4b7ef0a750">&#9670;&#160;</a></span>buildCommData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<div class="memtemplate">
template&lt;class DecompositionTag , class LocalGridType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::buildCommData </td>
          <td>(</td>
          <td class="paramtype">DecompositionTag&#160;</td>
          <td class="paramname"><em>decomposition_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; LocalGridType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ac4b64da890c7ea16a8156d1545888a59">num_space_dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#adee005ea512fdbd9acb04d1546c006ef">buffer_view</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a20aa8f28c2201f4689177ab548fc8cfb">steering_view</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>steering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a6b2ebe2999d6043666bbd15137b7f98c">tile_index_space</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>spaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build communication data. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DecompositionTag</td><td>decomposition tag type </td></tr>
    <tr><td class="paramname">LocalGridType</td><td>sparse local grid type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decomposition_tag</td><td>tag to indicate if it's owned or ghosted halo </td></tr>
    <tr><td class="paramname">local_grid</td><td>sparse local grid shared pointer </td></tr>
    <tr><td class="paramname">nid</td><td>neighbor local id (ijk in pattern) </td></tr>
    <tr><td class="paramname">buffers</td><td>buffer to be used to store communicated data </td></tr>
    <tr><td class="paramname">steering</td><td>steering to be used to guide communications </td></tr>
    <tr><td class="paramname">spaces</td><td>sparse tile index spaces </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadf6ce3c5dadc8c41efe394683b65a2c" name="aadf6ce3c5dadc8c41efe394683b65a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf6ce3c5dadc8c41efe394683b65a2c">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clear guiding information in sparse halo, </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>MPI communicator</td></tr>
  </table>
  </dd>
</dl>
<p>This information needs to be cleared before steering and counting, then recollected before halo communication in each step. </p>

</div>
</div>
<a id="abf5e84d5a926275dfe2743d9514b875e" name="abf5e84d5a926275dfe2743d9514b875e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5e84d5a926275dfe2743d9514b875e">&#9670;&#160;</a></span>collectNeighborCounting()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::collectNeighborCounting </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_neighbor_counting_collected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>neighbor tile counting, communication needed only if the counting is non-zero </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>MPI communicator </td></tr>
    <tr><td class="paramname">is_neighbor_counting_collected</td><td>label if the neighbor has already been collected; if true, it means all neighbor counting information is up-to-date and there's no need for recollection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a063fe877e39f21ba3137b17c024bf0ac" name="a063fe877e39f21ba3137b17c024bf0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063fe877e39f21ba3137b17c024bf0ac">&#9670;&#160;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<div class="memtemplate">
template&lt;class ExecSpace , class SparseArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::gather </td>
          <td>(</td>
          <td class="paramtype">const ExecSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseArrayType &amp;&#160;</td>
          <td class="paramname"><em>sparse_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_neighbor_counting_collected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classCabana_1_1Gather.html">Gather</a> data into our ghosted share space from their owners. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecSpace</td><td>exectution space </td></tr>
    <tr><td class="paramname">SparseArrayType</td><td>sparse array type </td></tr>
    <tr><td class="paramname">SparseMapType</td><td>sparse map type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>execution space </td></tr>
    <tr><td class="paramname">sparse_array</td><td>sparse <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> array used to store grid data </td></tr>
    <tr><td class="paramname">is_neighbor_counting_collected</td><td>label if the neighbor has already been collected; if true, it means all neighbor counting information is up-to-date and there's no need for recollection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a569ba6f225cbe72ebd0d4e6f3ca645" name="a4a569ba6f225cbe72ebd0d4e6f3ca645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a569ba6f225cbe72ebd0d4e6f3ca645">&#9670;&#160;</a></span>gatherValidSendAndRecvRanks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::gatherValidSendAndRecvRanks </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>valid_sends</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>valid_recvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_neighbor_counting_collected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>collect all valid ranks for sparse grid gather operations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>MPI communicator </td></tr>
    <tr><td class="paramname">valid_sends</td><td>neighbor array id that requires data from current rank </td></tr>
    <tr><td class="paramname">valid_recvs</td><td>neighbor array id the current ranks requires data from </td></tr>
    <tr><td class="paramname">is_neighbor_counting_collected</td><td>label if the neighbor has already been collected; if true, it means all neighbor counting information is up-to-date and there's no need for recollection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac905a4b8bfae8e4fb6e8bfe60c704cc5" name="ac905a4b8bfae8e4fb6e8bfe60c704cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac905a4b8bfae8e4fb6e8bfe60c704cc5">&#9670;&#160;</a></span>packBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<div class="memtemplate">
template&lt;class ExecSpace , class SparseArrayType , class CountType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::packBuffer </td>
          <td>(</td>
          <td class="paramtype">const ExecSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#adee005ea512fdbd9acb04d1546c006ef">buffer_view</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a20aa8f28c2201f4689177ab548fc8cfb">steering_view</a> &amp;&#160;</td>
          <td class="paramname"><em>tile_steering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseArrayType &amp;&#160;</td>
          <td class="paramname"><em>sparse_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountType&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack sparse arrays at halo regions into a buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecSpace</td><td>execution space type </td></tr>
    <tr><td class="paramname">SparseArrayType</td><td>sparse array type </td></tr>
    <tr><td class="paramname">CountType</td><td>counting number type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>execution space </td></tr>
    <tr><td class="paramname">buffer</td><td>buffer to store sparse array data and to communicate </td></tr>
    <tr><td class="paramname">tile_steering</td><td>Kokkos view to store halo tile keys </td></tr>
    <tr><td class="paramname">sparse_array</td><td>sparse array (all sparse grids on current rank) </td></tr>
    <tr><td class="paramname">count</td><td>number of halo grids to pack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21c10b47c3380102e3c80b878b3671c4" name="a21c10b47c3380102e3c80b878b3671c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c10b47c3380102e3c80b878b3671c4">&#9670;&#160;</a></span>register_halo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<div class="memtemplate">
template&lt;class ExecSpace , class SparseMapType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::register_halo </td>
          <td>(</td>
          <td class="paramtype">SparseMapType &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>register valid halos (according to grid activation status in sparse map) in the steerings </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecSpace</td><td>execution space </td></tr>
    <tr><td class="paramname">SparseMapType</td><td>sparse map type </td></tr>
    <tr><td class="paramname">scalar_type</td><td>scalar type (type of dx) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>sparse map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47864a58a44132ec9bfcc7fc6647eb8f" name="a47864a58a44132ec9bfcc7fc6647eb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47864a58a44132ec9bfcc7fc6647eb8f">&#9670;&#160;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<div class="memtemplate">
template&lt;class ExecSpace , class ReduceOp , class SparseArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::scatter </td>
          <td>(</td>
          <td class="paramtype">const ExecSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ReduceOp &amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseArrayType &amp;&#160;</td>
          <td class="paramname"><em>sparse_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_neighbor_counting_collected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classCabana_1_1Scatter.html" title="Synchronously scatter data from the ghosts to the local decomposition of a slice using the halo rever...">Scatter</a> data from our ghosts to their owners using the given type of reduce operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecSpace</td><td>exectution space </td></tr>
    <tr><td class="paramname">ReduceOp</td><td>The type of reduction functor </td></tr>
    <tr><td class="paramname">SparseArrayType</td><td>sparse array type </td></tr>
    <tr><td class="paramname">SparseMapType</td><td>sparse map type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>execution space </td></tr>
    <tr><td class="paramname">reduce_op</td><td>The functor used to reduce the results </td></tr>
    <tr><td class="paramname">sparse_array</td><td>sparse <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a> array used to store grid data </td></tr>
    <tr><td class="paramname">is_neighbor_counting_collected</td><td>label if the neighbor has already been collected; if true, it means all neighbor counting information is up-to-date and there's no need for recollection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac25ae7ddc9cf17d0cc9f911209c20c1e" name="ac25ae7ddc9cf17d0cc9f911209c20c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25ae7ddc9cf17d0cc9f911209c20c1e">&#9670;&#160;</a></span>scatterValidSendAndRecvRanks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::scatterValidSendAndRecvRanks </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>valid_sends</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>valid_recvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_neighbor_counting_collected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>collect all valid ranks for sparse grid scatter operations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>MPI communicator </td></tr>
    <tr><td class="paramname">valid_sends</td><td>neighbor array id that requires data from current rank </td></tr>
    <tr><td class="paramname">valid_recvs</td><td>neighbor array id the current ranks requires data from </td></tr>
    <tr><td class="paramname">is_neighbor_counting_collected</td><td>label if the neighbor has already been collected; if true, it means all neighbor counting information is up-to-date and there's no need for recollection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38dc08768a3a8c2c5f363eed5e123500" name="a38dc08768a3a8c2c5f363eed5e123500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38dc08768a3a8c2c5f363eed5e123500">&#9670;&#160;</a></span>unpackBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<div class="memtemplate">
template&lt;class ReduceOp , class ExecSpace , class SparseArrayType , class SparseMapType , class CountType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::unpackBuffer </td>
          <td>(</td>
          <td class="paramtype">const ReduceOp &amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#adee005ea512fdbd9acb04d1546c006ef">buffer_view</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#a20aa8f28c2201f4689177ab548fc8cfb">steering_view</a> &amp;&#160;</td>
          <td class="paramname"><em>tile_steering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseArrayType &amp;&#160;</td>
          <td class="paramname"><em>sparse_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseMapType &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountType&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a sparse array communication buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>reduce functor type </td></tr>
    <tr><td class="paramname">ExecSpace</td><td>execution space type </td></tr>
    <tr><td class="paramname">SparseArrayType</td><td>sparse array type </td></tr>
    <tr><td class="paramname">SparseMapType</td><td>sparse map type </td></tr>
    <tr><td class="paramname">CountType</td><td>counting number type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>reduce operation </td></tr>
    <tr><td class="paramname">exec_space</td><td>execution space </td></tr>
    <tr><td class="paramname">buffer</td><td>buffer to store sparse array data and to communicate </td></tr>
    <tr><td class="paramname">tile_steering</td><td>Kokkos view to store halo tile keys </td></tr>
    <tr><td class="paramname">sparse_array</td><td>sparse array (all sparse grids on current rank) </td></tr>
    <tr><td class="paramname">map</td><td>sparse map that has valid grids registered </td></tr>
    <tr><td class="paramname">count</td><td>number of halo grids to unpack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9aeac20ab5a7e0d5aa71f3497ea663b6" name="a9aeac20ab5a7e0d5aa71f3497ea663b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aeac20ab5a7e0d5aa71f3497ea663b6">&#9670;&#160;</a></span>unpackTuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<div class="memtemplate">
template&lt;class ReduceOp , class SoAType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static KOKKOS_FORCEINLINE_FUNCTION void <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::unpackTuple </td>
          <td>(</td>
          <td class="paramtype">const ReduceOp &amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ad396715ca570fa51ffd5484bd37a0682">tuple_type</a> &amp;&#160;</td>
          <td class="paramname"><em>src_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SoAType &amp;&#160;</td>
          <td class="paramname"><em>dst_soa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>soa_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; std::size_t, 0 &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a sparse arrays tuple for it's member with index 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>reduce functor type </td></tr>
    <tr><td class="paramname">SoAType</td><td><a class="el" href="structCabana_1_1SoA.html">SoA</a> type in sparse array (which is an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>reduce operation </td></tr>
    <tr><td class="paramname">src_tuple</td><td>source tuple </td></tr>
    <tr><td class="paramname">dst_soa</td><td>destination <a class="el" href="structCabana_1_1SoA.html">SoA</a> to store copied data </td></tr>
    <tr><td class="paramname">soa_idx</td><td>tuple index inside the destination <a class="el" href="structCabana_1_1SoA.html">SoA</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae36df4dfaccc333a9a7b4715b0443054" name="ae36df4dfaccc333a9a7b4715b0443054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36df4dfaccc333a9a7b4715b0443054">&#9670;&#160;</a></span>unpackTuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<div class="memtemplate">
template&lt;class ReduceOp , std::size_t N, class SoAType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static KOKKOS_FORCEINLINE_FUNCTION void <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::unpackTuple </td>
          <td>(</td>
          <td class="paramtype">const ReduceOp &amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ad396715ca570fa51ffd5484bd37a0682">tuple_type</a> &amp;&#160;</td>
          <td class="paramname"><em>src_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SoAType &amp;&#160;</td>
          <td class="paramname"><em>dst_soa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>soa_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; std::size_t, N &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a sparse arrays tuple for all members when element ID!=0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>reduce functor type </td></tr>
    <tr><td class="paramname">SoAType</td><td><a class="el" href="structCabana_1_1SoA.html">SoA</a> type in sparse array (which is an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) </td></tr>
    <tr><td class="paramname">N</td><td>Unpack N-th data member in this call </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>reduce operation </td></tr>
    <tr><td class="paramname">src_tuple</td><td>source tuple </td></tr>
    <tr><td class="paramname">dst_soa</td><td>destination <a class="el" href="structCabana_1_1SoA.html">SoA</a> to store copied data </td></tr>
    <tr><td class="paramname">soa_idx</td><td>tuple index inside the destination <a class="el" href="structCabana_1_1SoA.html">SoA</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43ba27d5ad22ba54232c29cfc39fec0b" name="a43ba27d5ad22ba54232c29cfc39fec0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ba27d5ad22ba54232c29cfc39fec0b">&#9670;&#160;</a></span>unpackTupleMember() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<div class="memtemplate">
template&lt;class ReduceOp , std::size_t N, std::size_t M, class SoAType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static KOKKOS_FORCEINLINE_FUNCTION std::enable_if_t&lt; 0==M, void &gt; <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::unpackTupleMember </td>
          <td>(</td>
          <td class="paramtype">const ReduceOp &amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ad396715ca570fa51ffd5484bd37a0682">tuple_type</a> &amp;&#160;</td>
          <td class="paramname"><em>src_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SoAType &amp;&#160;</td>
          <td class="paramname"><em>dst_soa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>soa_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::Array&lt; std::size_t, M &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; std::size_t, N &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; std::size_t, M &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a sparse arrays element (a tuple) in a buffer (for case tuple members with rank == 0) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>reduce functor type </td></tr>
    <tr><td class="paramname">N</td><td>element ID inside a <a class="el" href="structCabana_1_1SoA.html">SoA</a> tuple (N-th data member) </td></tr>
    <tr><td class="paramname">M</td><td>rank number of the current element (N-th data member) </td></tr>
    <tr><td class="paramname">SoAType</td><td><a class="el" href="structCabana_1_1SoA.html">SoA</a> type in sparse array (which is an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>reduce operation </td></tr>
    <tr><td class="paramname">src_tuple</td><td>source tuple </td></tr>
    <tr><td class="paramname">dst_soa</td><td>destination <a class="el" href="structCabana_1_1SoA.html">SoA</a> to store copied data </td></tr>
    <tr><td class="paramname">soa_idx</td><td>tuple index inside the destination <a class="el" href="structCabana_1_1SoA.html">SoA</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41dbb3106ef8173c2fc3c70932603c18" name="a41dbb3106ef8173c2fc3c70932603c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41dbb3106ef8173c2fc3c70932603c18">&#9670;&#160;</a></span>unpackTupleMember() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<div class="memtemplate">
template&lt;class ReduceOp , std::size_t N, std::size_t M, class SoAType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static KOKKOS_FORCEINLINE_FUNCTION std::enable_if_t&lt; 3==M, void &gt; <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::unpackTupleMember </td>
          <td>(</td>
          <td class="paramtype">const ReduceOp &amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ad396715ca570fa51ffd5484bd37a0682">tuple_type</a> &amp;&#160;</td>
          <td class="paramname"><em>src_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SoAType &amp;&#160;</td>
          <td class="paramname"><em>dst_soa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>soa_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::Array&lt; std::size_t, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; std::size_t, N &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; std::size_t, M &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a sparse arrays element (a tuple) in a buffer (for case tuple members with rank == 3) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>reduce functor type </td></tr>
    <tr><td class="paramname">N</td><td>element ID inside a <a class="el" href="structCabana_1_1SoA.html">SoA</a> tuple (N-th data member) </td></tr>
    <tr><td class="paramname">M</td><td>rank number of the current element (N-th data member) </td></tr>
    <tr><td class="paramname">SoAType</td><td><a class="el" href="structCabana_1_1SoA.html">SoA</a> type in sparse array (which is an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>reduce operation </td></tr>
    <tr><td class="paramname">src_tuple</td><td>source tuple </td></tr>
    <tr><td class="paramname">dst_soa</td><td>destination <a class="el" href="structCabana_1_1SoA.html">SoA</a> to store copied data </td></tr>
    <tr><td class="paramname">soa_idx</td><td>tuple index inside the destination <a class="el" href="structCabana_1_1SoA.html">SoA</a> </td></tr>
    <tr><td class="paramname">extents</td><td>element member extents in all ranks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11a7877f6aa505b9a063e7b8018a83fd" name="a11a7877f6aa505b9a063e7b8018a83fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a7877f6aa505b9a063e7b8018a83fd">&#9670;&#160;</a></span>unpackTupleMember() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<div class="memtemplate">
template&lt;class ReduceOp , std::size_t N, std::size_t M, class SoAType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static KOKKOS_FORCEINLINE_FUNCTION std::enable_if_t&lt; 2==M, void &gt; <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::unpackTupleMember </td>
          <td>(</td>
          <td class="paramtype">const ReduceOp &amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ad396715ca570fa51ffd5484bd37a0682">tuple_type</a> &amp;&#160;</td>
          <td class="paramname"><em>src_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SoAType &amp;&#160;</td>
          <td class="paramname"><em>dst_soa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>soa_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::Array&lt; std::size_t, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; std::size_t, N &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; std::size_t, M &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a sparse arrays element (a tuple) in a buffer (for case tuple members with rank == 2) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>reduce functor type </td></tr>
    <tr><td class="paramname">N</td><td>element ID inside a <a class="el" href="structCabana_1_1SoA.html">SoA</a> tuple (N-th data member) </td></tr>
    <tr><td class="paramname">M</td><td>rank number of the current element (N-th data member) </td></tr>
    <tr><td class="paramname">SoAType</td><td><a class="el" href="structCabana_1_1SoA.html">SoA</a> type in sparse array (which is an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>reduce operation </td></tr>
    <tr><td class="paramname">src_tuple</td><td>source tuple </td></tr>
    <tr><td class="paramname">dst_soa</td><td>destination <a class="el" href="structCabana_1_1SoA.html">SoA</a> to store copied data </td></tr>
    <tr><td class="paramname">soa_idx</td><td>tuple index inside the destination <a class="el" href="structCabana_1_1SoA.html">SoA</a> </td></tr>
    <tr><td class="paramname">extents</td><td>element member extents in all ranks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2b3bc1ebfcefbf57bbda99663fa5869" name="ae2b3bc1ebfcefbf57bbda99663fa5869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b3bc1ebfcefbf57bbda99663fa5869">&#9670;&#160;</a></span>unpackTupleMember() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<div class="memtemplate">
template&lt;class ReduceOp , std::size_t N, std::size_t M, class SoAType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static KOKKOS_FORCEINLINE_FUNCTION std::enable_if_t&lt; 1==M, void &gt; <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::unpackTupleMember </td>
          <td>(</td>
          <td class="paramtype">const ReduceOp &amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#ad396715ca570fa51ffd5484bd37a0682">tuple_type</a> &amp;&#160;</td>
          <td class="paramname"><em>src_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SoAType &amp;&#160;</td>
          <td class="paramname"><em>dst_soa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>soa_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::Array&lt; std::size_t, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; std::size_t, N &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; std::size_t, M &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a sparse arrays element (a tuple) in a buffer (for case tuple members with rank == 1) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>reduce functor type </td></tr>
    <tr><td class="paramname">N</td><td>element ID inside a <a class="el" href="structCabana_1_1SoA.html">SoA</a> tuple (N-th data member) </td></tr>
    <tr><td class="paramname">M</td><td>rank number of the current element (N-th data member) </td></tr>
    <tr><td class="paramname">SoAType</td><td><a class="el" href="structCabana_1_1SoA.html">SoA</a> type in sparse array (which is an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays.">AoSoA</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>reduce operation </td></tr>
    <tr><td class="paramname">src_tuple</td><td>source tuple </td></tr>
    <tr><td class="paramname">dst_soa</td><td>destination <a class="el" href="structCabana_1_1SoA.html">SoA</a> to store copied data </td></tr>
    <tr><td class="paramname">soa_idx</td><td>tuple index inside the destination <a class="el" href="structCabana_1_1SoA.html">SoA</a> </td></tr>
    <tr><td class="paramname">extents</td><td>element member extents in all ranks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44ea1af92073388e8f6de0b47def606b" name="a44ea1af92073388e8f6de0b47def606b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ea1af92073388e8f6de0b47def606b">&#9670;&#160;</a></span>updateTileSpace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<div class="memtemplate">
template&lt;class LocalGridType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::updateTileSpace </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; LocalGridType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update tile index space according to current partition </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LocalGridType</td><td>sparse local grid type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_grid</td><td>sparse local grid pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afb4e06ee0e7d95e311c1a2693efbe15d" name="afb4e06ee0e7d95e311c1a2693efbe15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4e06ee0e7d95e311c1a2693efbe15d">&#9670;&#160;</a></span>cell_bits_per_tile_dim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned long long <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::cell_bits_per_tile_dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        cellBitsPerTileDim</div>
</div><!-- fragment -->
<p>sparse grid hierarchy: cell id bit# per dimension </p>

</div>
</div>
<a id="aeea91000b0ba3f493d69241b4f581e5a" name="aeea91000b0ba3f493d69241b4f581e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea91000b0ba3f493d69241b4f581e5a">&#9670;&#160;</a></span>cell_num_per_tile</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class DataTypes , class EntityType , std::size_t NumSpaceDim, unsigned long long cellBitsPerTileDim, typename Value  = int, typename Key  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned long long <a class="el" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html">Cabana::Grid::Experimental::SparseHalo</a>&lt; MemorySpace, DataTypes, EntityType, NumSpaceDim, cellBitsPerTileDim, Value, Key &gt;::cell_num_per_tile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        1 &lt;&lt; ( <a class="code hl_variable" href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#afb4e06ee0e7d95e311c1a2693efbe15d">cell_bits_per_tile_dim</a> * 3 )</div>
<div class="ttc" id="aclassCabana_1_1Grid_1_1Experimental_1_1SparseHalo_html_afb4e06ee0e7d95e311c1a2693efbe15d"><div class="ttname"><a href="classCabana_1_1Grid_1_1Experimental_1_1SparseHalo.html#afb4e06ee0e7d95e311c1a2693efbe15d">Cabana::Grid::Experimental::SparseHalo::cell_bits_per_tile_dim</a></div><div class="ttdeci">static constexpr unsigned long long cell_bits_per_tile_dim</div><div class="ttdoc">sparse grid hierarchy: cell id bit# per dimension</div><div class="ttdef"><b>Definition:</b> Cabana_Grid_SparseHalo.hpp:88</div></div>
</div><!-- fragment -->
<p>sparse grid hierarchy: cell # per dimension </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>grid/src/<a class="el" href="Cabana__Grid__SparseHalo_8hpp_source.html">Cabana_Grid_SparseHalo.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
