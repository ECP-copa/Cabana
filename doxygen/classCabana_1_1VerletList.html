<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cabana: Cabana::VerletList&lt; MemorySpace, AlgorithmTag, LayoutTag, BuildTag, NumSpaceDim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cabana<span id="projectnumber">&#160;0.8.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classCabana_1_1VerletList.html','','classCabana_1_1VerletList-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Cabana::VerletList&lt; MemorySpace, AlgorithmTag, LayoutTag, BuildTag, NumSpaceDim &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Neighbor list implementation based on binning particles on a Cartesian grid with cells of the same size as the interaction distance.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Cabana__VerletList_8hpp_source.html">Cabana_VerletList.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Cabana::VerletList&lt; MemorySpace, AlgorithmTag, LayoutTag, BuildTag, NumSpaceDim &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classCabana_1_1VerletList__coll__graph.png" border="0" usemap="#aCabana_1_1VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01LayoutTag_00_01BuildTag_00_01NumSpaceDim_01_4_coll__map" loading="lazy" alt="Collaboration graph"/></div>
<map name="aCabana_1_1VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01LayoutTag_00_01BuildTag_00_01NumSpaceDim_01_4_coll__map" id="aCabana_1_1VerletList_3_01MemorySpace_00_01AlgorithmTag_00_01LayoutTag_00_01BuildTag_00_01NumSpaceDim_01_4_coll__map">
<area shape="rect" title="Neighbor list implementation based on binning particles on a Cartesian grid with cells of the same si..." alt="" coords="5,129,261,197"/>
<area shape="rect" href="structCabana_1_1VerletListData.html" title=" " alt="" coords="29,5,237,54"/>
<area shape="poly" title=" " alt="" coords="136,69,136,129,130,129,130,69"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af1209250b5adaca14570ab8df18ff2b4" id="r_af1209250b5adaca14570ab8df18ff2b4"><td class="memItemLeft" align="right" valign="top"><a id="af1209250b5adaca14570ab8df18ff2b4" name="af1209250b5adaca14570ab8df18ff2b4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>memory_space</b> = MemorySpace</td></tr>
<tr class="memdesc:af1209250b5adaca14570ab8df18ff2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kokkos memory space in which the neighbor list data resides. <br /></td></tr>
<tr class="memitem:a22cbd4b338d1e22852a41e832a76af91" id="r_a22cbd4b338d1e22852a41e832a76af91"><td class="memItemLeft" align="right" valign="top"><a id="a22cbd4b338d1e22852a41e832a76af91" name="a22cbd4b338d1e22852a41e832a76af91"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>execution_space</b> = typename memory_space::execution_space</td></tr>
<tr class="memdesc:a22cbd4b338d1e22852a41e832a76af91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kokkos default execution space for this memory space. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a861a64bf5ddc88c0397a52ff717d8d16" id="r_a861a64bf5ddc88c0397a52ff717d8d16"><td class="memItemLeft" align="right" valign="top"><a id="a861a64bf5ddc88c0397a52ff717d8d16" name="a861a64bf5ddc88c0397a52ff717d8d16"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VerletList</b> ()=default</td></tr>
<tr class="memdesc:a861a64bf5ddc88c0397a52ff717d8d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="memitem:a4ecd06f11ea5e74b434df98b7726e91f" id="r_a4ecd06f11ea5e74b434df98b7726e91f"><td class="memTemplParams" colspan="2">template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args&gt; </td></tr>
<tr class="memitem:a4ecd06f11ea5e74b434df98b7726e91f template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ecd06f11ea5e74b434df98b7726e91f">VerletList</a> (PositionType x, const std::size_t begin, const std::size_t end, const typename PositionType::value_type neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_min, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_max, const std::size_t max_neigh=0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a4ecd06f11ea5e74b434df98b7726e91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of particle positions and a neighborhood radius calculate the neighbor list.  <br /></td></tr>
<tr class="memitem:af2b037181e4ea9d5c3b729f02415f301" id="r_af2b037181e4ea9d5c3b729f02415f301"><td class="memTemplParams" colspan="2">template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args&gt; </td></tr>
<tr class="memitem:af2b037181e4ea9d5c3b729f02415f301 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2b037181e4ea9d5c3b729f02415f301">build</a> (PositionType x, const std::size_t begin, const std::size_t end, const typename PositionType::value_type neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_min, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_max, const std::size_t max_neigh=0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:af2b037181e4ea9d5c3b729f02415f301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of particle positions and a neighborhood radius calculate the neighbor list.  <br /></td></tr>
<tr class="memitem:a54a2ef939a7679b5d71b9669348926cd" id="r_a54a2ef939a7679b5d71b9669348926cd"><td class="memTemplParams" colspan="2">template&lt;class PositionType, class RadiusType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args&gt; </td></tr>
<tr class="memitem:a54a2ef939a7679b5d71b9669348926cd template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54a2ef939a7679b5d71b9669348926cd">VerletList</a> (PositionType x, const std::size_t begin, const std::size_t end, const typename PositionType::value_type background_radius, RadiusType neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_min, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_max, const std::size_t max_neigh=0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a54a2ef939a7679b5d71b9669348926cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of particle positions and a neighborhood radius calculate the neighbor list.  <br /></td></tr>
<tr class="memitem:a56318e5b2f47fd34c11203959e463d45" id="r_a56318e5b2f47fd34c11203959e463d45"><td class="memTemplParams" colspan="2">template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args&gt; </td></tr>
<tr class="memitem:a56318e5b2f47fd34c11203959e463d45 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56318e5b2f47fd34c11203959e463d45">VerletList</a> (PositionType x, const typename PositionType::value_type neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_min, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_max, const std::size_t max_neigh=0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a56318e5b2f47fd34c11203959e463d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of particle positions and a neighborhood radius calculate the neighbor list.  <br /></td></tr>
<tr class="memitem:aeecd8e9b34aa499ed728fa7578a6d4e4" id="r_aeecd8e9b34aa499ed728fa7578a6d4e4"><td class="memTemplParams" colspan="2"><a id="aeecd8e9b34aa499ed728fa7578a6d4e4" name="aeecd8e9b34aa499ed728fa7578a6d4e4"></a>
template&lt;class PositionType&gt; </td></tr>
<tr class="memitem:aeecd8e9b34aa499ed728fa7578a6d4e4 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>VerletList</b> (PositionType x, const std::size_t begin, const std::size_t end, const typename PositionType::value_type neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const typename PositionType::value_type grid_min[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const typename PositionType::value_type grid_max[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const std::size_t max_neigh=0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:aeecd8e9b34aa499ed728fa7578a6d4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of particle positions and a neighborhood radius calculate the neighbor list. <br /></td></tr>
<tr class="memitem:af67e05a4b2bc0d4f5e0c2b9e9eedae67" id="r_af67e05a4b2bc0d4f5e0c2b9e9eedae67"><td class="memTemplParams" colspan="2"><a id="af67e05a4b2bc0d4f5e0c2b9e9eedae67" name="af67e05a4b2bc0d4f5e0c2b9e9eedae67"></a>
template&lt;class PositionType&gt; </td></tr>
<tr class="memitem:af67e05a4b2bc0d4f5e0c2b9e9eedae67 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>VerletList</b> (PositionType x, const typename PositionType::value_type neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const typename PositionType::value_type grid_min[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const typename PositionType::value_type grid_max[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const std::size_t max_neigh=0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:af67e05a4b2bc0d4f5e0c2b9e9eedae67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of particle positions and a neighborhood radius calculate the neighbor list.s. <br /></td></tr>
<tr class="memitem:a685ce848fff646bcbba443e58d80850b" id="r_a685ce848fff646bcbba443e58d80850b"><td class="memTemplParams" colspan="2"><a id="a685ce848fff646bcbba443e58d80850b" name="a685ce848fff646bcbba443e58d80850b"></a>
template&lt;class PositionType, class RadiusType&gt; </td></tr>
<tr class="memitem:a685ce848fff646bcbba443e58d80850b template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>VerletList</b> (PositionType x, const std::size_t begin, const std::size_t end, const typename PositionType::value_type background_radius, RadiusType neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const typename PositionType::value_type grid_min[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const typename PositionType::value_type grid_max[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const std::size_t max_neigh=0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a685ce848fff646bcbba443e58d80850b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of particle positions and a neighborhood radius calculate the neighbor list. <br /></td></tr>
<tr class="memitem:ad916cf7910024331fb4b6c64ddc34ee1" id="r_ad916cf7910024331fb4b6c64ddc34ee1"><td class="memTemplParams" colspan="2">template&lt;class PositionType, class RadiusType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args&gt; </td></tr>
<tr class="memitem:ad916cf7910024331fb4b6c64ddc34ee1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad916cf7910024331fb4b6c64ddc34ee1">build</a> (PositionType x, const std::size_t begin, const std::size_t end, const typename PositionType::value_type background_radius, RadiusType neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_min, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_max, const std::size_t max_neigh=0)</td></tr>
<tr class="memdesc:ad916cf7910024331fb4b6c64ddc34ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of particle positions and a neighborhood radius calculate the neighbor list.  <br /></td></tr>
<tr class="memitem:ae3adc4bbb20f7502278676b60a5b047e" id="r_ae3adc4bbb20f7502278676b60a5b047e"><td class="memTemplParams" colspan="2">template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args&gt; </td></tr>
<tr class="memitem:ae3adc4bbb20f7502278676b60a5b047e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3adc4bbb20f7502278676b60a5b047e">build</a> (PositionType x, const typename PositionType::value_type neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_min, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_max, const std::size_t max_neigh=0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:ae3adc4bbb20f7502278676b60a5b047e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a Cartesian grid with cells of the same si...">VerletList</a> constructor. Given a list of particle positions and a neighborhood radius calculate the neighbor list.  <br /></td></tr>
<tr class="memitem:aab68f0bea9132725ed49edefeeeef89e" id="r_aab68f0bea9132725ed49edefeeeef89e"><td class="memTemplParams" colspan="2"><a id="aab68f0bea9132725ed49edefeeeef89e" name="aab68f0bea9132725ed49edefeeeef89e"></a>
template&lt;class PositionType&gt; </td></tr>
<tr class="memitem:aab68f0bea9132725ed49edefeeeef89e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>build</b> (PositionType x, const std::size_t begin, const std::size_t end, const typename PositionType::value_type neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const typename PositionType::value_type grid_min[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const typename PositionType::value_type grid_max[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const std::size_t max_neigh=0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:aab68f0bea9132725ed49edefeeeef89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of particle positions and a neighborhood radius calculate the neighbor list. <br /></td></tr>
<tr class="memitem:a117995fb4b6993e6647dbbf32b38b149" id="r_a117995fb4b6993e6647dbbf32b38b149"><td class="memTemplParams" colspan="2"><a id="a117995fb4b6993e6647dbbf32b38b149" name="a117995fb4b6993e6647dbbf32b38b149"></a>
template&lt;class PositionType, class ExecutionSpace&gt; </td></tr>
<tr class="memitem:a117995fb4b6993e6647dbbf32b38b149 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>build</b> (ExecutionSpace exec_space, PositionType x, const std::size_t begin, const std::size_t end, const typename PositionType::value_type neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const typename PositionType::value_type grid_min[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const typename PositionType::value_type grid_max[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const std::size_t max_neigh=0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a117995fb4b6993e6647dbbf32b38b149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of particle positions and a neighborhood radius calculate the neighbor list. <br /></td></tr>
<tr class="memitem:aec55ec7ba8b25541a555c1e4b87f4393" id="r_aec55ec7ba8b25541a555c1e4b87f4393"><td class="memTemplParams" colspan="2"><a id="aec55ec7ba8b25541a555c1e4b87f4393" name="aec55ec7ba8b25541a555c1e4b87f4393"></a>
template&lt;class PositionType, class RadiusType&gt; </td></tr>
<tr class="memitem:aec55ec7ba8b25541a555c1e4b87f4393 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>build</b> (PositionType x, const std::size_t begin, const std::size_t end, const typename PositionType::value_type background_radius, RadiusType neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const typename PositionType::value_type grid_min[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const typename PositionType::value_type grid_max[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const std::size_t max_neigh=0)</td></tr>
<tr class="memdesc:aec55ec7ba8b25541a555c1e4b87f4393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of particle positions and a neighborhood radius calculate the neighbor list. <br /></td></tr>
<tr class="memitem:a826aeb585b7b518aa2ac89b109ff5088" id="r_a826aeb585b7b518aa2ac89b109ff5088"><td class="memTemplParams" colspan="2"><a id="a826aeb585b7b518aa2ac89b109ff5088" name="a826aeb585b7b518aa2ac89b109ff5088"></a>
template&lt;class PositionType&gt; </td></tr>
<tr class="memitem:a826aeb585b7b518aa2ac89b109ff5088 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>build</b> (PositionType x, const typename PositionType::value_type neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const typename PositionType::value_type grid_min[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const typename PositionType::value_type grid_max[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const std::size_t max_neigh=0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a826aeb585b7b518aa2ac89b109ff5088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of particle positions and a neighborhood radius calculate the neighbor list. <br /></td></tr>
<tr class="memitem:a7173bf4034de7fec00f8265a9e440933" id="r_a7173bf4034de7fec00f8265a9e440933"><td class="memTemplParams" colspan="2"><a id="a7173bf4034de7fec00f8265a9e440933" name="a7173bf4034de7fec00f8265a9e440933"></a>
template&lt;class PositionType, class RadiusType, class ExecutionSpace&gt; </td></tr>
<tr class="memitem:a7173bf4034de7fec00f8265a9e440933 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>build</b> (ExecutionSpace exec_space, PositionType x, const std::size_t begin, const std::size_t end, const typename PositionType::value_type background_radius, RadiusType neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const typename PositionType::value_type grid_min[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const typename PositionType::value_type grid_max[<a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a>], const std::size_t max_neigh=0)</td></tr>
<tr class="memdesc:a7173bf4034de7fec00f8265a9e440933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of particle positions and a neighborhood radius calculate the neighbor list. <br /></td></tr>
<tr class="memitem:af6be7b034a7763a2f882fdc44879af5b" id="r_af6be7b034a7763a2f882fdc44879af5b"><td class="memTemplParams" colspan="2"><a id="af6be7b034a7763a2f882fdc44879af5b" name="af6be7b034a7763a2f882fdc44879af5b"></a>
template&lt;class PositionType, class ExecutionSpace, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args&gt; </td></tr>
<tr class="memitem:af6be7b034a7763a2f882fdc44879af5b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>build</b> (ExecutionSpace, PositionType x, const std::size_t begin, const std::size_t end, const typename PositionType::value_type neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_min, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_max, const std::size_t max_neigh=0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:af6be7b034a7763a2f882fdc44879af5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of particle positions and a neighborhood radius calculate the neighbor list. <br /></td></tr>
<tr class="memitem:a7128bd5a261b4a40e9324147cf92e10e" id="r_a7128bd5a261b4a40e9324147cf92e10e"><td class="memTemplParams" colspan="2"><a id="a7128bd5a261b4a40e9324147cf92e10e" name="a7128bd5a261b4a40e9324147cf92e10e"></a>
template&lt;class PositionType, class RadiusType, class ExecutionSpace, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args&gt; </td></tr>
<tr class="memitem:a7128bd5a261b4a40e9324147cf92e10e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>build</b> (ExecutionSpace, PositionType x, const std::size_t begin, const std::size_t end, const typename PositionType::value_type background_radius, RadiusType neighborhood_radius, const typename PositionType::value_type cell_size_ratio, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_min, const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt; grid_max, const std::size_t max_neigh=0)</td></tr>
<tr class="memdesc:a7128bd5a261b4a40e9324147cf92e10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of particle positions and a neighborhood radius calculate the neighbor list. <br /></td></tr>
<tr class="memitem:a8ca468a94a9e1a536c4186387565b03d" id="r_a8ca468a94a9e1a536c4186387565b03d"><td class="memItemLeft" align="right" valign="top"><a id="a8ca468a94a9e1a536c4186387565b03d" name="a8ca468a94a9e1a536c4186387565b03d"></a>
KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memItemRight" valign="bottom"><b>setNeighbor</b> (const std::size_t particle_index, const std::size_t neighbor_index, const int new_index) const</td></tr>
<tr class="memdesc:a8ca468a94a9e1a536c4186387565b03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a neighbor in the list; for example, mark it as a broken bond. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa29e8d47a87aab59b393b4cff326d194" id="r_aa29e8d47a87aab59b393b4cff326d194"><td class="memItemLeft" align="right" valign="top"><a id="aa29e8d47a87aab59b393b4cff326d194" name="aa29e8d47a87aab59b393b4cff326d194"></a>
<a class="el" href="structCabana_1_1VerletListData.html">VerletListData</a>&lt; <a class="el" href="#af1209250b5adaca14570ab8df18ff2b4">memory_space</a>, LayoutTag &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_data</b></td></tr>
<tr class="memdesc:aa29e8d47a87aab59b393b4cff326d194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verlet list data. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af4a6b14c7a92275109f85097215817b7" id="r_af4a6b14c7a92275109f85097215817b7"><td class="memItemLeft" align="right" valign="top"><a id="af4a6b14c7a92275109f85097215817b7" name="af4a6b14c7a92275109f85097215817b7"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_space_dim</b> = NumSpaceDim</td></tr>
<tr class="memdesc:af4a6b14c7a92275109f85097215817b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial dimension. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class MemorySpace, class AlgorithmTag, class LayoutTag, class BuildTag = TeamVectorOpTag, std::size_t NumSpaceDim = 3&gt;<br />
class Cabana::VerletList&lt; MemorySpace, AlgorithmTag, LayoutTag, BuildTag, NumSpaceDim &gt;</div><p>Neighbor list implementation based on binning particles on a Cartesian grid with cells of the same size as the interaction distance. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MemorySpace</td><td>The Kokkos memory space for storing the neighbor list.</td></tr>
    <tr><td class="paramname">AlgorithmTag</td><td>Tag indicating whether to build a full or half neighbor list.</td></tr>
    <tr><td class="paramname">LayoutTag</td><td>Tag indicating whether to use a CSR or 2D data layout.</td></tr>
    <tr><td class="paramname">BuildTag</td><td>Tag indicating whether to use hierarchical team or team vector parallelism when building neighbor lists.</td></tr>
  </table>
  </dd>
</dl>
<p>Neighbor list implementation most appropriate for somewhat regularly distributed particles due to the use of a Cartesian grid. </p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4ecd06f11ea5e74b434df98b7726e91f" name="a4ecd06f11ea5e74b434df98b7726e91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ecd06f11ea5e74b434df98b7726e91f">&#9670;&#160;</a></span>VerletList() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace, class AlgorithmTag, class LayoutTag, class BuildTag = TeamVectorOpTag, std::size_t NumSpaceDim = 3&gt; </div>
<div class="memtemplate">
template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1VerletList.html">Cabana::VerletList</a>&lt; MemorySpace, AlgorithmTag, LayoutTag, BuildTag, NumSpaceDim &gt;::VerletList </td>
          <td>(</td>
          <td class="paramtype">PositionType</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>neighborhood_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>cell_size_ratio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_neigh</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a list of particle positions and a neighborhood radius calculate the neighbor list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The particle positions </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning particle index to compute neighbors for. </td></tr>
    <tr><td class="paramname">end</td><td>The end particle index to compute neighbors for. </td></tr>
    <tr><td class="paramname">neighborhood_radius</td><td>The radius of the neighborhood. Particles within this radius are considered neighbors. This is effectively the grid cell size in each dimension. </td></tr>
    <tr><td class="paramname">cell_size_ratio</td><td>The ratio of the cell size in the Cartesian grid to the neighborhood radius. For example, if the cell size ratio is 0.5 then the cells will be half the size of the neighborhood radius in each dimension. </td></tr>
    <tr><td class="paramname">grid_min</td><td>The minimum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">grid_max</td><td>The maximum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">max_neigh</td><td>Optional maximum number of neighbors per particle to pre-allocate the neighbor list. Potentially avoids recounting with 2D layout only.</td></tr>
  </table>
  </dd>
</dl>
<p>Particles outside of the neighborhood radius will not be considered neighbors. Only compute the neighbors of those that are within the given range. All particles are candidates for being a neighbor, regardless of whether or not they are in the range. </p>

</div>
</div>
<a id="a54a2ef939a7679b5d71b9669348926cd" name="a54a2ef939a7679b5d71b9669348926cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a2ef939a7679b5d71b9669348926cd">&#9670;&#160;</a></span>VerletList() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace, class AlgorithmTag, class LayoutTag, class BuildTag = TeamVectorOpTag, std::size_t NumSpaceDim = 3&gt; </div>
<div class="memtemplate">
template&lt;class PositionType, class RadiusType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1VerletList.html">Cabana::VerletList</a>&lt; MemorySpace, AlgorithmTag, LayoutTag, BuildTag, NumSpaceDim &gt;::VerletList </td>
          <td>(</td>
          <td class="paramtype">PositionType</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>background_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RadiusType</td>          <td class="paramname"><span class="paramname"><em>neighborhood_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>cell_size_ratio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_neigh</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a list of particle positions and a neighborhood radius calculate the neighbor list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The slice containing the particle positions </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning particle index to compute neighbors for. </td></tr>
    <tr><td class="paramname">end</td><td>The end particle index to compute neighbors for. </td></tr>
    <tr><td class="paramname">background_radius</td><td>The radius of the neighborhood used for the background grid cells in each dimension. </td></tr>
    <tr><td class="paramname">neighborhood_radius</td><td>The radius of the neighborhood per particle. Particles within this radius are considered neighbors. </td></tr>
    <tr><td class="paramname">cell_size_ratio</td><td>The ratio of the cell size in the Cartesian grid to the neighborhood radius. For example, if the cell size ratio is 0.5 then the cells will be half the size of the neighborhood radius in each dimension. </td></tr>
    <tr><td class="paramname">grid_min</td><td>The minimum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">grid_max</td><td>The maximum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">max_neigh</td><td>Optional maximum number of neighbors per particle to pre-allocate the neighbor list. Potentially avoids recounting with 2D layout only.</td></tr>
  </table>
  </dd>
</dl>
<p>Particles outside of the neighborhood radius will not be considered neighbors. Only compute the neighbors of those that are within the given range. All particles are candidates for being a neighbor, regardless of whether or not they are in the range. </p>

</div>
</div>
<a id="a56318e5b2f47fd34c11203959e463d45" name="a56318e5b2f47fd34c11203959e463d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56318e5b2f47fd34c11203959e463d45">&#9670;&#160;</a></span>VerletList() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace, class AlgorithmTag, class LayoutTag, class BuildTag = TeamVectorOpTag, std::size_t NumSpaceDim = 3&gt; </div>
<div class="memtemplate">
template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1VerletList.html">Cabana::VerletList</a>&lt; MemorySpace, AlgorithmTag, LayoutTag, BuildTag, NumSpaceDim &gt;::VerletList </td>
          <td>(</td>
          <td class="paramtype">PositionType</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>neighborhood_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>cell_size_ratio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_neigh</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a list of particle positions and a neighborhood radius calculate the neighbor list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The slice containing the particle positions </td></tr>
    <tr><td class="paramname">neighborhood_radius</td><td>The radius of the neighborhood. Particles within this radius are considered neighbors. This is effectively the grid cell size in each dimension. </td></tr>
    <tr><td class="paramname">cell_size_ratio</td><td>The ratio of the cell size in the Cartesian grid to the neighborhood radius. For example, if the cell size ratio is 0.5 then the cells will be half the size of the neighborhood radius in each dimension. </td></tr>
    <tr><td class="paramname">grid_min</td><td>The minimum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">grid_max</td><td>The maximum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">max_neigh</td><td>Optional maximum number of neighbors per particle to pre-allocate the neighbor list. Potentially avoids recounting with 2D layout only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ad916cf7910024331fb4b6c64ddc34ee1" name="ad916cf7910024331fb4b6c64ddc34ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad916cf7910024331fb4b6c64ddc34ee1">&#9670;&#160;</a></span>build() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace, class AlgorithmTag, class LayoutTag, class BuildTag = TeamVectorOpTag, std::size_t NumSpaceDim = 3&gt; </div>
<div class="memtemplate">
template&lt;class PositionType, class RadiusType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1VerletList.html">Cabana::VerletList</a>&lt; MemorySpace, AlgorithmTag, LayoutTag, BuildTag, NumSpaceDim &gt;::build </td>
          <td>(</td>
          <td class="paramtype">PositionType</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>background_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RadiusType</td>          <td class="paramname"><span class="paramname"><em>neighborhood_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>cell_size_ratio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_neigh</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a list of particle positions and a neighborhood radius calculate the neighbor list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The particle positions </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning particle index to compute neighbors for. </td></tr>
    <tr><td class="paramname">end</td><td>The end particle index to compute neighbors for. </td></tr>
    <tr><td class="paramname">background_radius</td><td>The radius of the neighborhood used for the background grid cells in each dimension. </td></tr>
    <tr><td class="paramname">neighborhood_radius</td><td>The radius of the neighborhood per particle. Particles within this radius are considered neighbors. </td></tr>
    <tr><td class="paramname">cell_size_ratio</td><td>The ratio of the cell size in the Cartesian grid to the neighborhood radius. For example, if the cell size ratio is 0.5 then the cells will be half the size of the neighborhood radius in each dimension. </td></tr>
    <tr><td class="paramname">grid_min</td><td>The minimum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">grid_max</td><td>The maximum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">max_neigh</td><td>Optional maximum number of neighbors per particle to pre-allocate the neighbor list. Potentially avoids recounting with 2D layout only.</td></tr>
  </table>
  </dd>
</dl>
<p>Particles outside of the neighborhood radius will not be considered neighbors. Only compute the neighbors of those that are within the given range. All particles are candidates for being a neighbor, regardless of whether or not they are in the range. </p>

</div>
</div>
<a id="af2b037181e4ea9d5c3b729f02415f301" name="af2b037181e4ea9d5c3b729f02415f301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b037181e4ea9d5c3b729f02415f301">&#9670;&#160;</a></span>build() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace, class AlgorithmTag, class LayoutTag, class BuildTag = TeamVectorOpTag, std::size_t NumSpaceDim = 3&gt; </div>
<div class="memtemplate">
template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1VerletList.html">Cabana::VerletList</a>&lt; MemorySpace, AlgorithmTag, LayoutTag, BuildTag, NumSpaceDim &gt;::build </td>
          <td>(</td>
          <td class="paramtype">PositionType</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>neighborhood_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>cell_size_ratio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_neigh</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a list of particle positions and a neighborhood radius calculate the neighbor list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The particle positions </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning particle index to compute neighbors for. </td></tr>
    <tr><td class="paramname">end</td><td>The end particle index to compute neighbors for. </td></tr>
    <tr><td class="paramname">neighborhood_radius</td><td>The radius of the neighborhood. Particles within this radius are considered neighbors. This is effectively the grid cell size in each dimension. </td></tr>
    <tr><td class="paramname">cell_size_ratio</td><td>The ratio of the cell size in the Cartesian grid to the neighborhood radius. For example, if the cell size ratio is 0.5 then the cells will be half the size of the neighborhood radius in each dimension. </td></tr>
    <tr><td class="paramname">grid_min</td><td>The minimum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">grid_max</td><td>The maximum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">max_neigh</td><td>Optional maximum number of neighbors per particle to pre-allocate the neighbor list. Potentially avoids recounting with 2D layout only.</td></tr>
  </table>
  </dd>
</dl>
<p>Particles outside of the neighborhood radius will not be considered neighbors. Only compute the neighbors of those that are within the given range. All particles are candidates for being a neighbor, regardless of whether or not they are in the range. </p>

</div>
</div>
<a id="ae3adc4bbb20f7502278676b60a5b047e" name="ae3adc4bbb20f7502278676b60a5b047e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3adc4bbb20f7502278676b60a5b047e">&#9670;&#160;</a></span>build() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace, class AlgorithmTag, class LayoutTag, class BuildTag = TeamVectorOpTag, std::size_t NumSpaceDim = 3&gt; </div>
<div class="memtemplate">
template&lt;class PositionType, template&lt; class, std::size_t, class... &gt; class ArrayType, class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1VerletList.html">Cabana::VerletList</a>&lt; MemorySpace, AlgorithmTag, LayoutTag, BuildTag, NumSpaceDim &gt;::build </td>
          <td>(</td>
          <td class="paramtype">PositionType</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>neighborhood_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename PositionType::value_type</td>          <td class="paramname"><span class="paramname"><em>cell_size_ratio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayType&lt; typename PositionType::value_type, <a class="el" href="#af4a6b14c7a92275109f85097215817b7">num_space_dim</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>grid_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_neigh</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classCabana_1_1VerletList.html" title="Neighbor list implementation based on binning particles on a Cartesian grid with cells of the same si...">VerletList</a> constructor. Given a list of particle positions and a neighborhood radius calculate the neighbor list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The particle positions </td></tr>
    <tr><td class="paramname">neighborhood_radius</td><td>The radius of the neighborhood. Particles within this radius are considered neighbors. This is effectively the grid cell size in each dimension. </td></tr>
    <tr><td class="paramname">cell_size_ratio</td><td>The ratio of the cell size in the Cartesian grid to the neighborhood radius. For example, if the cell size ratio is 0.5 then the cells will be half the size of the neighborhood radius in each dimension. </td></tr>
    <tr><td class="paramname">grid_min</td><td>The minimum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">grid_max</td><td>The maximum value of the grid containing the particles in each dimension. </td></tr>
    <tr><td class="paramname">max_neigh</td><td>Optional maximum number of neighbors per particle to pre-allocate the neighbor list. Potentially avoids recounting with 2D layout only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/src/<a class="el" href="Cabana__VerletList_8hpp_source.html">Cabana_VerletList.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceCabana.html">Cabana</a></li><li class="navelem"><a href="classCabana_1_1VerletList.html">VerletList</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
