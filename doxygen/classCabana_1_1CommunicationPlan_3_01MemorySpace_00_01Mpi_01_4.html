<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cabana: Cabana::CommunicationPlan&lt; MemorySpace, Mpi &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cabana<span id="projectnumber">&#160;0.8.0-dev</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classCabana_1_1CommunicationPlan_3_01MemorySpace_00_01Mpi_01_4.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classCabana_1_1CommunicationPlan_3_01MemorySpace_00_01Mpi_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Cabana::CommunicationPlan&lt; MemorySpace, Mpi &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Communication plan class. Uses vanilla MPI as the communication backend.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Cabana__CommunicationPlan__Mpi_8hpp_source.html">Cabana_CommunicationPlan_Mpi.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Cabana::CommunicationPlan&lt; MemorySpace, Mpi &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classCabana_1_1CommunicationPlan_3_01MemorySpace_00_01Mpi_01_4__inherit__graph.png" border="0" usemap="#aCabana_1_1CommunicationPlan_3_01MemorySpace_00_01Mpi_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aCabana_1_1CommunicationPlan_3_01MemorySpace_00_01Mpi_01_4_inherit__map" id="aCabana_1_1CommunicationPlan_3_01MemorySpace_00_01Mpi_01_4_inherit__map">
<area shape="rect" title="Communication plan class. Uses vanilla MPI as the communication backend." alt="" coords="250,43,446,91"/>
<area shape="rect" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely&#45;owned decomposition to another uniquely own..." alt="" coords="494,5,739,54"/>
<area shape="poly" title=" " alt="" coords="461,49,493,44,494,49,462,54"/>
<area shape="rect" href="classCabana_1_1Halo.html" title="A communication plan for scattering and gathering of ghosted data." alt="" coords="512,79,721,127"/>
<area shape="poly" title=" " alt="" coords="462,80,512,86,511,92,461,85"/>
<area shape="rect" href="classCabana_1_1CommunicationPlanBase.html" title="Communication plan base class." alt="" coords="5,43,202,91"/>
<area shape="poly" title=" " alt="" coords="217,64,249,64,249,70,217,70"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Cabana::CommunicationPlan&lt; MemorySpace, Mpi &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classCabana_1_1CommunicationPlan_3_01MemorySpace_00_01Mpi_01_4__coll__graph.png" border="0" usemap="#aCabana_1_1CommunicationPlan_3_01MemorySpace_00_01Mpi_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aCabana_1_1CommunicationPlan_3_01MemorySpace_00_01Mpi_01_4_coll__map" id="aCabana_1_1CommunicationPlan_3_01MemorySpace_00_01Mpi_01_4_coll__map">
<area shape="rect" title="Communication plan class. Uses vanilla MPI as the communication backend." alt="" coords="5,102,202,151"/>
<area shape="rect" href="classCabana_1_1CommunicationPlanBase.html" title="Communication plan base class." alt="" coords="5,5,202,54"/>
<area shape="poly" title=" " alt="" coords="106,69,106,101,101,101,101,69"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a12c9a18433ab41af808ba793d285c46a" id="r_a12c9a18433ab41af808ba793d285c46a"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class RankViewType&gt; </td></tr>
<tr class="memitem:a12c9a18433ab41af808ba793d285c46a"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlanBase.html#a9c22c59cd9089040be500e6f62b3d09a">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlanBase.html#ade52a84c762977169dd1867f4c617348">memory_space</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a12c9a18433ab41af808ba793d285c46a">createWithTopology</a> (ExecutionSpace exec_space, <a class="el" href="structCabana_1_1Export.html">Export</a>, const RankViewType &amp;element_export_ranks, const std::vector&lt; int &gt; &amp;neighbor_ranks)</td></tr>
<tr class="memdesc:a12c9a18433ab41af808ba793d285c46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor and export rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors.  <br /></td></tr>
<tr class="separator:a12c9a18433ab41af808ba793d285c46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d0b4d20d8ae73ea350961f61b46c34" id="r_aa4d0b4d20d8ae73ea350961f61b46c34"><td class="memTemplParams" colspan="2">template&lt;class RankViewType&gt; </td></tr>
<tr class="memitem:aa4d0b4d20d8ae73ea350961f61b46c34"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlanBase.html#a9c22c59cd9089040be500e6f62b3d09a">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlanBase.html#ade52a84c762977169dd1867f4c617348">memory_space</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa4d0b4d20d8ae73ea350961f61b46c34">createWithTopology</a> (<a class="el" href="structCabana_1_1Export.html">Export</a>, const RankViewType &amp;element_export_ranks, const std::vector&lt; int &gt; &amp;neighbor_ranks)</td></tr>
<tr class="memdesc:aa4d0b4d20d8ae73ea350961f61b46c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor and export rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors.  <br /></td></tr>
<tr class="separator:aa4d0b4d20d8ae73ea350961f61b46c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1ce92effd4a8ec401ae188276998e0" id="r_a3a1ce92effd4a8ec401ae188276998e0"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class RankViewType&gt; </td></tr>
<tr class="memitem:a3a1ce92effd4a8ec401ae188276998e0"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlanBase.html#a9c22c59cd9089040be500e6f62b3d09a">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlanBase.html#ade52a84c762977169dd1867f4c617348">memory_space</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3a1ce92effd4a8ec401ae188276998e0">createWithoutTopology</a> (ExecutionSpace exec_space, <a class="el" href="structCabana_1_1Export.html">Export</a>, const RankViewType &amp;element_export_ranks)</td></tr>
<tr class="memdesc:a3a1ce92effd4a8ec401ae188276998e0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Export.html" title="Export-based tag - default.">Export</a> rank creator. Use this when you don't know who you will receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first.  <br /></td></tr>
<tr class="separator:a3a1ce92effd4a8ec401ae188276998e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a08be158caa7d1c3e041edf3b54172" id="r_a96a08be158caa7d1c3e041edf3b54172"><td class="memTemplParams" colspan="2">template&lt;class RankViewType&gt; </td></tr>
<tr class="memitem:a96a08be158caa7d1c3e041edf3b54172"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlanBase.html#a9c22c59cd9089040be500e6f62b3d09a">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlanBase.html#ade52a84c762977169dd1867f4c617348">memory_space</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a96a08be158caa7d1c3e041edf3b54172">createWithoutTopology</a> (<a class="el" href="structCabana_1_1Export.html">Export</a>, const RankViewType &amp;element_export_ranks)</td></tr>
<tr class="memdesc:a96a08be158caa7d1c3e041edf3b54172"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Export.html" title="Export-based tag - default.">Export</a> rank creator. Use this when you don't know who you will receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first.  <br /></td></tr>
<tr class="separator:a96a08be158caa7d1c3e041edf3b54172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d95e3d877c213dbe0967c2cdcf5c8d6" id="r_a3d95e3d877c213dbe0967c2cdcf5c8d6"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class RankViewType, class IdViewType&gt; </td></tr>
<tr class="memitem:a3d95e3d877c213dbe0967c2cdcf5c8d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d95e3d877c213dbe0967c2cdcf5c8d6">createWithTopology</a> (ExecutionSpace exec_space, <a class="el" href="structCabana_1_1Import.html">Import</a>, const RankViewType &amp;element_import_ranks, const IdViewType &amp;element_import_ids, const std::vector&lt; int &gt; &amp;neighbor_ranks) -&gt; std::tuple&lt; Kokkos::View&lt; typename RankViewType::size_type *, typename RankViewType::memory_space &gt;, Kokkos::View&lt; int *, typename RankViewType::memory_space &gt;, Kokkos::View&lt; int *, typename IdViewType::memory_space &gt; &gt;</td></tr>
<tr class="memdesc:a3d95e3d877c213dbe0967c2cdcf5c8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor and import rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors.  <br /></td></tr>
<tr class="separator:a3d95e3d877c213dbe0967c2cdcf5c8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138ff6e81ddfdd98c0c7e20e3536c65b" id="r_a138ff6e81ddfdd98c0c7e20e3536c65b"><td class="memTemplParams" colspan="2">template&lt;class RankViewType, class IdViewType&gt; </td></tr>
<tr class="memitem:a138ff6e81ddfdd98c0c7e20e3536c65b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a138ff6e81ddfdd98c0c7e20e3536c65b">createWithTopology</a> (<a class="el" href="structCabana_1_1Import.html">Import</a>, const RankViewType &amp;element_import_ranks, const IdViewType &amp;element_import_ids, const std::vector&lt; int &gt; &amp;neighbor_ranks)</td></tr>
<tr class="memdesc:a138ff6e81ddfdd98c0c7e20e3536c65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor and import rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors.  <br /></td></tr>
<tr class="separator:a138ff6e81ddfdd98c0c7e20e3536c65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ced9199a784d28235f9798e5e05d74" id="r_ae1ced9199a784d28235f9798e5e05d74"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class RankViewType, class IdViewType&gt; </td></tr>
<tr class="memitem:ae1ced9199a784d28235f9798e5e05d74"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae1ced9199a784d28235f9798e5e05d74">createWithoutTopology</a> (ExecutionSpace exec_space, <a class="el" href="structCabana_1_1Import.html">Import</a>, const RankViewType &amp;element_import_ranks, const IdViewType &amp;element_import_ids) -&gt; std::tuple&lt; Kokkos::View&lt; typename RankViewType::size_type *, typename RankViewType::memory_space &gt;, Kokkos::View&lt; int *, typename RankViewType::memory_space &gt;, Kokkos::View&lt; int *, typename IdViewType::memory_space &gt; &gt;</td></tr>
<tr class="memdesc:ae1ced9199a784d28235f9798e5e05d74"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Import.html" title="Import-based tag.">Import</a> rank creator. Use this when you don't know who you will be receiving from - only who you are importing from. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first.  <br /></td></tr>
<tr class="separator:ae1ced9199a784d28235f9798e5e05d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7818bd4ef0f33b9f0542dcd6cb1545" id="r_aee7818bd4ef0f33b9f0542dcd6cb1545"><td class="memTemplParams" colspan="2">template&lt;class RankViewType, class IdViewType&gt; </td></tr>
<tr class="memitem:aee7818bd4ef0f33b9f0542dcd6cb1545"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aee7818bd4ef0f33b9f0542dcd6cb1545">createWithoutTopology</a> (<a class="el" href="structCabana_1_1Import.html">Import</a>, const RankViewType &amp;element_import_ranks, const IdViewType &amp;element_import_ids)</td></tr>
<tr class="memdesc:aee7818bd4ef0f33b9f0542dcd6cb1545"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Import.html" title="Import-based tag.">Import</a> rank creator. Use this when you don't know who you will be receiving from - only who you are importing from. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first.  <br /></td></tr>
<tr class="separator:aee7818bd4ef0f33b9f0542dcd6cb1545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classCabana_1_1CommunicationPlanBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classCabana_1_1CommunicationPlanBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classCabana_1_1CommunicationPlanBase.html">Cabana::CommunicationPlanBase&lt; MemorySpace &gt;</a></td></tr>
<tr class="memitem:aea909e312c4cf4da52ac21a0dab15228 inherit pub_methods_classCabana_1_1CommunicationPlanBase" id="r_aea909e312c4cf4da52ac21a0dab15228"><td class="memItemLeft" align="right" valign="top">
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><b>comm</b> () const</td></tr>
<tr class="memdesc:aea909e312c4cf4da52ac21a0dab15228 inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MPI communicator. <br /></td></tr>
<tr class="separator:aea909e312c4cf4da52ac21a0dab15228 inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e35361587f6f78fe7066030c76824c4 inherit pub_methods_classCabana_1_1CommunicationPlanBase" id="r_a9e35361587f6f78fe7066030c76824c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlanBase.html#a9e35361587f6f78fe7066030c76824c4">numNeighbor</a> () const</td></tr>
<tr class="memdesc:a9e35361587f6f78fe7066030c76824c4 inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of neighbor ranks that this rank will communicate with.  <br /></td></tr>
<tr class="separator:a9e35361587f6f78fe7066030c76824c4 inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9317f80a6b3afc7ba4f1757fdf20cb inherit pub_methods_classCabana_1_1CommunicationPlanBase" id="r_a4f9317f80a6b3afc7ba4f1757fdf20cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlanBase.html#a4f9317f80a6b3afc7ba4f1757fdf20cb">neighborRank</a> (const int neighbor) const</td></tr>
<tr class="memdesc:a4f9317f80a6b3afc7ba4f1757fdf20cb inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a local neighbor id get its rank in the MPI communicator.  <br /></td></tr>
<tr class="separator:a4f9317f80a6b3afc7ba4f1757fdf20cb inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f742a9c68e3673625da6f8966fd38f inherit pub_methods_classCabana_1_1CommunicationPlanBase" id="r_ad0f742a9c68e3673625da6f8966fd38f"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlanBase.html#ad0f742a9c68e3673625da6f8966fd38f">numExport</a> (const int neighbor) const</td></tr>
<tr class="memdesc:ad0f742a9c68e3673625da6f8966fd38f inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements this rank will export to a given neighbor.  <br /></td></tr>
<tr class="separator:ad0f742a9c68e3673625da6f8966fd38f inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5485461fcead85a2c89c0698129bde32 inherit pub_methods_classCabana_1_1CommunicationPlanBase" id="r_a5485461fcead85a2c89c0698129bde32"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlanBase.html#a5485461fcead85a2c89c0698129bde32">totalNumExport</a> () const</td></tr>
<tr class="memdesc:a5485461fcead85a2c89c0698129bde32 inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of exports this rank will do.  <br /></td></tr>
<tr class="separator:a5485461fcead85a2c89c0698129bde32 inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521cce72bacd30bf13dddbac2fa307e0 inherit pub_methods_classCabana_1_1CommunicationPlanBase" id="r_a521cce72bacd30bf13dddbac2fa307e0"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlanBase.html#a521cce72bacd30bf13dddbac2fa307e0">numImport</a> (const int neighbor) const</td></tr>
<tr class="memdesc:a521cce72bacd30bf13dddbac2fa307e0 inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements this rank will import from a given neighbor.  <br /></td></tr>
<tr class="separator:a521cce72bacd30bf13dddbac2fa307e0 inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6624ba829579fb308f37854956050182 inherit pub_methods_classCabana_1_1CommunicationPlanBase" id="r_a6624ba829579fb308f37854956050182"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlanBase.html#a6624ba829579fb308f37854956050182">totalNumImport</a> () const</td></tr>
<tr class="memdesc:a6624ba829579fb308f37854956050182 inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of imports this rank will do.  <br /></td></tr>
<tr class="separator:a6624ba829579fb308f37854956050182 inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0948a98484500e0b72f1e304579fbd37 inherit pub_methods_classCabana_1_1CommunicationPlanBase" id="r_a0948a98484500e0b72f1e304579fbd37"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlanBase.html#a0948a98484500e0b72f1e304579fbd37">exportSize</a> () const</td></tr>
<tr class="memdesc:a0948a98484500e0b72f1e304579fbd37 inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of export elements.  <br /></td></tr>
<tr class="separator:a0948a98484500e0b72f1e304579fbd37 inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9963bdfea2f1cf34018b60defe01f4a inherit pub_methods_classCabana_1_1CommunicationPlanBase" id="r_ad9963bdfea2f1cf34018b60defe01f4a"><td class="memItemLeft" align="right" valign="top">Kokkos::View&lt; std::size_t *, <a class="el" href="classCabana_1_1CommunicationPlanBase.html#ade52a84c762977169dd1867f4c617348">memory_space</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlanBase.html#ad9963bdfea2f1cf34018b60defe01f4a">getExportSteering</a> () const</td></tr>
<tr class="memdesc:ad9963bdfea2f1cf34018b60defe01f4a inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the steering vector for the exports.  <br /></td></tr>
<tr class="separator:ad9963bdfea2f1cf34018b60defe01f4a inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89654426c8566c2fc830c25fbf28fa59 inherit pub_methods_classCabana_1_1CommunicationPlanBase" id="r_a89654426c8566c2fc830c25fbf28fa59"><td class="memTemplParams" colspan="2">template&lt;class PackViewType, class RankViewType&gt; </td></tr>
<tr class="memitem:a89654426c8566c2fc830c25fbf28fa59 inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlanBase.html#a89654426c8566c2fc830c25fbf28fa59">createExportSteering</a> (const PackViewType &amp;neighbor_ids, const RankViewType &amp;element_export_ranks)</td></tr>
<tr class="memdesc:a89654426c8566c2fc830c25fbf28fa59 inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the export steering vector.  <br /></td></tr>
<tr class="separator:a89654426c8566c2fc830c25fbf28fa59 inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c00e198f37e2af1b4c8df5c0bd3138f inherit pub_methods_classCabana_1_1CommunicationPlanBase" id="r_a7c00e198f37e2af1b4c8df5c0bd3138f"><td class="memTemplParams" colspan="2">template&lt;class PackViewType, class RankViewType, class IdViewType&gt; </td></tr>
<tr class="memitem:a7c00e198f37e2af1b4c8df5c0bd3138f inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlanBase.html#a7c00e198f37e2af1b4c8df5c0bd3138f">createExportSteering</a> (const PackViewType &amp;neighbor_ids, const RankViewType &amp;element_export_ranks, const IdViewType &amp;element_export_ids)</td></tr>
<tr class="memdesc:a7c00e198f37e2af1b4c8df5c0bd3138f inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the export steering vector.  <br /></td></tr>
<tr class="separator:a7c00e198f37e2af1b4c8df5c0bd3138f inherit pub_methods_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8d7ea5e3b1d98fcf01bb44e9ab9a552e" id="r_a8d7ea5e3b1d98fcf01bb44e9ab9a552e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d7ea5e3b1d98fcf01bb44e9ab9a552e">CommunicationPlan</a> (MPI_Comm <a class="el" href="classCabana_1_1CommunicationPlanBase.html#aea909e312c4cf4da52ac21a0dab15228">comm</a>)</td></tr>
<tr class="memdesc:a8d7ea5e3b1d98fcf01bb44e9ab9a552e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a8d7ea5e3b1d98fcf01bb44e9ab9a552e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classCabana_1_1CommunicationPlanBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classCabana_1_1CommunicationPlanBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classCabana_1_1CommunicationPlanBase.html">Cabana::CommunicationPlanBase&lt; MemorySpace &gt;</a></td></tr>
<tr class="memitem:a41e15e96daa97a90915c8f29145ca0c4 inherit pro_methods_classCabana_1_1CommunicationPlanBase" id="r_a41e15e96daa97a90915c8f29145ca0c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlanBase.html#a41e15e96daa97a90915c8f29145ca0c4">CommunicationPlanBase</a> (MPI_Comm <a class="el" href="classCabana_1_1CommunicationPlanBase.html#aea909e312c4cf4da52ac21a0dab15228">comm</a>)</td></tr>
<tr class="memdesc:a41e15e96daa97a90915c8f29145ca0c4 inherit pro_methods_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a41e15e96daa97a90915c8f29145ca0c4 inherit pro_methods_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classCabana_1_1CommunicationPlanBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classCabana_1_1CommunicationPlanBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classCabana_1_1CommunicationPlanBase.html">Cabana::CommunicationPlanBase&lt; MemorySpace &gt;</a></td></tr>
<tr class="memitem:ade52a84c762977169dd1867f4c617348 inherit pub_types_classCabana_1_1CommunicationPlanBase" id="r_ade52a84c762977169dd1867f4c617348"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>memory_space</b> = MemorySpace</td></tr>
<tr class="memdesc:ade52a84c762977169dd1867f4c617348 inherit pub_types_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kokkos memory space. <br /></td></tr>
<tr class="separator:ade52a84c762977169dd1867f4c617348 inherit pub_types_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add94f41de27ee9adae8f5c42c6ca8a68 inherit pub_types_classCabana_1_1CommunicationPlanBase" id="r_add94f41de27ee9adae8f5c42c6ca8a68"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>execution_space</b> = typename memory_space::execution_space</td></tr>
<tr class="memdesc:add94f41de27ee9adae8f5c42c6ca8a68 inherit pub_types_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default execution space. <br /></td></tr>
<tr class="separator:add94f41de27ee9adae8f5c42c6ca8a68 inherit pub_types_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c22c59cd9089040be500e6f62b3d09a inherit pub_types_classCabana_1_1CommunicationPlanBase" id="r_a9c22c59cd9089040be500e6f62b3d09a"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename memory_space::memory_space::size_type</td></tr>
<tr class="memdesc:a9c22c59cd9089040be500e6f62b3d09a inherit pub_types_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type. <br /></td></tr>
<tr class="separator:a9c22c59cd9089040be500e6f62b3d09a inherit pub_types_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classCabana_1_1CommunicationPlanBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_classCabana_1_1CommunicationPlanBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classCabana_1_1CommunicationPlanBase.html">Cabana::CommunicationPlanBase&lt; MemorySpace &gt;</a></td></tr>
<tr class="memitem:a72708578bc4d29acd5a8a8f359f4b9ce inherit pro_attribs_classCabana_1_1CommunicationPlanBase" id="r_a72708578bc4d29acd5a8a8f359f4b9ce"><td class="memItemLeft" align="right" valign="top">
std::shared_ptr&lt; MPI_Comm &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_comm_ptr</b></td></tr>
<tr class="memdesc:a72708578bc4d29acd5a8a8f359f4b9ce inherit pro_attribs_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to <a class="el" href="structCabana_1_1Mpi.html" title="Vanilla MPI backend tag - default.">Mpi</a> communicator. <br /></td></tr>
<tr class="separator:a72708578bc4d29acd5a8a8f359f4b9ce inherit pro_attribs_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca342fad7a374c5d066743fce037c6f1 inherit pro_attribs_classCabana_1_1CommunicationPlanBase" id="r_aca342fad7a374c5d066743fce037c6f1"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_neighbors</b></td></tr>
<tr class="memdesc:aca342fad7a374c5d066743fce037c6f1 inherit pro_attribs_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of <a class="el" href="structCabana_1_1Mpi.html" title="Vanilla MPI backend tag - default.">Mpi</a> neighbors. <br /></td></tr>
<tr class="separator:aca342fad7a374c5d066743fce037c6f1 inherit pro_attribs_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c740213abcd9b401c7dfa0111460f1 inherit pro_attribs_classCabana_1_1CommunicationPlanBase" id="r_a15c740213abcd9b401c7dfa0111460f1"><td class="memItemLeft" align="right" valign="top">
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_total_num_export</b></td></tr>
<tr class="memdesc:a15c740213abcd9b401c7dfa0111460f1 inherit pro_attribs_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements exported. <br /></td></tr>
<tr class="separator:a15c740213abcd9b401c7dfa0111460f1 inherit pro_attribs_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e4ed8138ecfcd2be327365bf7999c7 inherit pro_attribs_classCabana_1_1CommunicationPlanBase" id="r_a88e4ed8138ecfcd2be327365bf7999c7"><td class="memItemLeft" align="right" valign="top">
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_total_num_import</b></td></tr>
<tr class="memdesc:a88e4ed8138ecfcd2be327365bf7999c7 inherit pro_attribs_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements imported. <br /></td></tr>
<tr class="separator:a88e4ed8138ecfcd2be327365bf7999c7 inherit pro_attribs_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc2607e2e32a9d3f7290b8e1b112add inherit pro_attribs_classCabana_1_1CommunicationPlanBase" id="r_a1fc2607e2e32a9d3f7290b8e1b112add"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_num_export</b></td></tr>
<tr class="memdesc:a1fc2607e2e32a9d3f7290b8e1b112add inherit pro_attribs_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements exported to each neighbor. <br /></td></tr>
<tr class="separator:a1fc2607e2e32a9d3f7290b8e1b112add inherit pro_attribs_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad93a68db08d10e0872f51698e33f9d6 inherit pro_attribs_classCabana_1_1CommunicationPlanBase" id="r_aad93a68db08d10e0872f51698e33f9d6"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_num_import</b></td></tr>
<tr class="memdesc:aad93a68db08d10e0872f51698e33f9d6 inherit pro_attribs_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements imported from each neighbor. <br /></td></tr>
<tr class="separator:aad93a68db08d10e0872f51698e33f9d6 inherit pro_attribs_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6c10f8ccfc103eb69e6b7d2b0e3192 inherit pro_attribs_classCabana_1_1CommunicationPlanBase" id="r_aac6c10f8ccfc103eb69e6b7d2b0e3192"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlanBase.html#aac6c10f8ccfc103eb69e6b7d2b0e3192">_num_export_element</a></td></tr>
<tr class="separator:aac6c10f8ccfc103eb69e6b7d2b0e3192 inherit pro_attribs_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebf3556128399fc94f87444a38a4930 inherit pro_attribs_classCabana_1_1CommunicationPlanBase" id="r_a3ebf3556128399fc94f87444a38a4930"><td class="memItemLeft" align="right" valign="top">
Kokkos::View&lt; std::size_t *, <a class="el" href="classCabana_1_1CommunicationPlanBase.html#ade52a84c762977169dd1867f4c617348">memory_space</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_export_steering</b></td></tr>
<tr class="memdesc:a3ebf3556128399fc94f87444a38a4930 inherit pro_attribs_classCabana_1_1CommunicationPlanBase"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Export.html" title="Export-based tag - default.">Export</a> steering vector. <br /></td></tr>
<tr class="separator:a3ebf3556128399fc94f87444a38a4930 inherit pro_attribs_classCabana_1_1CommunicationPlanBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class MemorySpace&gt;<br />
class Cabana::CommunicationPlan&lt; MemorySpace, Mpi &gt;</div><p>Communication plan class. Uses vanilla MPI as the communication backend. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8d7ea5e3b1d98fcf01bb44e9ab9a552e" name="a8d7ea5e3b1d98fcf01bb44e9ab9a552e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7ea5e3b1d98fcf01bb44e9ab9a552e">&#9670;&#160;</a></span>CommunicationPlan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; MemorySpace, <a class="el" href="structCabana_1_1Mpi.html">Mpi</a> &gt;::CommunicationPlan </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The MPI communicator over which the <a class="el" href="classCabana_1_1CommunicationPlan.html">CommunicationPlan</a> is defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3a1ce92effd4a8ec401ae188276998e0" name="a3a1ce92effd4a8ec401ae188276998e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1ce92effd4a8ec401ae188276998e0">&#9670;&#160;</a></span>createWithoutTopology() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace&gt; </div>
<div class="memtemplate">
template&lt;class ExecutionSpace, class RankViewType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlanBase.html#a9c22c59cd9089040be500e6f62b3d09a">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlanBase.html#ade52a84c762977169dd1867f4c617348">memory_space</a> &gt; <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; MemorySpace, <a class="el" href="structCabana_1_1Mpi.html">Mpi</a> &gt;::createWithoutTopology </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace</td>          <td class="paramname"><span class="paramname"><em>exec_space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCabana_1_1Export.html">Export</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_export_ranks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structCabana_1_1Export.html" title="Export-based tag - default.">Export</a> rank creator. Use this when you don't know who you will receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space.</td></tr>
    <tr><td class="paramname">element_export_ranks</td><td>The destination rank in the target decomposition of each locally owned element in the source decomposition. Each element will have one unique destination to which it will be exported. This export rank may any one of the listed neighbor ranks which can include the calling rank. An export rank of -1 will signal that this element is <em>not</em> to be exported and will be ignored in the data migration. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The location of each export element in the send buffer for its given neighbor.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function completely updates the state of this object and invalidates the previous state.</dd>
<dd>
For elements that you do not wish to export, use an export rank of -1 to signal that this element is <em>not</em> to be exported and will be ignored in the data migration. In other words, this element will be completely* removed in the new decomposition. If the data is staying on this rank, just use this rank as the export destination and the data will be efficiently migrated. </dd></dl>

</div>
</div>
<a id="ae1ced9199a784d28235f9798e5e05d74" name="ae1ced9199a784d28235f9798e5e05d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ced9199a784d28235f9798e5e05d74">&#9670;&#160;</a></span>createWithoutTopology() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace&gt; </div>
<div class="memtemplate">
template&lt;class ExecutionSpace, class RankViewType, class IdViewType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; MemorySpace, <a class="el" href="structCabana_1_1Mpi.html">Mpi</a> &gt;::createWithoutTopology </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace</td>          <td class="paramname"><span class="paramname"><em>exec_space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCabana_1_1Import.html">Import</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_import_ranks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IdViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_import_ids</em></span>&#160;) -&gt; std::tuple&lt;Kokkos::View&lt;typename RankViewType::size_type*,
                                   typename RankViewType::memory_space&gt;,
                      Kokkos::View&lt;int*, typename RankViewType::memory_space&gt;,
                      Kokkos::View&lt;int*, typename IdViewType::memory_space&gt;&gt;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structCabana_1_1Import.html" title="Import-based tag.">Import</a> rank creator. Use this when you don't know who you will be receiving from - only who you are importing from. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space.</td></tr>
    <tr><td class="paramname">element_import_ranks</td><td>The source rank in the target decomposition of each remotely owned element in element_import_ids. This import rank may be any one of the listed neighbor ranks which can include the calling rank. The input is expected to be a Kokkos view in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">element_import_ids</td><td>The local IDs of remotely owned elements that are to be imported. These are local IDs on the remote rank. element_import_ids is mapped such that element_import_ids(i) lives on remote rank element_import_ranks(i).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of Kokkos views, where: Element 1: The location of each export element in the send buffer for its given neighbor. Element 2: The remote ranks this rank will export to Element 3: The local IDs this rank will export Elements 2 and 3 are mapped in the same way as element_import_ranks and element_import_ids</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function completely updates the state of this object and invalidates the previous state.</dd>
<dd>
Unlike creating from exports, an import rank of -1 is not supported. </dd></dl>

</div>
</div>
<a id="a96a08be158caa7d1c3e041edf3b54172" name="a96a08be158caa7d1c3e041edf3b54172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a08be158caa7d1c3e041edf3b54172">&#9670;&#160;</a></span>createWithoutTopology() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace&gt; </div>
<div class="memtemplate">
template&lt;class RankViewType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlanBase.html#a9c22c59cd9089040be500e6f62b3d09a">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlanBase.html#ade52a84c762977169dd1867f4c617348">memory_space</a> &gt; <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; MemorySpace, <a class="el" href="structCabana_1_1Mpi.html">Mpi</a> &gt;::createWithoutTopology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1Export.html">Export</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_export_ranks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structCabana_1_1Export.html" title="Export-based tag - default.">Export</a> rank creator. Use this when you don't know who you will receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_export_ranks</td><td>The destination rank in the target decomposition of each locally owned element in the source decomposition. Each element will have one unique destination to which it will be exported. This export rank may any one of the listed neighbor ranks which can include the calling rank. An export rank of -1 will signal that this element is <em>not</em> to be exported and will be ignored in the data migration. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The location of each export element in the send buffer for its given neighbor.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function completely updates the state of this object and invalidates the previous state.</dd>
<dd>
For elements that you do not wish to export, use an export rank of -1 to signal that this element is <em>not</em> to be exported and will be ignored in the data migration. In other words, this element will be completely* removed in the new decomposition. If the data is staying on this rank, just use this rank as the export destination and the data will be efficiently migrated. </dd></dl>

</div>
</div>
<a id="aee7818bd4ef0f33b9f0542dcd6cb1545" name="aee7818bd4ef0f33b9f0542dcd6cb1545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7818bd4ef0f33b9f0542dcd6cb1545">&#9670;&#160;</a></span>createWithoutTopology() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace&gt; </div>
<div class="memtemplate">
template&lt;class RankViewType, class IdViewType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; MemorySpace, <a class="el" href="structCabana_1_1Mpi.html">Mpi</a> &gt;::createWithoutTopology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1Import.html">Import</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_import_ranks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IdViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_import_ids</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structCabana_1_1Import.html" title="Import-based tag.">Import</a> rank creator. Use this when you don't know who you will be receiving from - only who you are importing from. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_import_ranks</td><td>The source rank in the target decomposition of each remotely owned element in element_import_ids. This import rank may be any one of the listed neighbor ranks which can include the calling rank. The input is expected to be a Kokkos view in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">element_import_ids</td><td>The local IDs of remotely owned elements that are to be imported. These are local IDs on the remote rank. element_import_ids is mapped such that element_import_ids(i) lives on remote rank element_import_ranks(i).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of Kokkos views, where: Element 1: The location of each export element in the send buffer for its given neighbor. Element 2: The remote ranks this rank will export to Element 3: The local IDs this rank will export Elements 2 and 3 are mapped in the same way as element_import_ranks and element_import_ids</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function completely updates the state of this object and invalidates the previous state.</dd>
<dd>
Unlike creating from exports, an import rank of -1 is not supported. </dd></dl>

</div>
</div>
<a id="a12c9a18433ab41af808ba793d285c46a" name="a12c9a18433ab41af808ba793d285c46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c9a18433ab41af808ba793d285c46a">&#9670;&#160;</a></span>createWithTopology() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace&gt; </div>
<div class="memtemplate">
template&lt;class ExecutionSpace, class RankViewType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlanBase.html#a9c22c59cd9089040be500e6f62b3d09a">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlanBase.html#ade52a84c762977169dd1867f4c617348">memory_space</a> &gt; <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; MemorySpace, <a class="el" href="structCabana_1_1Mpi.html">Mpi</a> &gt;::createWithTopology </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace</td>          <td class="paramname"><span class="paramname"><em>exec_space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCabana_1_1Export.html">Export</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_export_ranks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>neighbor_ranks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Neighbor and export rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space.</td></tr>
    <tr><td class="paramname">element_export_ranks</td><td>The destination rank in the target decomposition of each locally owned element in the source decomposition. Each element will have one unique destination to which it will be exported. This export rank may be any one of the listed neighbor ranks which can include the calling rank. An export rank of -1 will signal that this element is <em>not</em> to be exported and will be ignored in the data migration. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">neighbor_ranks</td><td>List of ranks this rank will send to and receive from. This list can include the calling rank. This is effectively a description of the topology of the point-to-point communication plan. Only the unique elements in this list are used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The location of each export element in the send buffer for its given neighbor.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function completely updates the state of this object and invalidates the previous state.</dd>
<dd>
For elements that you do not wish to export, use an export rank of -1 to signal that this element is <em>not</em> to be exported and will be ignored in the data migration. In other words, this element will be completely* removed in the new decomposition. If the data is staying on this rank, just use this rank as the export destination and the data will be efficiently migrated. </dd></dl>

</div>
</div>
<a id="a3d95e3d877c213dbe0967c2cdcf5c8d6" name="a3d95e3d877c213dbe0967c2cdcf5c8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d95e3d877c213dbe0967c2cdcf5c8d6">&#9670;&#160;</a></span>createWithTopology() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace&gt; </div>
<div class="memtemplate">
template&lt;class ExecutionSpace, class RankViewType, class IdViewType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; MemorySpace, <a class="el" href="structCabana_1_1Mpi.html">Mpi</a> &gt;::createWithTopology </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace</td>          <td class="paramname"><span class="paramname"><em>exec_space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCabana_1_1Import.html">Import</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_import_ranks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IdViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_import_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>neighbor_ranks</em></span>&#160;) -&gt; std::tuple&lt;Kokkos::View&lt;typename RankViewType::size_type*,
                                   typename RankViewType::memory_space&gt;,
                      Kokkos::View&lt;int*, typename RankViewType::memory_space&gt;,
                      Kokkos::View&lt;int*, typename IdViewType::memory_space&gt;&gt;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Neighbor and import rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space.</td></tr>
    <tr><td class="paramname">element_import_ranks</td><td>The source rank in the target decomposition of each remotely owned element in element_import_ids. This import rank may be any one of the listed neighbor ranks which can include the calling rank. The input is expected to be a Kokkos view in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">element_import_ids</td><td>The local IDs of remotely owned elements that are to be imported. These are local IDs on the remote rank. element_import_ids is mapped such that element_import_ids(i) lives on remote rank element_import_ranks(i).</td></tr>
    <tr><td class="paramname">neighbor_ranks</td><td>List of ranks this rank will send to and receive from. This list can include the calling rank. This is effectively a description of the topology of the point-to-point communication plan. Only the unique elements in this list are used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of Kokkos views, where: Element 1: The location of each export element in the send buffer for its given neighbor. Element 2: The remote ranks this rank will export to Element 3: The local IDs this rank will export Elements 2 and 3 are mapped in the same way as element_import_ranks and element_import_ids</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function completely updates the state of this object and invalidates the previous state.</dd>
<dd>
Unlike creating from exports, an import rank of -1 is not supported. </dd></dl>

</div>
</div>
<a id="aa4d0b4d20d8ae73ea350961f61b46c34" name="aa4d0b4d20d8ae73ea350961f61b46c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d0b4d20d8ae73ea350961f61b46c34">&#9670;&#160;</a></span>createWithTopology() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace&gt; </div>
<div class="memtemplate">
template&lt;class RankViewType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlanBase.html#a9c22c59cd9089040be500e6f62b3d09a">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlanBase.html#ade52a84c762977169dd1867f4c617348">memory_space</a> &gt; <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; MemorySpace, <a class="el" href="structCabana_1_1Mpi.html">Mpi</a> &gt;::createWithTopology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1Export.html">Export</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_export_ranks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>neighbor_ranks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Neighbor and export rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_export_ranks</td><td>The destination rank in the target decomposition of each locally owned element in the source decomposition. Each element will have one unique destination to which it will be exported. This export rank may be any one of the listed neighbor ranks which can include the calling rank. An export rank of -1 will signal that this element is <em>not</em> to be exported and will be ignored in the data migration. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">neighbor_ranks</td><td>List of ranks this rank will send to and receive from. This list can include the calling rank. This is effectively a description of the topology of the point-to-point communication plan. Only the unique elements in this list are used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The location of each export element in the send buffer for its given neighbor.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function completely updates the state of this object and invalidates the previous state.</dd>
<dd>
For elements that you do not wish to export, use an export rank of -1 to signal that this element is <em>not</em> to be exported and will be ignored in the data migration. In other words, this element will be completely* removed in the new decomposition. If the data is staying on this rank, just use this rank as the export destination and the data will be efficiently migrated. </dd></dl>

</div>
</div>
<a id="a138ff6e81ddfdd98c0c7e20e3536c65b" name="a138ff6e81ddfdd98c0c7e20e3536c65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138ff6e81ddfdd98c0c7e20e3536c65b">&#9670;&#160;</a></span>createWithTopology() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace&gt; </div>
<div class="memtemplate">
template&lt;class RankViewType, class IdViewType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; MemorySpace, <a class="el" href="structCabana_1_1Mpi.html">Mpi</a> &gt;::createWithTopology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1Import.html">Import</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_import_ranks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IdViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_import_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>neighbor_ranks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Neighbor and import rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_import_ranks</td><td>The source rank in the target decomposition of each remotely owned element in element_import_ids. This import rank may be any one of the listed neighbor ranks which can include the calling rank. The input is expected to be a Kokkos view in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">element_import_ids</td><td>The local IDs of remotely owned elements that are to be imported. These are local IDs on the remote rank. element_import_ids is mapped such that element_import_ids(i) lives on remote rank element_import_ranks(i).</td></tr>
    <tr><td class="paramname">neighbor_ranks</td><td>List of ranks this rank will send to and receive from. This list can include the calling rank. This is effectively a description of the topology of the point-to-point communication plan. Only the unique elements in this list are used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of Kokkos views, where: Element 1: The location of each export element in the send buffer for its given neighbor. Element 2: The remote ranks this rank will export to Element 3: The local IDs this rank will export Elements 2 and 3 are mapped in the same way as element_import_ranks and element_import_ids</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function completely updates the state of this object and invalidates the previous state.</dd>
<dd>
Unlike creating from exports, an import rank of -1 is not supported. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/src/impl/<a class="el" href="Cabana__CommunicationPlan__Mpi_8hpp_source.html">Cabana_CommunicationPlan_Mpi.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceCabana.html">Cabana</a></li><li class="navelem"><a class="el" href="classCabana_1_1CommunicationPlan_3_01MemorySpace_00_01Mpi_01_4.html">CommunicationPlan&lt; MemorySpace, Mpi &gt;</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
