<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Cabana: Cabana::CommunicationPlan&lt; DeviceType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cabana
   &#160;<span id="projectnumber">0.3.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Cabana</b></li><li class="navelem"><a class="el" href="classCabana_1_1CommunicationPlan.html">CommunicationPlan</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCabana_1_1CommunicationPlan-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Cabana::CommunicationPlan&lt; DeviceType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Communication plan base class.  
 <a href="classCabana_1_1CommunicationPlan.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Cabana__CommunicationPlan_8hpp_source.html">Cabana_CommunicationPlan.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Cabana::CommunicationPlan&lt; DeviceType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classCabana_1_1CommunicationPlan.png" usemap="#Cabana::CommunicationPlan&lt; DeviceType &gt;_map" alt=""/>
  <map id="Cabana::CommunicationPlan&lt; DeviceType &gt;_map" name="Cabana::CommunicationPlan&lt; DeviceType &gt;_map">
<area href="classCabana_1_1Distributor.html" title="Distributor is a communication plan for migrating data from one uniquely-owned decomposition to anoth..." alt="Cabana::Distributor&lt; DeviceType &gt;" shape="rect" coords="0,56,264,80"/>
<area href="classCabana_1_1Halo.html" title="Halo communication plan for scattering and gathering of ghosted data. " alt="Cabana::Halo&lt; DeviceType &gt;" shape="rect" coords="274,56,538,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a166fe8d6270e0d3224d4298bc4b4bb6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a166fe8d6270e0d3224d4298bc4b4bb6b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>device_type</b> = DeviceType</td></tr>
<tr class="separator:a166fe8d6270e0d3224d4298bc4b4bb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb04f782ff2aa705075d56d758c4f678"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb04f782ff2aa705075d56d758c4f678"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>memory_space</b> = typename device_type::memory_space</td></tr>
<tr class="separator:adb04f782ff2aa705075d56d758c4f678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0dc771fcf7c9015a6f935e9621725a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f0dc771fcf7c9015a6f935e9621725a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>execution_space</b> = typename device_type::execution_space</td></tr>
<tr class="separator:a0f0dc771fcf7c9015a6f935e9621725a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb0f589e39614e6bd75bd834e6cd4ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afeb0f589e39614e6bd75bd834e6cd4ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename memory_space::size_type</td></tr>
<tr class="separator:afeb0f589e39614e6bd75bd834e6cd4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a06e29072acf141f5da2aa73c27443f94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a06e29072acf141f5da2aa73c27443f94">CommunicationPlan</a> (MPI_Comm <a class="el" href="classCabana_1_1CommunicationPlan.html#a604e8cc930192a7df6f1ab7a0f294f75">comm</a>)</td></tr>
<tr class="memdesc:a06e29072acf141f5da2aa73c27443f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a06e29072acf141f5da2aa73c27443f94">More...</a><br/></td></tr>
<tr class="separator:a06e29072acf141f5da2aa73c27443f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604e8cc930192a7df6f1ab7a0f294f75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a604e8cc930192a7df6f1ab7a0f294f75"></a>
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a604e8cc930192a7df6f1ab7a0f294f75">comm</a> () const </td></tr>
<tr class="memdesc:a604e8cc930192a7df6f1ab7a0f294f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MPI communicator. <br/></td></tr>
<tr class="separator:a604e8cc930192a7df6f1ab7a0f294f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9419563c0f8b9f069417ebc55a6956d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#ab9419563c0f8b9f069417ebc55a6956d">numNeighbor</a> () const </td></tr>
<tr class="memdesc:ab9419563c0f8b9f069417ebc55a6956d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of neighbor ranks that this rank will communicate with.  <a href="#ab9419563c0f8b9f069417ebc55a6956d">More...</a><br/></td></tr>
<tr class="separator:ab9419563c0f8b9f069417ebc55a6956d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda7e706ce1d7f0c0b850aad57397fea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#abda7e706ce1d7f0c0b850aad57397fea">neighborRank</a> (const int neighbor) const </td></tr>
<tr class="memdesc:abda7e706ce1d7f0c0b850aad57397fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a local neighbor id get its rank in the MPI communicator.  <a href="#abda7e706ce1d7f0c0b850aad57397fea">More...</a><br/></td></tr>
<tr class="separator:abda7e706ce1d7f0c0b850aad57397fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff326912314c587d0836a76ad10c5b3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a1ff326912314c587d0836a76ad10c5b3">numExport</a> (const int neighbor) const </td></tr>
<tr class="memdesc:a1ff326912314c587d0836a76ad10c5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements this rank will export to a given neighbor.  <a href="#a1ff326912314c587d0836a76ad10c5b3">More...</a><br/></td></tr>
<tr class="separator:a1ff326912314c587d0836a76ad10c5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a10a9c6e37a3f66e6d47ea155b5c50a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a4a10a9c6e37a3f66e6d47ea155b5c50a">totalNumExport</a> () const </td></tr>
<tr class="memdesc:a4a10a9c6e37a3f66e6d47ea155b5c50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of exports this rank will do.  <a href="#a4a10a9c6e37a3f66e6d47ea155b5c50a">More...</a><br/></td></tr>
<tr class="separator:a4a10a9c6e37a3f66e6d47ea155b5c50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb06fd90c18694c52460ef86e8db41b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a0bb06fd90c18694c52460ef86e8db41b">numImport</a> (const int neighbor) const </td></tr>
<tr class="memdesc:a0bb06fd90c18694c52460ef86e8db41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements this rank will import from a given neighbor.  <a href="#a0bb06fd90c18694c52460ef86e8db41b">More...</a><br/></td></tr>
<tr class="separator:a0bb06fd90c18694c52460ef86e8db41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f106268b61895a1ca102ae9e7e3a20"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#ae0f106268b61895a1ca102ae9e7e3a20">totalNumImport</a> () const </td></tr>
<tr class="memdesc:ae0f106268b61895a1ca102ae9e7e3a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of imports this rank will do.  <a href="#ae0f106268b61895a1ca102ae9e7e3a20">More...</a><br/></td></tr>
<tr class="separator:ae0f106268b61895a1ca102ae9e7e3a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d819547750eb75d4bca726abdf9a38"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a99d819547750eb75d4bca726abdf9a38">exportSize</a> () const </td></tr>
<tr class="memdesc:a99d819547750eb75d4bca726abdf9a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of export elements.  <a href="#a99d819547750eb75d4bca726abdf9a38">More...</a><br/></td></tr>
<tr class="separator:a99d819547750eb75d4bca726abdf9a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b93e676802d1d6358a843af9a954a4"><td class="memItemLeft" align="right" valign="top">Kokkos::View&lt; std::size_t <br class="typebreak"/>
*, device_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a14b93e676802d1d6358a843af9a954a4">getExportSteering</a> () const </td></tr>
<tr class="memdesc:a14b93e676802d1d6358a843af9a954a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the steering vector for the exports.  <a href="#a14b93e676802d1d6358a843af9a954a4">More...</a><br/></td></tr>
<tr class="separator:a14b93e676802d1d6358a843af9a954a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b917c46cf274f309969ae4c05ef8120"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a4b917c46cf274f309969ae4c05ef8120"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; size_type <br class="typebreak"/>
*, device_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a4b917c46cf274f309969ae4c05ef8120">createFromExportsAndTopology</a> (const ViewType &amp;element_export_ranks, const std::vector&lt; int &gt; &amp;neighbor_ranks, const int mpi_tag=1221)</td></tr>
<tr class="memdesc:a4b917c46cf274f309969ae4c05ef8120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor and export rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors.  <a href="#a4b917c46cf274f309969ae4c05ef8120">More...</a><br/></td></tr>
<tr class="separator:a4b917c46cf274f309969ae4c05ef8120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370578437d000d1181576fc9e682889b"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a370578437d000d1181576fc9e682889b"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; size_type <br class="typebreak"/>
*, device_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a370578437d000d1181576fc9e682889b">createFromExportsOnly</a> (const ViewType &amp;element_export_ranks, const int mpi_tag=1221)</td></tr>
<tr class="memdesc:a370578437d000d1181576fc9e682889b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export rank creator. Use this when you don't know who you will receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first.  <a href="#a370578437d000d1181576fc9e682889b">More...</a><br/></td></tr>
<tr class="separator:a370578437d000d1181576fc9e682889b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8281c28110645e3a8af293a1984917"><td class="memTemplParams" colspan="2">template&lt;class PackViewType , class RankViewType &gt; </td></tr>
<tr class="memitem:a8a8281c28110645e3a8af293a1984917"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a8a8281c28110645e3a8af293a1984917">createExportSteering</a> (const PackViewType &amp;neighbor_ids, const RankViewType &amp;element_export_ranks)</td></tr>
<tr class="memdesc:a8a8281c28110645e3a8af293a1984917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the export steering vector.  <a href="#a8a8281c28110645e3a8af293a1984917">More...</a><br/></td></tr>
<tr class="separator:a8a8281c28110645e3a8af293a1984917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0809d8f8ef5a6594f00cf7b1ed50fec"><td class="memTemplParams" colspan="2">template&lt;class PackViewType , class RankViewType , class IdViewType &gt; </td></tr>
<tr class="memitem:aa0809d8f8ef5a6594f00cf7b1ed50fec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#aa0809d8f8ef5a6594f00cf7b1ed50fec">createExportSteering</a> (const PackViewType &amp;neighbor_ids, const RankViewType &amp;element_export_ranks, const IdViewType &amp;element_export_ids)</td></tr>
<tr class="memdesc:aa0809d8f8ef5a6594f00cf7b1ed50fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the export steering vector.  <a href="#aa0809d8f8ef5a6594f00cf7b1ed50fec">More...</a><br/></td></tr>
<tr class="separator:aa0809d8f8ef5a6594f00cf7b1ed50fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0568f03db1d1afdd086142a4b01504"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4c0568f03db1d1afdd086142a4b01504"></a>
template&lt;class PackViewType , class RankViewType , class IdViewType &gt; </td></tr>
<tr class="memitem:a4c0568f03db1d1afdd086142a4b01504"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createSteering</b> (const bool use_iota, const PackViewType &amp;neighbor_ids, const RankViewType &amp;element_export_ranks, const IdViewType &amp;element_export_ids)</td></tr>
<tr class="separator:a4c0568f03db1d1afdd086142a4b01504"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class DeviceType&gt;<br/>
class Cabana::CommunicationPlan&lt; DeviceType &gt;</h3>

<p>Communication plan base class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DeviceType</td><td>Device type for which the data for this class will be allocated and where parallel execution will occur.</td></tr>
  </table>
  </dd>
</dl>
<p>The communication plan computes how to redistribute elements in a parallel data structure using MPI. Given a list of data elements on the local MPI rank and their destination ranks, the communication plan computes which rank each process is sending and receiving from and how many elements we will send and receive. In addition, it provides an export steering vector which describes how to pack the local data to be exported into contiguous send buffers for each destination rank (in the forward communication plan).</p>
<p>Some nomenclature:</p>
<p>Export - elements we are sending in the forward communication plan.</p>
<p>Import - elements we are receiving in the forward communication plan.</p>
<dl class="section note"><dt>Note</dt><dd>If a communication plan does self-sends (i.e. exports and imports data from its own ranks) then this data is first in the data structure. What this means is that neighbor 0 is the local rank and the data for that rank that is being exported will appear first in the steering vector. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a06e29072acf141f5da2aa73c27443f94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; DeviceType &gt;::<a class="el" href="classCabana_1_1CommunicationPlan.html">CommunicationPlan</a> </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The MPI communicator over which the distributor is defined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MPI communicator for this plan. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8a8281c28110645e3a8af293a1984917"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType&gt; </div>
<div class="memtemplate">
template&lt;class PackViewType , class RankViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; DeviceType &gt;::createExportSteering </td>
          <td>(</td>
          <td class="paramtype">const PackViewType &amp;&#160;</td>
          <td class="paramname"><em>neighbor_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;&#160;</td>
          <td class="paramname"><em>element_export_ranks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the export steering vector. </p>
<p>Creates an array describing which export element ids are moved to which location in the send buffer of the communcation plan. Ordered such that if a rank sends to itself then those values come first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighbor_ids</td><td>The id of each element in the neighbor send buffers.</td></tr>
    <tr><td class="paramname">element_export_ranks</td><td>The ranks to which we are exporting each element. We use this to build the steering vector. The input is expected to be a Kokkos view or Cabana slice in the same memory space as the communication plan. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0809d8f8ef5a6594f00cf7b1ed50fec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType&gt; </div>
<div class="memtemplate">
template&lt;class PackViewType , class RankViewType , class IdViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; DeviceType &gt;::createExportSteering </td>
          <td>(</td>
          <td class="paramtype">const PackViewType &amp;&#160;</td>
          <td class="paramname"><em>neighbor_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;&#160;</td>
          <td class="paramname"><em>element_export_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IdViewType &amp;&#160;</td>
          <td class="paramname"><em>element_export_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the export steering vector. </p>
<p>Creates an array describing which export element ids are moved to which location in the contiguous send buffer of the communcation plan. Ordered such that if a rank sends to itself then those values come first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighbor_ids</td><td>The id of each element in the neighbor send buffers.</td></tr>
    <tr><td class="paramname">element_export_ranks</td><td>The ranks to which we are exporting each element. We use this to build the steering vector. The input is expected to be a Kokkos view or Cabana slice in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">element_export_ids</td><td>The local ids of the elements to be exported. This corresponds with the export ranks vector and must be the same length if defined. The input is expected to be a Kokkos view or Cabana slice in the same memory space as the communication plan. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b917c46cf274f309969ae4c05ef8120"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType&gt; </div>
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt;size_type*,device_type&gt; <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; DeviceType &gt;::createFromExportsAndTopology </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>element_export_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>mpi_tag</em> = <code>1221</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Neighbor and export rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_export_ranks</td><td>The destination rank in the target decomposition of each locally owned element in the source decomposition. Each element will have one unique destination to which it will be exported. This export rank may be any one of the listed neighbor ranks which can include the calling rank. An export rank of -1 will signal that this element is <em>not</em> to be exported and will be ignored in the data migration. The input is expected to be a Kokkos view or Cabana slice in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">mpi_tag</td><td>The MPI tag to use for non-blocking communication in the communication plan generation.</td></tr>
    <tr><td class="paramname">neighbor_ranks</td><td>List of ranks this rank will send to and receive from. This list can include the calling rank. This is effectively a description of the topology of the point-to-point communication plan. The elements in this list must be unique.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The location of each export element in the send buffer for its given neighbor.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function completely updates the state of this object and invalidates the previous state.</dd>
<dd>
For elements that you do not wish to export, use an export rank of -1 to signal that this element is <em>not</em> to be exported and will be ignored in the data migration. In other words, this element will be completely* removed in the new decomposition. If the data is staying on this rank, just use this rank as the export destination and the data will be efficiently migrated. </dd></dl>

</div>
</div>
<a class="anchor" id="a370578437d000d1181576fc9e682889b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType&gt; </div>
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt;size_type*,device_type&gt; <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; DeviceType &gt;::createFromExportsOnly </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>element_export_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>mpi_tag</em> = <code>1221</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export rank creator. Use this when you don't know who you will receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_export_ranks</td><td>The destination rank in the target decomposition of each locally owned element in the source decomposition. Each element will have one unique destination to which it will be exported. This export rank may any one of the listed neighbor ranks which can include the calling rank. An export rank of -1 will signal that this element is <em>not</em> to be exported and will be ignored in the data migration. The input is expected to be a Kokkos view or Cabana slice in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">mpi_tag</td><td>The MPI tag to use for non-blocking communication in the communication plan generation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The location of each export element in the send buffer for its given neighbor.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function completely updates the state of this object and invalidates the previous state.</dd>
<dd>
For elements that you do not wish to export, use an export rank of -1 to signal that this element is <em>not</em> to be exported and will be ignored in the data migration. In other words, this element will be completely* removed in the new decomposition. If the data is staying on this rank, just use this rank as the export destination and the data will be efficiently migrated. </dd></dl>

</div>
</div>
<a class="anchor" id="a99d819547750eb75d4bca726abdf9a38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; DeviceType &gt;::exportSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of export elements. </p>
<p>Whenever the communciation plan is applied, this is the total number of elements expected to be input on the sending ranks (in the forward communication plan). This will be different than the number returned by <a class="el" href="classCabana_1_1CommunicationPlan.html#a4a10a9c6e37a3f66e6d47ea155b5c50a" title="Get the total number of exports this rank will do. ">totalNumExport()</a> if some of the export ranks used in the construction are -1 and therefore will not particpate in an export operation.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of export elements. </dd></dl>

</div>
</div>
<a class="anchor" id="a14b93e676802d1d6358a843af9a954a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt;std::size_t*,device_type&gt; <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; DeviceType &gt;::getExportSteering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the steering vector for the exports. </p>
<dl class="section return"><dt>Returns</dt><dd>The steering vector for the exports.</dd></dl>
<p>The steering vector places exports in contiguous chunks by destination rank. The chunks are in consecutive order based on the local neighbor id (i.e. all elements going to neighbor with local id 0 first, then all elements going to neighbor with local id 1, etc.). </p>

</div>
</div>
<a class="anchor" id="abda7e706ce1d7f0c0b850aad57397fea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; DeviceType &gt;::neighborRank </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a local neighbor id get its rank in the MPI communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighbor</td><td>The local id of the neighbor to get the rank for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MPI rank of the neighbor with the given local id. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ff326912314c587d0836a76ad10c5b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; DeviceType &gt;::numExport </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of elements this rank will export to a given neighbor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighbor</td><td>The local id of the neighbor to get the number of exports for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements this rank will export to the neighbor with the given local id. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bb06fd90c18694c52460ef86e8db41b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; DeviceType &gt;::numImport </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of elements this rank will import from a given neighbor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighbor</td><td>The local id of the neighbor to get the number of imports for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements this rank will import from the neighbor with the given local id. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9419563c0f8b9f069417ebc55a6956d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; DeviceType &gt;::numNeighbor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of neighbor ranks that this rank will communicate with. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of MPI ranks that will exchange data with this rank. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a10a9c6e37a3f66e6d47ea155b5c50a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; DeviceType &gt;::totalNumExport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of exports this rank will do. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of elements this rank will export to its neighbors. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0f106268b61895a1ca102ae9e7e3a20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan</a>&lt; DeviceType &gt;::totalNumImport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of imports this rank will do. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of elements this rank will import from its neighhbors. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/src/<a class="el" href="Cabana__CommunicationPlan_8hpp_source.html">Cabana_CommunicationPlan.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 13 2019 23:07:23 for Cabana by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
