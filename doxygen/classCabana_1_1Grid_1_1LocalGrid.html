<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cabana: Cabana::Grid::LocalGrid&lt; MeshType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cabana<span id="projectnumber">&#160;0.7.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceCabana.html">Cabana</a></li><li class="navelem"><b>Grid</b></li><li class="navelem"><a class="el" href="classCabana_1_1Grid_1_1LocalGrid.html">LocalGrid</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classCabana_1_1Grid_1_1LocalGrid-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Cabana::Grid::LocalGrid&lt; MeshType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structCabana_1_1Grid_1_1Local.html" title="Local index tag.">Local</a> logical grid.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Cabana__Grid__LocalGrid_8hpp_source.html">Cabana_Grid_LocalGrid.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a03e7e5ebf9bdd691b772433a05eaa32f" id="r_a03e7e5ebf9bdd691b772433a05eaa32f"><td class="memItemLeft" align="right" valign="top"><a id="a03e7e5ebf9bdd691b772433a05eaa32f" name="a03e7e5ebf9bdd691b772433a05eaa32f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mesh_type</b> = MeshType</td></tr>
<tr class="memdesc:a03e7e5ebf9bdd691b772433a05eaa32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh type. <br /></td></tr>
<tr class="separator:a03e7e5ebf9bdd691b772433a05eaa32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6f02580d1bc669ab17593ffe0e41dfcc" id="r_a6f02580d1bc669ab17593ffe0e41dfcc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f02580d1bc669ab17593ffe0e41dfcc">LocalGrid</a> (const std::shared_ptr&lt; <a class="el" href="classCabana_1_1Grid_1_1GlobalGrid.html">GlobalGrid</a>&lt; MeshType &gt; &gt; &amp;global_grid, const int halo_cell_width)</td></tr>
<tr class="memdesc:a6f02580d1bc669ab17593ffe0e41dfcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a6f02580d1bc669ab17593ffe0e41dfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c368c061b1126d6c2ca63cd7c19358" id="r_a73c368c061b1126d6c2ca63cd7c19358"><td class="memItemLeft" align="right" valign="top"><a id="a73c368c061b1126d6c2ca63cd7c19358" name="a73c368c061b1126d6c2ca63cd7c19358"></a>
const <a class="el" href="classCabana_1_1Grid_1_1GlobalGrid.html">GlobalGrid</a>&lt; MeshType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>globalGrid</b> () const</td></tr>
<tr class="memdesc:a73c368c061b1126d6c2ca63cd7c19358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global grid that owns the local grid. <br /></td></tr>
<tr class="separator:a73c368c061b1126d6c2ca63cd7c19358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2474426b1b8d23a53248df9d6ba2c05f" id="r_a2474426b1b8d23a53248df9d6ba2c05f"><td class="memItemLeft" align="right" valign="top"><a id="a2474426b1b8d23a53248df9d6ba2c05f" name="a2474426b1b8d23a53248df9d6ba2c05f"></a>
<a class="el" href="classCabana_1_1Grid_1_1GlobalGrid.html">GlobalGrid</a>&lt; MeshType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>globalGrid</b> ()</td></tr>
<tr class="memdesc:a2474426b1b8d23a53248df9d6ba2c05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mutable version of the global grid that own the local grid. <br /></td></tr>
<tr class="separator:a2474426b1b8d23a53248df9d6ba2c05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53adb91473b83de6202e54cd45802765" id="r_a53adb91473b83de6202e54cd45802765"><td class="memItemLeft" align="right" valign="top"><a id="a53adb91473b83de6202e54cd45802765" name="a53adb91473b83de6202e54cd45802765"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>haloCellWidth</b> () const</td></tr>
<tr class="memdesc:a53adb91473b83de6202e54cd45802765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of cells in the halo. <br /></td></tr>
<tr class="separator:a53adb91473b83de6202e54cd45802765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add088c00b05a498a00c784745a79eaca" id="r_add088c00b05a498a00c784745a79eaca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add088c00b05a498a00c784745a79eaca">totalNumCell</a> (const int d) const</td></tr>
<tr class="memdesc:add088c00b05a498a00c784745a79eaca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of local cells per dimension (owned + halo).  <br /></td></tr>
<tr class="separator:add088c00b05a498a00c784745a79eaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbc5efded05ad7c7d58daeffa4ad3ad" id="r_acfbc5efded05ad7c7d58daeffa4ad3ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfbc5efded05ad7c7d58daeffa4ad3ad">neighborRank</a> (const std::array&lt; int, <a class="el" href="#aa1777869b23f090bf1ee3579c0ece7d5">num_space_dim</a> &gt; &amp;off_ijk) const</td></tr>
<tr class="memdesc:acfbc5efded05ad7c7d58daeffa4ad3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global index of a neighbor given neighbor rank offsets relative to this local grid.  <br /></td></tr>
<tr class="separator:acfbc5efded05ad7c7d58daeffa4ad3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dee0972b24f2a27db72badee05ab41a" id="r_a9dee0972b24f2a27db72badee05ab41a"><td class="memTemplParams" colspan="2">template&lt;std::size_t NSD = num_space_dim&gt; </td></tr>
<tr class="memitem:a9dee0972b24f2a27db72badee05ab41a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; 3==NSD, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9dee0972b24f2a27db72badee05ab41a">neighborRank</a> (const int off_i, const int off_j, const int off_k) const</td></tr>
<tr class="memdesc:a9dee0972b24f2a27db72badee05ab41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global index of a neighbor given neighbor rank offsets relative to this local grid.  <br /></td></tr>
<tr class="separator:a9dee0972b24f2a27db72badee05ab41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130d937580f7bcf4c4f20f9efe9c2358" id="r_a130d937580f7bcf4c4f20f9efe9c2358"><td class="memTemplParams" colspan="2">template&lt;std::size_t NSD = num_space_dim&gt; </td></tr>
<tr class="memitem:a130d937580f7bcf4c4f20f9efe9c2358"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; 2==NSD, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a130d937580f7bcf4c4f20f9efe9c2358">neighborRank</a> (const int off_i, const int off_j) const</td></tr>
<tr class="memdesc:a130d937580f7bcf4c4f20f9efe9c2358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global index of a neighbor given neighbor rank offsets relative to this local grid.  <br /></td></tr>
<tr class="separator:a130d937580f7bcf4c4f20f9efe9c2358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e6d373b57042fa2ee06fa4e96dcd85" id="r_a12e6d373b57042fa2ee06fa4e96dcd85"><td class="memTemplParams" colspan="2">template&lt;class DecompositionTag , class EntityType , class IndexType &gt; </td></tr>
<tr class="memitem:a12e6d373b57042fa2ee06fa4e96dcd85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1Grid_1_1IndexSpace.html">IndexSpace</a>&lt; <a class="el" href="#aa1777869b23f090bf1ee3579c0ece7d5">num_space_dim</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a12e6d373b57042fa2ee06fa4e96dcd85">indexSpace</a> (DecompositionTag t1, EntityType t2, IndexType t3) const</td></tr>
<tr class="memdesc:a12e6d373b57042fa2ee06fa4e96dcd85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a decomposition type, entity type, and index type, get the contiguous set of indices that span the space of those entities in the local domain.  <br /></td></tr>
<tr class="separator:a12e6d373b57042fa2ee06fa4e96dcd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0935dd3eaeb03de8caf39fdf9f729972" id="r_a0935dd3eaeb03de8caf39fdf9f729972"><td class="memTemplParams" colspan="2">template&lt;class DecompositionTag , class EntityType &gt; </td></tr>
<tr class="memitem:a0935dd3eaeb03de8caf39fdf9f729972"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1Grid_1_1IndexSpace.html">IndexSpace</a>&lt; <a class="el" href="#aa1777869b23f090bf1ee3579c0ece7d5">num_space_dim</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0935dd3eaeb03de8caf39fdf9f729972">sharedIndexSpace</a> (DecompositionTag t1, EntityType t2, const std::array&lt; int, <a class="el" href="#aa1777869b23f090bf1ee3579c0ece7d5">num_space_dim</a> &gt; &amp;off_ijk, const int halo_width=-1) const</td></tr>
<tr class="memdesc:a0935dd3eaeb03de8caf39fdf9f729972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the relative offsets of a neighbor rank relative to this local grid's indices get the set of local entity indices shared with that neighbor in the given decomposition.  <br /></td></tr>
<tr class="separator:a0935dd3eaeb03de8caf39fdf9f729972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe85a01a470009af24d34fcb7f338f7" id="r_aafe85a01a470009af24d34fcb7f338f7"><td class="memTemplParams" colspan="2">template&lt;class DecompositionTag , class EntityType , std::size_t NSD = num_space_dim&gt; </td></tr>
<tr class="memitem:aafe85a01a470009af24d34fcb7f338f7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; 3==NSD, <a class="el" href="classCabana_1_1Grid_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aafe85a01a470009af24d34fcb7f338f7">sharedIndexSpace</a> (DecompositionTag t1, EntityType t2, const int off_i, const int off_j, const int off_k, const int halo_width=-1) const</td></tr>
<tr class="memdesc:aafe85a01a470009af24d34fcb7f338f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the relative offsets of a neighbor rank relative to this local grid's indices get the set of local entity indices shared with that neighbor in the given decomposition.  <br /></td></tr>
<tr class="separator:aafe85a01a470009af24d34fcb7f338f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d6a81e39173d1ba99f7554afb093c2" id="r_ae5d6a81e39173d1ba99f7554afb093c2"><td class="memTemplParams" colspan="2">template&lt;class DecompositionTag , class EntityType , std::size_t NSD = num_space_dim&gt; </td></tr>
<tr class="memitem:ae5d6a81e39173d1ba99f7554afb093c2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; 2==NSD, <a class="el" href="classCabana_1_1Grid_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5d6a81e39173d1ba99f7554afb093c2">sharedIndexSpace</a> (DecompositionTag t1, EntityType t2, const int off_i, const int off_j, const int halo_width=-1) const</td></tr>
<tr class="memdesc:ae5d6a81e39173d1ba99f7554afb093c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the relative offsets of a neighbor rank relative to this local grid's indices get the set of local entity indices shared with that neighbor in the given decomposition.  <br /></td></tr>
<tr class="separator:ae5d6a81e39173d1ba99f7554afb093c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef43582c243303512bf19b55a6d96b71" id="r_aef43582c243303512bf19b55a6d96b71"><td class="memTemplParams" colspan="2">template&lt;class DecompositionTag , class EntityType &gt; </td></tr>
<tr class="memitem:aef43582c243303512bf19b55a6d96b71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1Grid_1_1IndexSpace.html">IndexSpace</a>&lt; <a class="el" href="#aa1777869b23f090bf1ee3579c0ece7d5">num_space_dim</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aef43582c243303512bf19b55a6d96b71">boundaryIndexSpace</a> (DecompositionTag t1, EntityType t2, const std::array&lt; int, <a class="el" href="#aa1777869b23f090bf1ee3579c0ece7d5">num_space_dim</a> &gt; &amp;off_ijk, const int halo_width=-1) const</td></tr>
<tr class="memdesc:aef43582c243303512bf19b55a6d96b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the relative offsets of a boundary relative to this local grid's indices get the set of local entity indices associated with that boundary in the given decomposition.  <br /></td></tr>
<tr class="separator:aef43582c243303512bf19b55a6d96b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2310523af7965ca13d5d8685492b1c2b" id="r_a2310523af7965ca13d5d8685492b1c2b"><td class="memTemplParams" colspan="2">template&lt;class DecompositionTag , class EntityType , std::size_t NSD = num_space_dim&gt; </td></tr>
<tr class="memitem:a2310523af7965ca13d5d8685492b1c2b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; 3==NSD, <a class="el" href="classCabana_1_1Grid_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2310523af7965ca13d5d8685492b1c2b">boundaryIndexSpace</a> (DecompositionTag t1, EntityType t2, const int off_i, const int off_j, const int off_k, const int halo_width=-1) const</td></tr>
<tr class="memdesc:a2310523af7965ca13d5d8685492b1c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the relative offsets of a boundary relative to this local grid's indices get the set of local entity indices associated with that boundary in the given decomposition.  <br /></td></tr>
<tr class="separator:a2310523af7965ca13d5d8685492b1c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a41dbd40824374670b0d7550a6d2c1f" id="r_a0a41dbd40824374670b0d7550a6d2c1f"><td class="memTemplParams" colspan="2">template&lt;class DecompositionTag , class EntityType , std::size_t NSD = num_space_dim&gt; </td></tr>
<tr class="memitem:a0a41dbd40824374670b0d7550a6d2c1f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; 2==NSD, <a class="el" href="classCabana_1_1Grid_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a41dbd40824374670b0d7550a6d2c1f">boundaryIndexSpace</a> (DecompositionTag t1, EntityType t2, const int off_i, const int off_j, const int halo_width=-1) const</td></tr>
<tr class="memdesc:a0a41dbd40824374670b0d7550a6d2c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the relative offsets of a boundary relative to this local grid's indices get the set of local entity indices associated with that boundary in the given decomposition.  <br /></td></tr>
<tr class="separator:a0a41dbd40824374670b0d7550a6d2c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa1777869b23f090bf1ee3579c0ece7d5" id="r_aa1777869b23f090bf1ee3579c0ece7d5"><td class="memItemLeft" align="right" valign="top"><a id="aa1777869b23f090bf1ee3579c0ece7d5" name="aa1777869b23f090bf1ee3579c0ece7d5"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_space_dim</b> = mesh_type::num_space_dim</td></tr>
<tr class="memdesc:aa1777869b23f090bf1ee3579c0ece7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial dimension. <br /></td></tr>
<tr class="separator:aa1777869b23f090bf1ee3579c0ece7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class MeshType&gt;<br />
class Cabana::Grid::LocalGrid&lt; MeshType &gt;</div><p><a class="el" href="structCabana_1_1Grid_1_1Local.html" title="Local index tag.">Local</a> logical grid. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>Mesh type: <a class="el" href="structCabana_1_1Grid_1_1UniformMesh.html" title="Uniform mesh tag.">UniformMesh</a>, <a class="el" href="structCabana_1_1Grid_1_1NonUniformMesh.html" title="Non-uniform mesh tag.">NonUniformMesh</a>, or <a class="el" href="structCabana_1_1Grid_1_1SparseMesh.html" title="Sparse mesh tag.">SparseMesh</a> </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6f02580d1bc669ab17593ffe0e41dfcc" name="a6f02580d1bc669ab17593ffe0e41dfcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f02580d1bc669ab17593ffe0e41dfcc">&#9670;&#160;</a></span>LocalGrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Grid_1_1LocalGrid.html">Cabana::Grid::LocalGrid</a>&lt; MeshType &gt;::LocalGrid </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCabana_1_1Grid_1_1GlobalGrid.html">GlobalGrid</a>&lt; MeshType &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>global_grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>halo_cell_width</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_grid</td><td>The global grid from which the local grid will be constructed. </td></tr>
    <tr><td class="paramname">halo_cell_width</td><td>The number of halo cells surrounding the locally owned cells. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0a41dbd40824374670b0d7550a6d2c1f" name="a0a41dbd40824374670b0d7550a6d2c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a41dbd40824374670b0d7550a6d2c1f">&#9670;&#160;</a></span>boundaryIndexSpace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
<div class="memtemplate">
template&lt;class DecompositionTag , class EntityType , std::size_t NSD = num_space_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; 2==NSD, <a class="el" href="classCabana_1_1Grid_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &gt; <a class="el" href="classCabana_1_1Grid_1_1LocalGrid.html">Cabana::Grid::LocalGrid</a>&lt; MeshType &gt;::boundaryIndexSpace </td>
          <td>(</td>
          <td class="paramtype">DecompositionTag</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EntityType</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>off_i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>off_j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>halo_width</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the relative offsets of a boundary relative to this local grid's indices get the set of local entity indices associated with that boundary in the given decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>Decomposition type: <a class="el" href="structCabana_1_1Grid_1_1Own.html" title="Owned decomposition tag.">Own</a> or <a class="el" href="structCabana_1_1Grid_1_1Ghost.html" title="Ghosted decomposition tag.">Ghost</a> </td></tr>
    <tr><td class="paramname">t2</td><td>Entity: <a class="el" href="structCabana_1_1Grid_1_1Cell.html" title="Mesh cell tag.">Cell</a>, <a class="el" href="structCabana_1_1Grid_1_1Node.html" title="Mesh node tag.">Node</a>, <a class="el" href="structCabana_1_1Grid_1_1Edge.html" title="Mesh edge tag.">Edge</a>, or <a class="el" href="structCabana_1_1Grid_1_1Face.html" title="Mesh face tag.">Face</a> </td></tr>
    <tr><td class="paramname">off_i,off_j</td><td>Neighbor offset index in a given dimension. </td></tr>
    <tr><td class="paramname">halo_width</td><td>Optional depth of shared indices within the halo. Must be less than or equal to the halo width of the local grid. Default is to use the halo width of the local grid.</td></tr>
  </table>
  </dd>
</dl>
<p>For example, if the <a class="el" href="structCabana_1_1Grid_1_1Own.html" title="Owned decomposition tag.">Own</a> decomposition is used, the interior entities that would be affected by a boundary operation are provided whereas if the <a class="el" href="structCabana_1_1Grid_1_1Ghost.html" title="Ghosted decomposition tag.">Ghost</a> decomposition is used the halo entities on the boundary are provided. </p>

</div>
</div>
<a id="a2310523af7965ca13d5d8685492b1c2b" name="a2310523af7965ca13d5d8685492b1c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2310523af7965ca13d5d8685492b1c2b">&#9670;&#160;</a></span>boundaryIndexSpace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
<div class="memtemplate">
template&lt;class DecompositionTag , class EntityType , std::size_t NSD = num_space_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; 3==NSD, <a class="el" href="classCabana_1_1Grid_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &gt; <a class="el" href="classCabana_1_1Grid_1_1LocalGrid.html">Cabana::Grid::LocalGrid</a>&lt; MeshType &gt;::boundaryIndexSpace </td>
          <td>(</td>
          <td class="paramtype">DecompositionTag</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EntityType</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>off_i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>off_j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>off_k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>halo_width</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the relative offsets of a boundary relative to this local grid's indices get the set of local entity indices associated with that boundary in the given decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>Decomposition type: <a class="el" href="structCabana_1_1Grid_1_1Own.html" title="Owned decomposition tag.">Own</a> or <a class="el" href="structCabana_1_1Grid_1_1Ghost.html" title="Ghosted decomposition tag.">Ghost</a> </td></tr>
    <tr><td class="paramname">t2</td><td>Entity: <a class="el" href="structCabana_1_1Grid_1_1Cell.html" title="Mesh cell tag.">Cell</a>, <a class="el" href="structCabana_1_1Grid_1_1Node.html" title="Mesh node tag.">Node</a>, <a class="el" href="structCabana_1_1Grid_1_1Edge.html" title="Mesh edge tag.">Edge</a>, or <a class="el" href="structCabana_1_1Grid_1_1Face.html" title="Mesh face tag.">Face</a> </td></tr>
    <tr><td class="paramname">off_i,off_j,off_k</td><td>Neighbor offset index in a given dimension. </td></tr>
    <tr><td class="paramname">halo_width</td><td>Optional depth of shared indices within the halo. Must be less than or equal to the halo width of the local grid. Default is to use the halo width of the local grid.</td></tr>
  </table>
  </dd>
</dl>
<p>For example, if the <a class="el" href="structCabana_1_1Grid_1_1Own.html" title="Owned decomposition tag.">Own</a> decomposition is used, the interior entities that would be affected by a boundary operation are provided whereas if the <a class="el" href="structCabana_1_1Grid_1_1Ghost.html" title="Ghosted decomposition tag.">Ghost</a> decomposition is used the halo entities on the boundary are provided. </p>

</div>
</div>
<a id="aef43582c243303512bf19b55a6d96b71" name="aef43582c243303512bf19b55a6d96b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef43582c243303512bf19b55a6d96b71">&#9670;&#160;</a></span>boundaryIndexSpace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
<div class="memtemplate">
template&lt;class DecompositionTag , class EntityType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Grid_1_1IndexSpace.html">IndexSpace</a>&lt; <a class="el" href="#aa1777869b23f090bf1ee3579c0ece7d5">num_space_dim</a> &gt; <a class="el" href="classCabana_1_1Grid_1_1LocalGrid.html">Cabana::Grid::LocalGrid</a>&lt; MeshType &gt;::boundaryIndexSpace </td>
          <td>(</td>
          <td class="paramtype">DecompositionTag</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EntityType</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, <a class="el" href="#aa1777869b23f090bf1ee3579c0ece7d5">num_space_dim</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>off_ijk</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>halo_width</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the relative offsets of a boundary relative to this local grid's indices get the set of local entity indices associated with that boundary in the given decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>Decomposition type: <a class="el" href="structCabana_1_1Grid_1_1Own.html" title="Owned decomposition tag.">Own</a> or <a class="el" href="structCabana_1_1Grid_1_1Ghost.html" title="Ghosted decomposition tag.">Ghost</a> </td></tr>
    <tr><td class="paramname">t2</td><td>Entity: <a class="el" href="structCabana_1_1Grid_1_1Cell.html" title="Mesh cell tag.">Cell</a>, <a class="el" href="structCabana_1_1Grid_1_1Node.html" title="Mesh node tag.">Node</a>, <a class="el" href="structCabana_1_1Grid_1_1Edge.html" title="Mesh edge tag.">Edge</a>, or <a class="el" href="structCabana_1_1Grid_1_1Face.html" title="Mesh face tag.">Face</a> </td></tr>
    <tr><td class="paramname">off_ijk</td><td>Array of neighbor offset indices. </td></tr>
    <tr><td class="paramname">halo_width</td><td>Optional depth of shared indices within the halo. Must be less than or equal to the halo width of the local grid. Default is to use the halo width of the local grid.</td></tr>
  </table>
  </dd>
</dl>
<p>For example, if the <a class="el" href="structCabana_1_1Grid_1_1Own.html" title="Owned decomposition tag.">Own</a> decomposition is used, the interior entities that would be affected by a boundary operation are provided whereas if the <a class="el" href="structCabana_1_1Grid_1_1Ghost.html" title="Ghosted decomposition tag.">Ghost</a> decomposition is used the halo entities on the boundary are provided. </p>

</div>
</div>
<a id="a12e6d373b57042fa2ee06fa4e96dcd85" name="a12e6d373b57042fa2ee06fa4e96dcd85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e6d373b57042fa2ee06fa4e96dcd85">&#9670;&#160;</a></span>indexSpace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
<div class="memtemplate">
template&lt;class DecompositionTag , class EntityType , class IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Grid_1_1IndexSpace.html">IndexSpace</a>&lt; <a class="el" href="#aa1777869b23f090bf1ee3579c0ece7d5">num_space_dim</a> &gt; <a class="el" href="classCabana_1_1Grid_1_1LocalGrid.html">Cabana::Grid::LocalGrid</a>&lt; MeshType &gt;::indexSpace </td>
          <td>(</td>
          <td class="paramtype">DecompositionTag</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EntityType</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType</td>          <td class="paramname"><span class="paramname"><em>t3</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a decomposition type, entity type, and index type, get the contiguous set of indices that span the space of those entities in the local domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>Decomposition type: <a class="el" href="structCabana_1_1Grid_1_1Own.html" title="Owned decomposition tag.">Own</a> or <a class="el" href="structCabana_1_1Grid_1_1Ghost.html" title="Ghosted decomposition tag.">Ghost</a> </td></tr>
    <tr><td class="paramname">t2</td><td>Entity type: <a class="el" href="structCabana_1_1Grid_1_1Cell.html" title="Mesh cell tag.">Cell</a>, <a class="el" href="structCabana_1_1Grid_1_1Node.html" title="Mesh node tag.">Node</a>, <a class="el" href="structCabana_1_1Grid_1_1Edge.html" title="Mesh edge tag.">Edge</a>, or <a class="el" href="structCabana_1_1Grid_1_1Face.html" title="Mesh face tag.">Face</a> </td></tr>
    <tr><td class="paramname">t3</td><td>Index type: <a class="el" href="structCabana_1_1Grid_1_1Local.html" title="Local index tag.">Local</a> or <a class="el" href="structCabana_1_1Grid_1_1Global.html" title="Global index tag.">Global</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a130d937580f7bcf4c4f20f9efe9c2358" name="a130d937580f7bcf4c4f20f9efe9c2358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130d937580f7bcf4c4f20f9efe9c2358">&#9670;&#160;</a></span>neighborRank() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
<div class="memtemplate">
template&lt;std::size_t NSD&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; 2==NSD, int &gt; <a class="el" href="classCabana_1_1Grid_1_1LocalGrid.html">Cabana::Grid::LocalGrid</a>&lt; MeshType &gt;::neighborRank </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>off_i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>off_j</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the global index of a neighbor given neighbor rank offsets relative to this local grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off_i,off_j</td><td>Neighbor offset index in a given dimension.</td></tr>
  </table>
  </dd>
</dl>
<p>If the neighbor rank is out of bounds return -1. Note that in the case of periodic boundaries out of bounds indices are allowed as the indices will be wrapped around the periodic boundary. </p>

</div>
</div>
<a id="a9dee0972b24f2a27db72badee05ab41a" name="a9dee0972b24f2a27db72badee05ab41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dee0972b24f2a27db72badee05ab41a">&#9670;&#160;</a></span>neighborRank() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
<div class="memtemplate">
template&lt;std::size_t NSD&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; 3==NSD, int &gt; <a class="el" href="classCabana_1_1Grid_1_1LocalGrid.html">Cabana::Grid::LocalGrid</a>&lt; MeshType &gt;::neighborRank </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>off_i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>off_j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>off_k</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the global index of a neighbor given neighbor rank offsets relative to this local grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off_i,off_j,off_k</td><td>Neighbor offset index in a given dimension.</td></tr>
  </table>
  </dd>
</dl>
<p>If the neighbor rank is out of bounds return -1. Note that in the case of periodic boundaries out of bounds indices are allowed as the indices will be wrapped around the periodic boundary. </p>

</div>
</div>
<a id="acfbc5efded05ad7c7d58daeffa4ad3ad" name="acfbc5efded05ad7c7d58daeffa4ad3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbc5efded05ad7c7d58daeffa4ad3ad">&#9670;&#160;</a></span>neighborRank() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCabana_1_1Grid_1_1LocalGrid.html">Cabana::Grid::LocalGrid</a>&lt; MeshType &gt;::neighborRank </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; int, <a class="el" href="#aa1777869b23f090bf1ee3579c0ece7d5">num_space_dim</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>off_ijk</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the global index of a neighbor given neighbor rank offsets relative to this local grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off_ijk</td><td>Array of neighbor offset indices.</td></tr>
  </table>
  </dd>
</dl>
<p>If the neighbor rank is out of bounds return -1. Note that in the case of periodic boundaries out of bounds indices are allowed as the indices will be wrapped around the periodic boundary. </p>

</div>
</div>
<a id="ae5d6a81e39173d1ba99f7554afb093c2" name="ae5d6a81e39173d1ba99f7554afb093c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d6a81e39173d1ba99f7554afb093c2">&#9670;&#160;</a></span>sharedIndexSpace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
<div class="memtemplate">
template&lt;class DecompositionTag , class EntityType , std::size_t NSD = num_space_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; 2==NSD, <a class="el" href="classCabana_1_1Grid_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &gt; <a class="el" href="classCabana_1_1Grid_1_1LocalGrid.html">Cabana::Grid::LocalGrid</a>&lt; MeshType &gt;::sharedIndexSpace </td>
          <td>(</td>
          <td class="paramtype">DecompositionTag</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EntityType</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>off_i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>off_j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>halo_width</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the relative offsets of a neighbor rank relative to this local grid's indices get the set of local entity indices shared with that neighbor in the given decomposition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DecompositionTag</td><td>Decomposition type: <a class="el" href="structCabana_1_1Grid_1_1Own.html" title="Owned decomposition tag.">Own</a> or <a class="el" href="structCabana_1_1Grid_1_1Ghost.html" title="Ghosted decomposition tag.">Ghost</a> </td></tr>
    <tr><td class="paramname">EntityType</td><td>Entity: <a class="el" href="structCabana_1_1Grid_1_1Cell.html" title="Mesh cell tag.">Cell</a>, <a class="el" href="structCabana_1_1Grid_1_1Node.html" title="Mesh node tag.">Node</a>, <a class="el" href="structCabana_1_1Grid_1_1Edge.html" title="Mesh edge tag.">Edge</a>, or <a class="el" href="structCabana_1_1Grid_1_1Face.html" title="Mesh face tag.">Face</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>Decomposition type: <a class="el" href="structCabana_1_1Grid_1_1Own.html" title="Owned decomposition tag.">Own</a> or <a class="el" href="structCabana_1_1Grid_1_1Ghost.html" title="Ghosted decomposition tag.">Ghost</a> </td></tr>
    <tr><td class="paramname">t2</td><td>Entity: <a class="el" href="structCabana_1_1Grid_1_1Cell.html" title="Mesh cell tag.">Cell</a>, <a class="el" href="structCabana_1_1Grid_1_1Node.html" title="Mesh node tag.">Node</a>, <a class="el" href="structCabana_1_1Grid_1_1Edge.html" title="Mesh edge tag.">Edge</a>, or <a class="el" href="structCabana_1_1Grid_1_1Face.html" title="Mesh face tag.">Face</a> </td></tr>
    <tr><td class="paramname">off_i,off_j</td><td>Neighbor offset index in a given dimension. </td></tr>
    <tr><td class="paramname">halo_width</td><td>Optional depth of shared indices within the halo. Must be less than or equal to the halo width of the local grid. Default is to use the halo width of the local grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafe85a01a470009af24d34fcb7f338f7" name="aafe85a01a470009af24d34fcb7f338f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe85a01a470009af24d34fcb7f338f7">&#9670;&#160;</a></span>sharedIndexSpace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
<div class="memtemplate">
template&lt;class DecompositionTag , class EntityType , std::size_t NSD = num_space_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; 3==NSD, <a class="el" href="classCabana_1_1Grid_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &gt; <a class="el" href="classCabana_1_1Grid_1_1LocalGrid.html">Cabana::Grid::LocalGrid</a>&lt; MeshType &gt;::sharedIndexSpace </td>
          <td>(</td>
          <td class="paramtype">DecompositionTag</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EntityType</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>off_i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>off_j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>off_k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>halo_width</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the relative offsets of a neighbor rank relative to this local grid's indices get the set of local entity indices shared with that neighbor in the given decomposition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DecompositionTag</td><td>Decomposition type: <a class="el" href="structCabana_1_1Grid_1_1Own.html" title="Owned decomposition tag.">Own</a> or <a class="el" href="structCabana_1_1Grid_1_1Ghost.html" title="Ghosted decomposition tag.">Ghost</a> </td></tr>
    <tr><td class="paramname">EntityType</td><td>Entity: <a class="el" href="structCabana_1_1Grid_1_1Cell.html" title="Mesh cell tag.">Cell</a>, <a class="el" href="structCabana_1_1Grid_1_1Node.html" title="Mesh node tag.">Node</a>, <a class="el" href="structCabana_1_1Grid_1_1Edge.html" title="Mesh edge tag.">Edge</a>, or <a class="el" href="structCabana_1_1Grid_1_1Face.html" title="Mesh face tag.">Face</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>Decomposition type: <a class="el" href="structCabana_1_1Grid_1_1Own.html" title="Owned decomposition tag.">Own</a> or <a class="el" href="structCabana_1_1Grid_1_1Ghost.html" title="Ghosted decomposition tag.">Ghost</a> </td></tr>
    <tr><td class="paramname">t2</td><td>Entity: <a class="el" href="structCabana_1_1Grid_1_1Cell.html" title="Mesh cell tag.">Cell</a>, <a class="el" href="structCabana_1_1Grid_1_1Node.html" title="Mesh node tag.">Node</a>, <a class="el" href="structCabana_1_1Grid_1_1Edge.html" title="Mesh edge tag.">Edge</a>, or <a class="el" href="structCabana_1_1Grid_1_1Face.html" title="Mesh face tag.">Face</a> </td></tr>
    <tr><td class="paramname">off_i,off_j,off_k</td><td>Neighbor offset index in a given dimension. </td></tr>
    <tr><td class="paramname">halo_width</td><td>Optional depth of shared indices within the halo. Must be less than or equal to the halo width of the local grid. Default is to use the halo width of the local grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0935dd3eaeb03de8caf39fdf9f729972" name="a0935dd3eaeb03de8caf39fdf9f729972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0935dd3eaeb03de8caf39fdf9f729972">&#9670;&#160;</a></span>sharedIndexSpace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
<div class="memtemplate">
template&lt;class DecompositionTag , class EntityType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Grid_1_1IndexSpace.html">IndexSpace</a>&lt; <a class="el" href="#aa1777869b23f090bf1ee3579c0ece7d5">num_space_dim</a> &gt; <a class="el" href="classCabana_1_1Grid_1_1LocalGrid.html">Cabana::Grid::LocalGrid</a>&lt; MeshType &gt;::sharedIndexSpace </td>
          <td>(</td>
          <td class="paramtype">DecompositionTag</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EntityType</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, <a class="el" href="#aa1777869b23f090bf1ee3579c0ece7d5">num_space_dim</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>off_ijk</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>halo_width</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the relative offsets of a neighbor rank relative to this local grid's indices get the set of local entity indices shared with that neighbor in the given decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>Decomposition type: <a class="el" href="structCabana_1_1Grid_1_1Own.html" title="Owned decomposition tag.">Own</a> or <a class="el" href="structCabana_1_1Grid_1_1Ghost.html" title="Ghosted decomposition tag.">Ghost</a> </td></tr>
    <tr><td class="paramname">t2</td><td>Entity: <a class="el" href="structCabana_1_1Grid_1_1Cell.html" title="Mesh cell tag.">Cell</a>, <a class="el" href="structCabana_1_1Grid_1_1Node.html" title="Mesh node tag.">Node</a>, <a class="el" href="structCabana_1_1Grid_1_1Edge.html" title="Mesh edge tag.">Edge</a>, or <a class="el" href="structCabana_1_1Grid_1_1Face.html" title="Mesh face tag.">Face</a> </td></tr>
    <tr><td class="paramname">off_ijk</td><td>Array of neighbor offset indices. </td></tr>
    <tr><td class="paramname">halo_width</td><td>Optional depth of shared indices within the halo. Must be less than or equal to the halo width of the local grid. Default is to use the halo width of the local grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add088c00b05a498a00c784745a79eaca" name="add088c00b05a498a00c784745a79eaca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add088c00b05a498a00c784745a79eaca">&#9670;&#160;</a></span>totalNumCell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCabana_1_1Grid_1_1LocalGrid.html">Cabana::Grid::LocalGrid</a>&lt; MeshType &gt;::totalNumCell </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total number of local cells per dimension (owned + halo). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Spatial dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>grid/src/<a class="el" href="Cabana__Grid__LocalGrid_8hpp_source.html">Cabana_Grid_LocalGrid.hpp</a></li>
<li>grid/src/<a class="el" href="Cabana__Grid__LocalGrid__impl_8hpp_source.html">Cabana_Grid_LocalGrid_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
