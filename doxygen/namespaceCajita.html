<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cabana: Cajita Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cabana<span id="projectnumber">&#160;1.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Cajita Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a>: grid and particle-grid data structures and algorithms.  
<a href="namespaceCajita.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1Array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCajita_1_1Array.html" title="Array of field data on the local mesh.">Array</a> of field data on the local mesh.  <a href="classCajita_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity layout for array data on the local mesh.  <a href="classCajita_1_1ArrayLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1ArrayPackMemorySpace.html">ArrayPackMemorySpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer array memory space.  <a href="structCajita_1_1ArrayPackMemorySpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1BlockMap.html">BlockMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of <a class="el" href="classCajita_1_1BlockMap.html" title="Declaration of BlockMap.">BlockMap</a>.  <a href="classCajita_1_1BlockMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1BlockPartitioner.html">BlockPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block partitioner base class.  <a href="classCajita_1_1BlockPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Cell.html">Cell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh cell tag.  <a href="structCajita_1_1Cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Dim.html">Dim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical dimension index.  <a href="structCajita_1_1Dim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1DimBlockPartitioner.html">DimBlockPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension-only partitioner.  <a href="classCajita_1_1DimBlockPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh edge tag.  <a href="structCajita_1_1Edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Edge_3_01Dim_1_1I_01_4.html">Edge&lt; Dim::I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I-edge tag.  <a href="structCajita_1_1Edge_3_01Dim_1_1I_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Edge_3_01Dim_1_1J_01_4.html">Edge&lt; Dim::J &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">J-edge tag.  <a href="structCajita_1_1Edge_3_01Dim_1_1J_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Edge_3_01Dim_1_1K_01_4.html">Edge&lt; Dim::K &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">K-edge tag.  <a href="structCajita_1_1Edge_3_01Dim_1_1K_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Face.html">Face</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh face tag.  <a href="structCajita_1_1Face.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Face_3_01Dim_1_1I_01_4.html">Face&lt; Dim::I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I-face tag.  <a href="structCajita_1_1Face_3_01Dim_1_1I_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Face_3_01Dim_1_1J_01_4.html">Face&lt; Dim::J &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">J-face tag.  <a href="structCajita_1_1Face_3_01Dim_1_1J_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Face_3_01Dim_1_1K_01_4.html">Face&lt; Dim::K &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">K-face tag.  <a href="structCajita_1_1Face_3_01Dim_1_1K_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1FaceHaloPattern.html">FaceHaloPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1FaceHaloPattern_3_012_01_4.html">FaceHaloPattern&lt; 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1FaceHaloPattern_3_013_01_4.html">FaceHaloPattern&lt; 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1FullHaloPattern.html">FullHaloPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full 3d halo with all 26 adjacent blocks. Backwards compatibility wrapper.  <a href="classCajita_1_1FullHaloPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Ghost.html">Ghost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ghosted decomposition tag.  <a href="structCajita_1_1Ghost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Global.html">Global</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> index tag.  <a href="structCajita_1_1Global.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> logical grid.  <a href="classCajita_1_1GlobalGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> mesh partial specialization for uniform mesh.  <a href="classCajita_1_1GlobalMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1GlobalMesh_3_01NonUniformMesh_3_01Scalar_00_012_01_4_01_4.html">GlobalMesh&lt; NonUniformMesh&lt; Scalar, 2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> mesh partial specialization for 2D non-uniform mesh.  <a href="classCajita_1_1GlobalMesh_3_01NonUniformMesh_3_01Scalar_00_012_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1GlobalMesh_3_01NonUniformMesh_3_01Scalar_00_013_01_4_01_4.html">GlobalMesh&lt; NonUniformMesh&lt; Scalar, 3 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> mesh partial specialization for 3D non-uniform mesh.  <a href="classCajita_1_1GlobalMesh_3_01NonUniformMesh_3_01Scalar_00_013_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1Halo.html">Halo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HaloPattern.html">HaloPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base halo exchange pattern class.  <a href="classCajita_1_1HaloPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1has__spline__tag.html">has_spline_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a given spline tag is present.  <a href="structCajita_1_1has__spline__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1HashKey2TileID.html">HashKey2TileID</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1HashKey2TileID_3_01Key_00_01HashTypes_1_1Morton_01_4.html">HashKey2TileID&lt; Key, HashTypes::Morton &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D tile ijk from the hash key.  <a href="structCajita_1_1HashKey2TileID_3_01Key_00_01HashTypes_1_1Morton_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1HashKey2TileID_3_01Key_00_01HashTypes_1_1Naive_01_4.html">HashKey2TileID&lt; Key, HashTypes::Naive &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D tile ijk from the hash key.  <a href="structCajita_1_1HashKey2TileID_3_01Key_00_01HashTypes_1_1Naive_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1HypreIsCompatibleWithMemorySpace.html">HypreIsCompatibleWithMemorySpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hypre device compatibility check.  <a href="structCajita_1_1HypreIsCompatibleWithMemorySpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1HypreIsCompatibleWithMemorySpace_3_01Kokkos_1_1HostSpace_01_4.html">HypreIsCompatibleWithMemorySpace&lt; Kokkos::HostSpace &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hypre device compatibility check - host memory.  <a href="structCajita_1_1HypreIsCompatibleWithMemorySpace_3_01Kokkos_1_1HostSpace_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreSemiStructBiCGSTAB.html">HypreSemiStructBiCGSTAB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">BiCGSTAB solver.  <a href="classCajita_1_1HypreSemiStructBiCGSTAB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreSemiStructDiagonal.html">HypreSemiStructDiagonal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonal preconditioner.  <a href="classCajita_1_1HypreSemiStructDiagonal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreSemiStructGMRES.html">HypreSemiStructGMRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GMRES solver.  <a href="classCajita_1_1HypreSemiStructGMRES.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreSemiStructPCG.html">HypreSemiStructPCG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PCG solver.  <a href="classCajita_1_1HypreSemiStructPCG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreSemiStructuredSolver.html">HypreSemiStructuredSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hypre semi-structured solver interface for scalar fields.  <a href="classCajita_1_1HypreSemiStructuredSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructBiCGSTAB.html">HypreStructBiCGSTAB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">BiCGSTAB solver.  <a href="classCajita_1_1HypreStructBiCGSTAB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructDiagonal.html">HypreStructDiagonal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonal preconditioner.  <a href="classCajita_1_1HypreStructDiagonal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructGMRES.html">HypreStructGMRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GMRES solver.  <a href="classCajita_1_1HypreStructGMRES.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructJacobi.html">HypreStructJacobi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi solver.  <a href="classCajita_1_1HypreStructJacobi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructPCG.html">HypreStructPCG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PCG solver.  <a href="classCajita_1_1HypreStructPCG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructPFMG.html">HypreStructPFMG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PFMG solver.  <a href="classCajita_1_1HypreStructPFMG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructSMG.html">HypreStructSMG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMG solver.  <a href="classCajita_1_1HypreStructSMG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructuredSolver.html">HypreStructuredSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hypre structured solver interface for scalar fields.  <a href="classCajita_1_1HypreStructuredSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structured index space.  <a href="classCajita_1_1IndexSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1is__array.html">is_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1is__array_3_01Array_3_01Scalar_00_01EntityType_00_01MeshType_00_01Params_8_8_8_01_4_01_4.html">is_array&lt; Array&lt; Scalar, EntityType, MeshType, Params... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1is__array_3_01const_01Array_3_01Scalar_00_01EntityType_00_01MeshType_00_01Params_8_8_8_01_4_01_4.html">is_array&lt; const Array&lt; Scalar, EntityType, MeshType, Params... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1is__array__layout.html">is_array_layout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCajita_1_1Array.html" title="Array of field data on the local mesh.">Array</a> static type checker.  <a href="structCajita_1_1is__array__layout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1is__array__layout_3_01ArrayLayout_3_01EntityType_00_01MeshType_01_4_01_4.html">is_array_layout&lt; ArrayLayout&lt; EntityType, MeshType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCajita_1_1Array.html" title="Array of field data on the local mesh.">Array</a> static type checker.  <a href="structCajita_1_1is__array__layout_3_01ArrayLayout_3_01EntityType_00_01MeshType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1is__array__layout_3_01const_01ArrayLayout_3_01EntityType_00_01MeshType_01_4_01_4.html">is_array_layout&lt; const ArrayLayout&lt; EntityType, MeshType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCajita_1_1Array.html" title="Array of field data on the local mesh.">Array</a> static type checker.  <a href="structCajita_1_1is__array__layout_3_01const_01ArrayLayout_3_01EntityType_00_01MeshType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1is__particle__list.html">is_particle_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCajita_1_1ParticleList.html" title="List of particle fields stored in AoSoA with associated Cajita mesh.">ParticleList</a> static type checker.  <a href="structCajita_1_1is__particle__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1is__particle__list__impl.html">is_particle_list_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1is__particle__list__impl_3_01ParticleList_3_01MemorySpace_00_01FieldTags_8_8_8_01_4_01_4.html">is_particle_list_impl&lt; ParticleList&lt; MemorySpace, FieldTags... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isCell.html">isCell</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isCell_3_01Cell_01_4.html">isCell&lt; Cell &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isCell_3_01const_01Cell_01_4.html">isCell&lt; const Cell &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isEdge.html">isEdge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isEdge_3_01const_01Edge_3_01Dir_01_4_01_4.html">isEdge&lt; const Edge&lt; Dir &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isEdge_3_01Edge_3_01Dir_01_4_01_4.html">isEdge&lt; Edge&lt; Dir &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isFace.html">isFace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isFace_3_01const_01Face_3_01Dir_01_4_01_4.html">isFace&lt; const Face&lt; Dir &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isFace_3_01Face_3_01Dir_01_4_01_4.html">isFace&lt; Face&lt; Dir &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isMeshType.html">isMeshType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isMeshType_3_01const_01NonUniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isMeshType&lt; const NonUniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isMeshType_3_01const_01SparseMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isMeshType&lt; const SparseMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isMeshType_3_01const_01UniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isMeshType&lt; const UniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isMeshType_3_01NonUniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isMeshType&lt; NonUniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isMeshType_3_01SparseMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isMeshType&lt; SparseMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isMeshType_3_01UniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isMeshType&lt; UniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isNode.html">isNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isNode_3_01const_01Node_01_4.html">isNode&lt; const Node &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isNode_3_01Node_01_4.html">isNode&lt; Node &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isNonUniformMesh.html">isNonUniformMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isNonUniformMesh_3_01const_01NonUniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isNonUniformMesh&lt; const NonUniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isNonUniformMesh_3_01NonUniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isNonUniformMesh&lt; NonUniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isSparseMesh.html">isSparseMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isSparseMesh_3_01const_01SparseMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isSparseMesh&lt; const SparseMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isSparseMesh_3_01SparseMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isSparseMesh&lt; SparseMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isUniformMesh.html">isUniformMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isUniformMesh_3_01const_01UniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isUniformMesh&lt; const UniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isUniformMesh_3_01UniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isUniformMesh&lt; UniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1LayoutAdapter.html">LayoutAdapter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Local.html">Local</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Local.html" title="Local index tag.">Local</a> index tag.  <a href="structCajita_1_1Local.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Local.html" title="Local index tag.">Local</a> logical grid.  <a href="classCajita_1_1LocalGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1LocalMesh.html">LocalMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1LocalMesh_3_01MemorySpace_00_01NonUniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">LocalMesh&lt; MemorySpace, NonUniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> mesh partial specialization for non-uniform mesh.  <a href="classCajita_1_1LocalMesh_3_01MemorySpace_00_01NonUniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1LocalMesh_3_01MemorySpace_00_01UniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">LocalMesh&lt; MemorySpace, UniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Local.html" title="Local index tag.">Local</a> mesh partial specialization for uniform mesh.  <a href="classCajita_1_1LocalMesh_3_01MemorySpace_00_01UniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1ManualBlockPartitioner.html">ManualBlockPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manual block partitioner.  <a href="classCajita_1_1ManualBlockPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1ManualPartitioner.html">ManualPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backwards compatibility wrapper for 3D <a class="el" href="classCajita_1_1ManualBlockPartitioner.html" title="Manual block partitioner.">ManualBlockPartitioner</a>.  <a href="classCajita_1_1ManualPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1MpiTraits.html">MpiTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1MpiTraits_3_01char_01_4.html">MpiTraits&lt; char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI type trait.  <a href="structCajita_1_1MpiTraits_3_01char_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1MpiTraits_3_01double_01_4.html">MpiTraits&lt; double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI type trait.  <a href="structCajita_1_1MpiTraits_3_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1MpiTraits_3_01float_01_4.html">MpiTraits&lt; float &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI type trait.  <a href="structCajita_1_1MpiTraits_3_01float_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1MpiTraits_3_01int_01_4.html">MpiTraits&lt; int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI type trait.  <a href="structCajita_1_1MpiTraits_3_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1MpiTraits_3_01long_01_4.html">MpiTraits&lt; long &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI type trait.  <a href="structCajita_1_1MpiTraits_3_01long_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh node tag.  <a href="structCajita_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1NodeHaloPattern.html">NodeHaloPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1NodeHaloPattern_3_012_01_4.html">NodeHaloPattern&lt; 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1NodeHaloPattern_3_013_01_4.html">NodeHaloPattern&lt; 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1NonUniformMesh.html">NonUniformMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-uniform mesh tag.  <a href="structCajita_1_1NonUniformMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Own.html">Own</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owned decomposition tag.  <a href="structCajita_1_1Own.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1ParticleList.html">ParticleList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of particle fields stored in AoSoA with associated <a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> mesh.  <a href="classCajita_1_1ParticleList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1ReferenceConjugateGradient.html">ReferenceConjugateGradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference structured preconditioned block conjugate gradient implementation.  <a href="classCajita_1_1ReferenceConjugateGradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1ReferenceStructuredSolver.html">ReferenceStructuredSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference preconditioned structured solver interface.  <a href="classCajita_1_1ReferenceStructuredSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1ScalarGradientG2P.html">ScalarGradientG2P</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid-to-point scalar gradient functor.  <a href="structCajita_1_1ScalarGradientG2P.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1ScalarGradientP2G.html">ScalarGradientP2G</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point-to-grid scalar gradient functor.  <a href="structCajita_1_1ScalarGradientP2G.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1ScalarValueG2P.html">ScalarValueG2P</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid-to-point scalar value functor.  <a href="structCajita_1_1ScalarValueG2P.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1ScalarValueP2G.html">ScalarValueP2G</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point-to-grid scalar value functor.  <a href="structCajita_1_1ScalarValueP2G.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1SparseDimPartitioner.html">SparseDimPartitioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1SparseMap.html">SparseMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse index space, with a hierarchical structure (cell-&gt;tile-&gt;block)  <a href="classCajita_1_1SparseMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse mesh tag.  <a href="structCajita_1_1SparseMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Spline.html">Spline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">B-Spline interface for uniform grids.  <a href="structCajita_1_1Spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Spline_3_010_01_4.html">Spline&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-order (Nearest Grid Point Interpolation). Defined on the dual grid.  <a href="structCajita_1_1Spline_3_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Spline_3_011_01_4.html">Spline&lt; 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear. Defined on the primal grid.  <a href="structCajita_1_1Spline_3_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Spline_3_012_01_4.html">Spline&lt; 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quadratic. Defined on the dual grid.  <a href="structCajita_1_1Spline_3_012_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Spline_3_013_01_4.html">Spline&lt; 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cubic. Defined on the primal grid.  <a href="structCajita_1_1Spline_3_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineData.html">SplineData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data container.  <a href="structCajita_1_1SplineData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineData_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01EntityType_00_01SplineDatdd11f66e3f203bad116bc3594e5b35d6.html">SplineData&lt; Scalar, Order, NumSpaceDim, EntityType, SplineDataMemberTypes&lt; Tags... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify each data member individually through tags.  <a href="structCajita_1_1SplineData_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01EntityType_00_01SplineDatdd11f66e3f203bad116bc3594e5b35d6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineData_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01EntityType_00_01void_01_4.html">SplineData&lt; Scalar, Order, NumSpaceDim, EntityType, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default of void has all data members.  <a href="structCajita_1_1SplineData_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01EntityType_00_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineDataMember.html">SplineDataMember</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data member.  <a href="structCajita_1_1SplineDataMember.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplineLogicalPosition_01_4.html">SplineDataMember&lt; Scalar, Order, NumSpaceDim, SplineLogicalPosition &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical position spline data member.  <a href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplineLogicalPosition_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplinePhysicalCellSize_01_4.html">SplineDataMember&lt; Scalar, Order, NumSpaceDim, SplinePhysicalCellSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical cell size spline data member.  <a href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplinePhysicalCellSize_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplinePhysicalDistance_01_4.html">SplineDataMember&lt; Scalar, Order, NumSpaceDim, SplinePhysicalDistance &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical distance spline data member.  <a href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplinePhysicalDistance_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplineWeightPhysicalGradients_01_4.html">SplineDataMember&lt; Scalar, Order, NumSpaceDim, SplineWeightPhysicalGradients &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weight physical gradients spline data member.  <a href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplineWeightPhysicalGradients_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplineWeightValues_01_4.html">SplineDataMember&lt; Scalar, Order, NumSpaceDim, SplineWeightValues &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weight values spline data member.  <a href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplineWeightValues_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineDataMemberTypes.html">SplineDataMemberTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data members holder.  <a href="structCajita_1_1SplineDataMemberTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineLogicalPosition.html">SplineLogicalPosition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data tag: logical position.  <a href="structCajita_1_1SplineLogicalPosition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplinePhysicalCellSize.html">SplinePhysicalCellSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data tag: physical cell size.  <a href="structCajita_1_1SplinePhysicalCellSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplinePhysicalDistance.html">SplinePhysicalDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data tag: physical distance.  <a href="structCajita_1_1SplinePhysicalDistance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineWeightPhysicalGradients.html">SplineWeightPhysicalGradients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data tag: physical gradient.  <a href="structCajita_1_1SplineWeightPhysicalGradients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineWeightValues.html">SplineWeightValues</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data tag: weight value.  <a href="structCajita_1_1SplineWeightValues.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1TensorDivergenceP2G.html">TensorDivergenceP2G</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point-to-grid tensor divergence functor.  <a href="structCajita_1_1TensorDivergenceP2G.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1TileID2HashKey.html">TileID2HashKey</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1TileID2HashKey_3_01Key_00_01HashTypes_1_1Morton_01_4.html">TileID2HashKey&lt; Key, HashTypes::Morton &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hash key from the 3D tile ijk.  <a href="structCajita_1_1TileID2HashKey_3_01Key_00_01HashTypes_1_1Morton_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1TileID2HashKey_3_01Key_00_01HashTypes_1_1Naive_01_4.html">TileID2HashKey&lt; Key, HashTypes::Naive &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hash key from the 3D tile ijk.  <a href="structCajita_1_1TileID2HashKey_3_01Key_00_01HashTypes_1_1Naive_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1TileIndexSpace.html">TileIndexSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index space with tile as unit; _min and _max forms the tile range. Note this is for sparse grid only, mainly used in sparse halo impl.  <a href="classCajita_1_1TileIndexSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1TileMap.html">TileMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of <a class="el" href="classCajita_1_1TileMap.html" title="Declaration of TileMap.">TileMap</a>.  <a href="classCajita_1_1TileMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1UniformDimPartitioner.html">UniformDimPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backwards compatibility wrapper for 3D <a class="el" href="classCajita_1_1DimBlockPartitioner.html" title="Dimension-only partitioner.">DimBlockPartitioner</a>.  <a href="classCajita_1_1UniformDimPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform mesh tag.  <a href="structCajita_1_1UniformMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1VectorDivergenceG2P.html">VectorDivergenceG2P</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid-to-point vector value functor.  <a href="structCajita_1_1VectorDivergenceG2P.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1VectorDivergenceP2G.html">VectorDivergenceP2G</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point-to-grid vector divergence functor.  <a href="structCajita_1_1VectorDivergenceP2G.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1VectorGradientG2P.html">VectorGradientG2P</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid-to-point vector gradient functor.  <a href="structCajita_1_1VectorGradientG2P.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1VectorValueG2P.html">VectorValueG2P</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid-to-point vector value functor.  <a href="structCajita_1_1VectorValueG2P.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1VectorValueP2G.html">VectorValueP2G</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point-to-grid vector value functor.  <a href="structCajita_1_1VectorValueP2G.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2ec822f40e278e94dbe22325c2b4c824"><td class="memItemLeft" align="right" valign="top"><a id="a2ec822f40e278e94dbe22325c2b4c824" name="a2ec822f40e278e94dbe22325c2b4c824"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a2ec822f40e278e94dbe22325c2b4c824">HashTypes</a> : unsigned char { <b>Naive</b> = 0
, <b>Morton</b> = 1
 }</td></tr>
<tr class="memdesc:a2ec822f40e278e94dbe22325c2b4c824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash table type tag. <br /></td></tr>
<tr class="separator:a2ec822f40e278e94dbe22325c2b4c824"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adefcb7bda05af73d9acd1b8c4d4e6b00"><td class="memTemplParams" colspan="2">template&lt;class EntityType , class MeshType &gt; </td></tr>
<tr class="memitem:adefcb7bda05af73d9acd1b8c4d4e6b00"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#adefcb7bda05af73d9acd1b8c4d4e6b00">createArrayLayout</a> (const std::shared_ptr&lt; <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &gt; &amp;local_grid, const int dofs_per_entity, EntityType)</td></tr>
<tr class="memdesc:adefcb7bda05af73d9acd1b8c4d4e6b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array layout over the entities of a local grid.  <br /></td></tr>
<tr class="separator:adefcb7bda05af73d9acd1b8c4d4e6b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ad222eb8b2ed544af3ce40e9fe7b36"><td class="memTemplParams" colspan="2">template&lt;class EntityType , class MeshType &gt; </td></tr>
<tr class="memitem:a33ad222eb8b2ed544af3ce40e9fe7b36"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a33ad222eb8b2ed544af3ce40e9fe7b36">createArrayLayout</a> (const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt; MeshType &gt; &gt; &amp;global_grid, const int halo_cell_width, const int dofs_per_entity, EntityType)</td></tr>
<tr class="memdesc:a33ad222eb8b2ed544af3ce40e9fe7b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array layout over the entities of a grid given local grid parameters. An intermediate local grid will be created and assigned to the layout.  <br /></td></tr>
<tr class="separator:a33ad222eb8b2ed544af3ce40e9fe7b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a66aaed41884fd04d9d7b1ab464e5cd"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params, class EntityType , class MeshType &gt; </td></tr>
<tr class="memitem:a4a66aaed41884fd04d9d7b1ab464e5cd"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a4a66aaed41884fd04d9d7b1ab464e5cd">createArray</a> (const std::string &amp;label, const std::shared_ptr&lt; <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &gt; &amp;layout)</td></tr>
<tr class="memdesc:a4a66aaed41884fd04d9d7b1ab464e5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array with the given array layout. Views are constructed over the ghosted index space of the layout.  <br /></td></tr>
<tr class="separator:a4a66aaed41884fd04d9d7b1ab464e5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966e2b4b433fdf383c0809965cdaaac9"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class EntityType , class MeshType , class... Params&gt; </td></tr>
<tr class="memitem:a966e2b4b433fdf383c0809965cdaaac9"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, typename <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt;::subview_layout, typename <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt;::memory_space, typename <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt;::subview_memory_traits &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a966e2b4b433fdf383c0809965cdaaac9">createSubarray</a> (const <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt; &amp;array, const int dof_min, const int dof_max)</td></tr>
<tr class="memdesc:a966e2b4b433fdf383c0809965cdaaac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a subarray of the given array over the given range of degrees of freedom.  <br /></td></tr>
<tr class="separator:a966e2b4b433fdf383c0809965cdaaac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e950c1c2bb6e812a513515c342940e"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:aa4e950c1c2bb6e812a513515c342940e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt; MeshType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aa4e950c1c2bb6e812a513515c342940e">createGlobalGrid</a> (MPI_Comm comm, const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; MeshType &gt; &gt; &amp;global_mesh, const std::array&lt; bool, MeshType::num_space_dim &gt; &amp;periodic, const <a class="el" href="classCajita_1_1BlockPartitioner.html">BlockPartitioner</a>&lt; MeshType::num_space_dim &gt; &amp;partitioner)</td></tr>
<tr class="memdesc:aa4e950c1c2bb6e812a513515c342940e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global grid.  <br /></td></tr>
<tr class="separator:aa4e950c1c2bb6e812a513515c342940e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb8877728a72318f7c6384446f700fb"><td class="memTemplParams" colspan="2">template&lt;class Scalar , std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:aecb8877728a72318f7c6384446f700fb"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aecb8877728a72318f7c6384446f700fb">createGlobalGrid</a> (MPI_Comm comm, const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt; &amp;global_mesh, const std::array&lt; bool, <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt;::num_space_dim &gt; &amp;periodic, const <a class="el" href="classCajita_1_1BlockPartitioner.html">BlockPartitioner</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt;::num_space_dim &gt; &amp;partitioner)</td></tr>
<tr class="memdesc:aecb8877728a72318f7c6384446f700fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sparse global grid.  <br /></td></tr>
<tr class="separator:aecb8877728a72318f7c6384446f700fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ade2ab7814eff8c8fcf0458db57834"><td class="memTemplParams" colspan="2">template&lt;class Scalar , std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:a16ade2ab7814eff8c8fcf0458db57834"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a16ade2ab7814eff8c8fcf0458db57834">createUniformGlobalMesh</a> (const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_low_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_high_corner, const Scalar cell_size)</td></tr>
<tr class="memdesc:a16ade2ab7814eff8c8fcf0458db57834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create uniform mesh with uniform cell size.  <br /></td></tr>
<tr class="separator:a16ade2ab7814eff8c8fcf0458db57834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f119fd6e65291b17c727cde04e75ea"><td class="memTemplParams" colspan="2">template&lt;class Scalar , std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:a58f119fd6e65291b17c727cde04e75ea"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a58f119fd6e65291b17c727cde04e75ea">createUniformGlobalMesh</a> (const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_low_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_high_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;cell_size)</td></tr>
<tr class="memdesc:a58f119fd6e65291b17c727cde04e75ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create uniform mesh with uniform cell size.  <br /></td></tr>
<tr class="separator:a58f119fd6e65291b17c727cde04e75ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d19738dfc2e199c3c650f6ded685cc"><td class="memTemplParams" colspan="2">template&lt;class Scalar , std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:ab5d19738dfc2e199c3c650f6ded685cc"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ab5d19738dfc2e199c3c650f6ded685cc">createUniformGlobalMesh</a> (const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_low_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_high_corner, const std::array&lt; int, NumSpaceDim &gt; &amp;global_num_cell)</td></tr>
<tr class="memdesc:ab5d19738dfc2e199c3c650f6ded685cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create uniform mesh with total number of cells.  <br /></td></tr>
<tr class="separator:ab5d19738dfc2e199c3c650f6ded685cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b3d8e281a87bbbad41d683ccdc2932"><td class="memTemplParams" colspan="2">template&lt;class Scalar , std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:a57b3d8e281a87bbbad41d683ccdc2932"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a57b3d8e281a87bbbad41d683ccdc2932">createSparseGlobalMesh</a> (const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_low_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_high_corner, const Scalar cell_size)</td></tr>
<tr class="memdesc:a57b3d8e281a87bbbad41d683ccdc2932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create sparse mesh with uniform cell size.  <br /></td></tr>
<tr class="separator:a57b3d8e281a87bbbad41d683ccdc2932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719fca8fb1f9b118e0861f7945acba31"><td class="memTemplParams" colspan="2">template&lt;class Scalar , std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:a719fca8fb1f9b118e0861f7945acba31"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a719fca8fb1f9b118e0861f7945acba31">createSparseGlobalMesh</a> (const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_low_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_high_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;cell_size)</td></tr>
<tr class="memdesc:a719fca8fb1f9b118e0861f7945acba31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create sparse mesh with uniform cell size.  <br /></td></tr>
<tr class="separator:a719fca8fb1f9b118e0861f7945acba31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa0745c47c59a4b2b217d2e8c381917"><td class="memTemplParams" colspan="2">template&lt;class Scalar , std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:a3fa0745c47c59a4b2b217d2e8c381917"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a3fa0745c47c59a4b2b217d2e8c381917">createSparseGlobalMesh</a> (const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_low_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_high_corner, const std::array&lt; int, NumSpaceDim &gt; &amp;global_num_cell)</td></tr>
<tr class="memdesc:a3fa0745c47c59a4b2b217d2e8c381917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create sparse mesh with total number of cells.  <br /></td></tr>
<tr class="separator:a3fa0745c47c59a4b2b217d2e8c381917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e22d3e3c25b63a4b0b248fbb2a798d"><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:a37e22d3e3c25b63a4b0b248fbb2a798d"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1NonUniformMesh.html">NonUniformMesh</a>&lt; Scalar, 3 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a37e22d3e3c25b63a4b0b248fbb2a798d">createNonUniformGlobalMesh</a> (const std::vector&lt; Scalar &gt; &amp;i_edges, const std::vector&lt; Scalar &gt; &amp;j_edges, const std::vector&lt; Scalar &gt; &amp;k_edges)</td></tr>
<tr class="memdesc:a37e22d3e3c25b63a4b0b248fbb2a798d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a non-uniform 3D mesh.  <br /></td></tr>
<tr class="separator:a37e22d3e3c25b63a4b0b248fbb2a798d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6558146b8c8a36758de47e1cebbfc1dc"><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:a6558146b8c8a36758de47e1cebbfc1dc"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1NonUniformMesh.html">NonUniformMesh</a>&lt; Scalar, 2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a6558146b8c8a36758de47e1cebbfc1dc">createNonUniformGlobalMesh</a> (const std::vector&lt; Scalar &gt; &amp;i_edges, const std::vector&lt; Scalar &gt; &amp;j_edges)</td></tr>
<tr class="memdesc:a6558146b8c8a36758de47e1cebbfc1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a non-uniform 2D mesh.  <br /></td></tr>
<tr class="separator:a6558146b8c8a36758de47e1cebbfc1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047ee0472b03e9ef8798fc34f110c28d"><td class="memTemplParams" colspan="2">template&lt;class Pattern , class... ArrayTypes&gt; </td></tr>
<tr class="memitem:a047ee0472b03e9ef8798fc34f110c28d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a047ee0472b03e9ef8798fc34f110c28d">createHalo</a> (const Pattern &amp;pattern, const int width, const ArrayTypes &amp;... arrays)</td></tr>
<tr class="memdesc:a047ee0472b03e9ef8798fc34f110c28d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCajita_1_1Halo.html">Halo</a> creation function.  <br /></td></tr>
<tr class="separator:a047ee0472b03e9ef8798fc34f110c28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8e3f33f12e80ce359f1d4840ee641c"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class MemorySpace , class EntityType , class MeshType , class Pattern &gt; </td></tr>
<tr class="memitem:abb8e3f33f12e80ce359f1d4840ee641c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#abb8e3f33f12e80ce359f1d4840ee641c">createHalo</a> (const <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &amp;layout, const Pattern &amp;pattern, const int width=-1)</td></tr>
<tr class="memdesc:abb8e3f33f12e80ce359f1d4840ee641c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a halo with a layout.  <br /></td></tr>
<tr class="separator:abb8e3f33f12e80ce359f1d4840ee641c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342119f5d5b011c689cc474e16cc70e5"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class EntityType , class MeshType , class Pattern , class... Params&gt; </td></tr>
<tr class="memitem:a342119f5d5b011c689cc474e16cc70e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a342119f5d5b011c689cc474e16cc70e5">createHalo</a> (const <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt; &amp;array, const Pattern &amp;pattern, const int width=-1)</td></tr>
<tr class="memdesc:a342119f5d5b011c689cc474e16cc70e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a halo.  <br /></td></tr>
<tr class="separator:a342119f5d5b011c689cc474e16cc70e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9324aa4ca484d5161b846b624fde85eb"><td class="memTemplParams" colspan="2"><a id="a9324aa4ca484d5161b846b624fde85eb" name="a9324aa4ca484d5161b846b624fde85eb"></a>
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a9324aa4ca484d5161b846b624fde85eb"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreSemiStructPCG.html">HypreSemiStructPCG</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createHypreSemiStructPCG</b> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false, int n_vars=3)</td></tr>
<tr class="memdesc:a9324aa4ca484d5161b846b624fde85eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HYPRE PCG semi-structured solver. <br /></td></tr>
<tr class="separator:a9324aa4ca484d5161b846b624fde85eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061fb23a04b2015dbe777db316133f84"><td class="memTemplParams" colspan="2"><a id="a061fb23a04b2015dbe777db316133f84" name="a061fb23a04b2015dbe777db316133f84"></a>
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a061fb23a04b2015dbe777db316133f84"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreSemiStructGMRES.html">HypreSemiStructGMRES</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createHypreSemiStructGMRES</b> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false, int n_vars=3)</td></tr>
<tr class="memdesc:a061fb23a04b2015dbe777db316133f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HYPRE GMRES semi-structured solver. <br /></td></tr>
<tr class="separator:a061fb23a04b2015dbe777db316133f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed55a3db82012e28a6f9cc4684d09929"><td class="memTemplParams" colspan="2"><a id="aed55a3db82012e28a6f9cc4684d09929" name="aed55a3db82012e28a6f9cc4684d09929"></a>
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:aed55a3db82012e28a6f9cc4684d09929"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreSemiStructBiCGSTAB.html">HypreSemiStructBiCGSTAB</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createHypreSemiStructBiCGSTAB</b> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false, int n_vars=3)</td></tr>
<tr class="memdesc:aed55a3db82012e28a6f9cc4684d09929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HYPRE BiCGSTAB semi-structured solver. <br /></td></tr>
<tr class="separator:aed55a3db82012e28a6f9cc4684d09929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c783f7c3edc563b55aa3b4491ebebc"><td class="memTemplParams" colspan="2"><a id="a78c783f7c3edc563b55aa3b4491ebebc" name="a78c783f7c3edc563b55aa3b4491ebebc"></a>
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a78c783f7c3edc563b55aa3b4491ebebc"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreSemiStructDiagonal.html">HypreSemiStructDiagonal</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createHypreSemiStructDiagonal</b> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false, int n_vars=3)</td></tr>
<tr class="memdesc:a78c783f7c3edc563b55aa3b4491ebebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HYPRE Diagonal semi-structured solver. <br /></td></tr>
<tr class="separator:a78c783f7c3edc563b55aa3b4491ebebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c393ffd77e2c1f52c016967d4f29b36"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a5c393ffd77e2c1f52c016967d4f29b36"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreSemiStructuredSolver.html">HypreSemiStructuredSolver</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a5c393ffd77e2c1f52c016967d4f29b36">createHypreSemiStructuredSolver</a> (const std::string &amp;solver_type, const ArrayLayout_t &amp;layout, const bool is_preconditioner=false, int n_vars=3)</td></tr>
<tr class="memdesc:a5c393ffd77e2c1f52c016967d4f29b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HYPRE semi-structured solver.  <br /></td></tr>
<tr class="separator:a5c393ffd77e2c1f52c016967d4f29b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c92d4aae32d9f5d56b31a0b8279ceb7"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a3c92d4aae32d9f5d56b31a0b8279ceb7"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructPCG.html">HypreStructPCG</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a3c92d4aae32d9f5d56b31a0b8279ceb7">createHypreStructPCG</a> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="separator:a3c92d4aae32d9f5d56b31a0b8279ceb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d71f02651fd8a97cdc442fb874a495f"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a5d71f02651fd8a97cdc442fb874a495f"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructGMRES.html">HypreStructGMRES</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a5d71f02651fd8a97cdc442fb874a495f">createHypreStructGMRES</a> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="separator:a5d71f02651fd8a97cdc442fb874a495f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245f4b046906b9df567d04ec0b3134c7"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a245f4b046906b9df567d04ec0b3134c7"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructBiCGSTAB.html">HypreStructBiCGSTAB</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a245f4b046906b9df567d04ec0b3134c7">createHypreStructBiCGSTAB</a> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="separator:a245f4b046906b9df567d04ec0b3134c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1caff74a3aa4d7f764fe7467419224bb"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a1caff74a3aa4d7f764fe7467419224bb"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructPFMG.html">HypreStructPFMG</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a1caff74a3aa4d7f764fe7467419224bb">createHypreStructPFMG</a> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="separator:a1caff74a3aa4d7f764fe7467419224bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c7de540918841a4f8dc4ddfb521edf"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a45c7de540918841a4f8dc4ddfb521edf"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructSMG.html">HypreStructSMG</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a45c7de540918841a4f8dc4ddfb521edf">createHypreStructSMG</a> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="separator:a45c7de540918841a4f8dc4ddfb521edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c0ac9ccf5f75940088f70085aac42a"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a50c0ac9ccf5f75940088f70085aac42a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructJacobi.html">HypreStructJacobi</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a50c0ac9ccf5f75940088f70085aac42a">createHypreStructJacobi</a> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="separator:a50c0ac9ccf5f75940088f70085aac42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5181ce534138c85176950c6bff1d1a04"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a5181ce534138c85176950c6bff1d1a04"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructDiagonal.html">HypreStructDiagonal</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a5181ce534138c85176950c6bff1d1a04">createHypreStructDiagonal</a> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="separator:a5181ce534138c85176950c6bff1d1a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c28a5827014301ee6072123bd0ab97e"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a5c28a5827014301ee6072123bd0ab97e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructuredSolver.html">HypreStructuredSolver</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a5c28a5827014301ee6072123bd0ab97e">createHypreStructuredSolver</a> (const std::string &amp;solver_type, const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="memdesc:a5c28a5827014301ee6072123bd0ab97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HYPRE structured solver.  <br /></td></tr>
<tr class="separator:a5c28a5827014301ee6072123bd0ab97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdf1c2aa21fee549c55f4610e9ac5b8"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace &gt; </td></tr>
<tr class="memitem:a0fdf1c2aa21fee549c55f4610e9ac5b8"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::RangePolicy&lt; ExecutionSpace &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a0fdf1c2aa21fee549c55f4610e9ac5b8">createExecutionPolicy</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;index_space, const ExecutionSpace &amp;)</td></tr>
<tr class="memdesc:a0fdf1c2aa21fee549c55f4610e9ac5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a multi-dimensional execution policy over an index space.  <br /></td></tr>
<tr class="separator:a0fdf1c2aa21fee549c55f4610e9ac5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ff824e39e183fe89d3edae6acfae2d"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class WorkTag &gt; </td></tr>
<tr class="memitem:ab7ff824e39e183fe89d3edae6acfae2d"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::RangePolicy&lt; ExecutionSpace, WorkTag &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ab7ff824e39e183fe89d3edae6acfae2d">createExecutionPolicy</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;index_space, const ExecutionSpace &amp;, const WorkTag &amp;)</td></tr>
<tr class="memdesc:ab7ff824e39e183fe89d3edae6acfae2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a multi-dimensional execution policy over an index space.  <br /></td></tr>
<tr class="separator:ab7ff824e39e183fe89d3edae6acfae2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebdf82160fd53a757e368eb94c65246"><td class="memTemplParams" colspan="2">template&lt;class IndexSpace_t , class ExecutionSpace &gt; </td></tr>
<tr class="memitem:a2ebdf82160fd53a757e368eb94c65246"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::MDRangePolicy&lt; ExecutionSpace, Kokkos::Rank&lt; IndexSpace_t::Rank &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a2ebdf82160fd53a757e368eb94c65246">createExecutionPolicy</a> (const IndexSpace_t &amp;index_space, const ExecutionSpace &amp;)</td></tr>
<tr class="memdesc:a2ebdf82160fd53a757e368eb94c65246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a multi-dimensional execution policy over an index space.  <br /></td></tr>
<tr class="separator:a2ebdf82160fd53a757e368eb94c65246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacc6c22c6ce7bb70ff0d9f78b9797b5"><td class="memTemplParams" colspan="2">template&lt;class IndexSpace_t , class ExecutionSpace , class WorkTag &gt; </td></tr>
<tr class="memitem:aeacc6c22c6ce7bb70ff0d9f78b9797b5"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::MDRangePolicy&lt; ExecutionSpace, WorkTag, Kokkos::Rank&lt; IndexSpace_t::Rank &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aeacc6c22c6ce7bb70ff0d9f78b9797b5">createExecutionPolicy</a> (const IndexSpace_t &amp;index_space, const ExecutionSpace &amp;, const WorkTag &amp;)</td></tr>
<tr class="memdesc:aeacc6c22c6ce7bb70ff0d9f78b9797b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a multi-dimensional execution policy over an index space with a work tag.  <br /></td></tr>
<tr class="separator:aeacc6c22c6ce7bb70ff0d9f78b9797b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24fe00c83ebfa654cf17e1b37da1df4"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:ab24fe00c83ebfa654cf17e1b37da1df4"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar *, Params... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ab24fe00c83ebfa654cf17e1b37da1df4">createView</a> (const std::string &amp;label, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;index_space)</td></tr>
<tr class="memdesc:ab24fe00c83ebfa654cf17e1b37da1df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space create a view over the extent of that index space.  <br /></td></tr>
<tr class="separator:ab24fe00c83ebfa654cf17e1b37da1df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f6ec432d9d9173b3882e0a9fcad001"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:a35f6ec432d9d9173b3882e0a9fcad001"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar *, Params..., Kokkos::MemoryUnmanaged &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a35f6ec432d9d9173b3882e0a9fcad001">createView</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;index_space, Scalar *data)</td></tr>
<tr class="memdesc:a35f6ec432d9d9173b3882e0a9fcad001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space and a data pointer create an unmanaged view over the extent of that index space.  <br /></td></tr>
<tr class="separator:a35f6ec432d9d9173b3882e0a9fcad001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9158690c5131a1b161d9231bd8689b80"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:a9158690c5131a1b161d9231bd8689b80"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar **, Params... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a9158690c5131a1b161d9231bd8689b80">createView</a> (const std::string &amp;label, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &amp;index_space)</td></tr>
<tr class="memdesc:a9158690c5131a1b161d9231bd8689b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space create a view over the extent of that index space.  <br /></td></tr>
<tr class="separator:a9158690c5131a1b161d9231bd8689b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0532beb1d6581bb6cd9209ca66138d64"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:a0532beb1d6581bb6cd9209ca66138d64"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar **, Params..., Kokkos::MemoryUnmanaged &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a0532beb1d6581bb6cd9209ca66138d64">createView</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &amp;index_space, Scalar *data)</td></tr>
<tr class="memdesc:a0532beb1d6581bb6cd9209ca66138d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space and a data pointer create an unmanaged view over the extent of that index space.  <br /></td></tr>
<tr class="separator:a0532beb1d6581bb6cd9209ca66138d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bf0e22ae8f2deab76e5fbd7b00af3e"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:ab3bf0e22ae8f2deab76e5fbd7b00af3e"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar ***, Params... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ab3bf0e22ae8f2deab76e5fbd7b00af3e">createView</a> (const std::string &amp;label, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &amp;index_space)</td></tr>
<tr class="memdesc:ab3bf0e22ae8f2deab76e5fbd7b00af3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space create a view over the extent of that index space.  <br /></td></tr>
<tr class="separator:ab3bf0e22ae8f2deab76e5fbd7b00af3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0161931a68a6885f9677065f1ae75061"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:a0161931a68a6885f9677065f1ae75061"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar ***, Params..., Kokkos::MemoryUnmanaged &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a0161931a68a6885f9677065f1ae75061">createView</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &amp;index_space, Scalar *data)</td></tr>
<tr class="memdesc:a0161931a68a6885f9677065f1ae75061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space and a data pointer create an unmanaged view over the extent of that index space.  <br /></td></tr>
<tr class="separator:a0161931a68a6885f9677065f1ae75061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b5c9fe52af6b7e411c68b9e59733ee"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:a79b5c9fe52af6b7e411c68b9e59733ee"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar ****, Params... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a79b5c9fe52af6b7e411c68b9e59733ee">createView</a> (const std::string &amp;label, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt; &amp;index_space)</td></tr>
<tr class="memdesc:a79b5c9fe52af6b7e411c68b9e59733ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space create a view over the extent of that index space.  <br /></td></tr>
<tr class="separator:a79b5c9fe52af6b7e411c68b9e59733ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9573b857e2ae0d4dcc2935527017d16"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:ac9573b857e2ae0d4dcc2935527017d16"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar ****, Params..., Kokkos::MemoryUnmanaged &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ac9573b857e2ae0d4dcc2935527017d16">createView</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt; &amp;index_space, Scalar *data)</td></tr>
<tr class="memdesc:ac9573b857e2ae0d4dcc2935527017d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space and a data pointer create an unmanaged view over the extent of that index space.  <br /></td></tr>
<tr class="separator:ac9573b857e2ae0d4dcc2935527017d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffd9f583a762bf067ff0d583b5e3498"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:afffd9f583a762bf067ff0d583b5e3498"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#afffd9f583a762bf067ff0d583b5e3498">createSubview</a> (const ViewType &amp;view, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;index_space) -&gt; decltype(Kokkos::subview(view, index_space.range(0)))</td></tr>
<tr class="memdesc:afffd9f583a762bf067ff0d583b5e3498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a view create a subview over the given index space.  <br /></td></tr>
<tr class="separator:afffd9f583a762bf067ff0d583b5e3498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4594470daa8143fa9a8f65e5689c3ae7"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a4594470daa8143fa9a8f65e5689c3ae7"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a4594470daa8143fa9a8f65e5689c3ae7">createSubview</a> (const ViewType &amp;view, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &amp;index_space) -&gt; decltype(Kokkos::subview(view, index_space.range(0), index_space.range(1)))</td></tr>
<tr class="memdesc:a4594470daa8143fa9a8f65e5689c3ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a view create a subview over the given index space.  <br /></td></tr>
<tr class="separator:a4594470daa8143fa9a8f65e5689c3ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb002d4e9b61930c1478eaf4f00d610f"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:aeb002d4e9b61930c1478eaf4f00d610f"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aeb002d4e9b61930c1478eaf4f00d610f">createSubview</a> (const ViewType &amp;view, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &amp;index_space) -&gt; decltype(Kokkos::subview(view, index_space.range(0), index_space.range(1), index_space.range(2)))</td></tr>
<tr class="memdesc:aeb002d4e9b61930c1478eaf4f00d610f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a view create a subview over the given index space.  <br /></td></tr>
<tr class="separator:aeb002d4e9b61930c1478eaf4f00d610f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413c2645baa122d4cb8f079597e43fce"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a413c2645baa122d4cb8f079597e43fce"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a413c2645baa122d4cb8f079597e43fce">createSubview</a> (const ViewType &amp;view, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt; &amp;index_space) -&gt; decltype(Kokkos::subview(view, index_space.range(0), index_space.range(1), index_space.range(2), index_space.range(3)))</td></tr>
<tr class="memdesc:a413c2645baa122d4cb8f079597e43fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a view create a subview over the given index space.  <br /></td></tr>
<tr class="separator:a413c2645baa122d4cb8f079597e43fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0652ddec74a14c5efdd4178f98cf0e38"><td class="memTemplParams" colspan="2">template&lt;long N&gt; </td></tr>
<tr class="memitem:a0652ddec74a14c5efdd4178f98cf0e38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a0652ddec74a14c5efdd4178f98cf0e38">appendDimension</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;index_space, const long size)</td></tr>
<tr class="memdesc:a0652ddec74a14c5efdd4178f98cf0e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an N-dimensional index space append an additional dimension with the given size.  <br /></td></tr>
<tr class="separator:a0652ddec74a14c5efdd4178f98cf0e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72bb9627157c6ffd385b4ae8b831d20"><td class="memTemplParams" colspan="2">template&lt;long N&gt; </td></tr>
<tr class="memitem:ae72bb9627157c6ffd385b4ae8b831d20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ae72bb9627157c6ffd385b4ae8b831d20">appendDimension</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;index_space, const long min, const long max)</td></tr>
<tr class="memdesc:ae72bb9627157c6ffd385b4ae8b831d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an N-dimensional index space append an additional dimension with the given range.  <br /></td></tr>
<tr class="separator:ae72bb9627157c6ffd385b4ae8b831d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d19f2ef5451251a976755c2d564bd9"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class PointEvalFunctor , class PointCoordinates , class ArrayScalar , class MeshScalar , class EntityType , int SplineOrder, std::size_t NumSpaceDim, class MemorySpace , class... ArrayParams&gt; </td></tr>
<tr class="memitem:ad9d19f2ef5451251a976755c2d564bd9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ad9d19f2ef5451251a976755c2d564bd9">g2p</a> (ExecutionSpace, const <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; ArrayScalar, EntityType, <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; MeshScalar, NumSpaceDim &gt;, ArrayParams... &gt; &amp;array, const <a class="el" href="classCajita_1_1Halo.html">Halo</a>&lt; MemorySpace &gt; &amp;halo, const PointCoordinates &amp;points, const std::size_t num_point, <a class="el" href="structCajita_1_1Spline.html">Spline</a>&lt; SplineOrder &gt;, const PointEvalFunctor &amp;functor)</td></tr>
<tr class="memdesc:ad9d19f2ef5451251a976755c2d564bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> Grid-to-Point interpolation.  <br /></td></tr>
<tr class="separator:ad9d19f2ef5451251a976755c2d564bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29734b06e0d3e134136763ccfe527119"><td class="memTemplParams" colspan="2">template&lt;class PointEvalFunctor , class PointCoordinates , class ArrayScalar , class MeshScalar , class EntityType , int SplineOrder, std::size_t NumSpaceDim, class MemorySpace , class... ArrayParams&gt; </td></tr>
<tr class="memitem:a29734b06e0d3e134136763ccfe527119"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a29734b06e0d3e134136763ccfe527119">g2p</a> (const <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; ArrayScalar, EntityType, <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; MeshScalar, NumSpaceDim &gt;, ArrayParams... &gt; &amp;array, const <a class="el" href="classCajita_1_1Halo.html">Halo</a>&lt; MemorySpace &gt; &amp;halo, const PointCoordinates &amp;points, const std::size_t num_point, <a class="el" href="structCajita_1_1Spline.html">Spline</a>&lt; SplineOrder &gt;, const PointEvalFunctor &amp;functor)</td></tr>
<tr class="memdesc:a29734b06e0d3e134136763ccfe527119"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> Grid-to-Point interpolation.  <br /></td></tr>
<tr class="separator:a29734b06e0d3e134136763ccfe527119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af216844047716b9ed30e193350c0ac87"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:af216844047716b9ed30e193350c0ac87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1ScalarValueG2P.html">ScalarValueG2P</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#af216844047716b9ed30e193350c0ac87">createScalarValueG2P</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:af216844047716b9ed30e193350c0ac87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for grid-to-point with scalar value.  <br /></td></tr>
<tr class="separator:af216844047716b9ed30e193350c0ac87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550995d7068512563be8850fabede1bf"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a550995d7068512563be8850fabede1bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1VectorValueG2P.html">VectorValueG2P</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a550995d7068512563be8850fabede1bf">createVectorValueG2P</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:a550995d7068512563be8850fabede1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for grid-to-point with vector value.  <br /></td></tr>
<tr class="separator:a550995d7068512563be8850fabede1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60732be857858da54d80ef3d79d90a2b"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a60732be857858da54d80ef3d79d90a2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1ScalarGradientG2P.html">ScalarGradientG2P</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a60732be857858da54d80ef3d79d90a2b">createScalarGradientG2P</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:a60732be857858da54d80ef3d79d90a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for grid-to-point with scalar gradient.  <br /></td></tr>
<tr class="separator:a60732be857858da54d80ef3d79d90a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a7aa16c0af807d86e915f85c6d4eba"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:ac5a7aa16c0af807d86e915f85c6d4eba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1VectorGradientG2P.html">VectorGradientG2P</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ac5a7aa16c0af807d86e915f85c6d4eba">createVectorGradientG2P</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:ac5a7aa16c0af807d86e915f85c6d4eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for grid-to-point with vector gradient.  <br /></td></tr>
<tr class="separator:ac5a7aa16c0af807d86e915f85c6d4eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d90eb25c79d9ff881e21aecee1a203"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a03d90eb25c79d9ff881e21aecee1a203"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1VectorDivergenceG2P.html">VectorDivergenceG2P</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a03d90eb25c79d9ff881e21aecee1a203">createVectorDivergenceG2P</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:a03d90eb25c79d9ff881e21aecee1a203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for grid-to-point with vector divergence.  <br /></td></tr>
<tr class="separator:a03d90eb25c79d9ff881e21aecee1a203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463fdf70de28bb1d20f9c12944101692"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class PointEvalFunctor , class PointCoordinates , class ArrayScalar , class MeshScalar , std::size_t NumSpaceDim, class EntityType , int SplineOrder, class MemorySpace , class... ArrayParams&gt; </td></tr>
<tr class="memitem:a463fdf70de28bb1d20f9c12944101692"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a463fdf70de28bb1d20f9c12944101692">p2g</a> (ExecutionSpace, const PointEvalFunctor &amp;functor, const PointCoordinates &amp;points, const std::size_t num_point, <a class="el" href="structCajita_1_1Spline.html">Spline</a>&lt; SplineOrder &gt;, const <a class="el" href="classCajita_1_1Halo.html">Halo</a>&lt; MemorySpace &gt; &amp;halo, <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; ArrayScalar, EntityType, <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; MeshScalar, NumSpaceDim &gt;, ArrayParams... &gt; &amp;array)</td></tr>
<tr class="memdesc:a463fdf70de28bb1d20f9c12944101692"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> Point-to-Grid interpolation.  <br /></td></tr>
<tr class="separator:a463fdf70de28bb1d20f9c12944101692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7718a376faa4470d8c6684946c8387"><td class="memTemplParams" colspan="2">template&lt;class PointEvalFunctor , class PointCoordinates , class ArrayScalar , class MeshScalar , std::size_t NumSpaceDim, class EntityType , int SplineOrder, class MemorySpace , class... ArrayParams&gt; </td></tr>
<tr class="memitem:a8e7718a376faa4470d8c6684946c8387"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a8e7718a376faa4470d8c6684946c8387">p2g</a> (const PointEvalFunctor &amp;functor, const PointCoordinates &amp;points, const std::size_t num_point, <a class="el" href="structCajita_1_1Spline.html">Spline</a>&lt; SplineOrder &gt;, const <a class="el" href="classCajita_1_1Halo.html">Halo</a>&lt; MemorySpace &gt; &amp;halo, <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; ArrayScalar, EntityType, <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; MeshScalar, NumSpaceDim &gt;, ArrayParams... &gt; &amp;array)</td></tr>
<tr class="memdesc:a8e7718a376faa4470d8c6684946c8387"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> Point-to-Grid interpolation.  <br /></td></tr>
<tr class="separator:a8e7718a376faa4470d8c6684946c8387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6673ee759e0056d8080f12b178e612"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:aff6673ee759e0056d8080f12b178e612"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1ScalarValueP2G.html">ScalarValueP2G</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aff6673ee759e0056d8080f12b178e612">createScalarValueP2G</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:aff6673ee759e0056d8080f12b178e612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for point-to-grid with scalar value.  <br /></td></tr>
<tr class="separator:aff6673ee759e0056d8080f12b178e612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153b58a7f96c06db398c646e51071a76"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a153b58a7f96c06db398c646e51071a76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1VectorValueP2G.html">VectorValueP2G</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a153b58a7f96c06db398c646e51071a76">createVectorValueP2G</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:a153b58a7f96c06db398c646e51071a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for point-to-grid with vector value.  <br /></td></tr>
<tr class="separator:a153b58a7f96c06db398c646e51071a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac7b11ead96b662cabf7db52327e4ab"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:abac7b11ead96b662cabf7db52327e4ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1ScalarGradientP2G.html">ScalarGradientP2G</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#abac7b11ead96b662cabf7db52327e4ab">createScalarGradientP2G</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:abac7b11ead96b662cabf7db52327e4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for point-to-grid with scalar gradient.  <br /></td></tr>
<tr class="separator:abac7b11ead96b662cabf7db52327e4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5f57cb216ead977713612d719178de"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a2e5f57cb216ead977713612d719178de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1VectorDivergenceP2G.html">VectorDivergenceP2G</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a2e5f57cb216ead977713612d719178de">createVectorDivergenceP2G</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:a2e5f57cb216ead977713612d719178de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for point-to-grid with vector divergence.  <br /></td></tr>
<tr class="separator:a2e5f57cb216ead977713612d719178de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec36af19ffac23853a2e1429544e6d7b"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:aec36af19ffac23853a2e1429544e6d7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1TensorDivergenceP2G.html">TensorDivergenceP2G</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aec36af19ffac23853a2e1429544e6d7b">createTensorDivergenceP2G</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:aec36af19ffac23853a2e1429544e6d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for point-to-grid with tensor divergence.  <br /></td></tr>
<tr class="separator:aec36af19ffac23853a2e1429544e6d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f523da3312248cc6caa4ca35b79b66b"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a3f523da3312248cc6caa4ca35b79b66b"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a3f523da3312248cc6caa4ca35b79b66b">createLocalGrid</a> (const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt; MeshType &gt; &gt; &amp;global_grid, const int halo_cell_width)</td></tr>
<tr class="memdesc:a3f523da3312248cc6caa4ca35b79b66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a local grid.  <br /></td></tr>
<tr class="separator:a3f523da3312248cc6caa4ca35b79b66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5176bf2393c60ac5fc930c521ac2809c"><td class="memTemplParams" colspan="2">template&lt;class MemorySpace , class MeshType &gt; </td></tr>
<tr class="memitem:a5176bf2393c60ac5fc930c521ac2809c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCajita_1_1LocalMesh.html">LocalMesh</a>&lt; MemorySpace, MeshType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a5176bf2393c60ac5fc930c521ac2809c">createLocalMesh</a> (const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;local_grid)</td></tr>
<tr class="memdesc:a5176bf2393c60ac5fc930c521ac2809c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for local mesh.  <br /></td></tr>
<tr class="separator:a5176bf2393c60ac5fc930c521ac2809c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c57f5f0f71a9195f375410205a2df20"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class ExecutionSpace , long N&gt; </td></tr>
<tr class="memitem:a1c57f5f0f71a9195f375410205a2df20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a1c57f5f0f71a9195f375410205a2df20">grid_parallel_for</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;index_space, const FunctorType &amp;functor)</td></tr>
<tr class="memdesc:a1c57f5f0f71a9195f375410205a2df20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a functor in parallel with a multidimensional execution policy specified by the given index space.  <br /></td></tr>
<tr class="separator:a1c57f5f0f71a9195f375410205a2df20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644313d527fab5a1d9e59a138f51ec63"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class WorkTag , class ExecutionSpace , long N&gt; </td></tr>
<tr class="memitem:a644313d527fab5a1d9e59a138f51ec63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a644313d527fab5a1d9e59a138f51ec63">grid_parallel_for</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;index_space, const WorkTag &amp;work_tag, const FunctorType &amp;functor)</td></tr>
<tr class="memdesc:a644313d527fab5a1d9e59a138f51ec63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a functor with a work tag in parallel with a multidimensional execution policy specified by the given index space.  <br /></td></tr>
<tr class="separator:a644313d527fab5a1d9e59a138f51ec63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc2c75279e73a954b280239e841b444"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType &gt; </td></tr>
<tr class="memitem:a0cc2c75279e73a954b280239e841b444"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a0cc2c75279e73a954b280239e841b444">grid_parallel_for</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;local_grid, const DecompositionType &amp;decomposition, const EntityType &amp;entity_type, const FunctorType &amp;functor)</td></tr>
<tr class="memdesc:a0cc2c75279e73a954b280239e841b444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a functor in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local.  <br /></td></tr>
<tr class="separator:a0cc2c75279e73a954b280239e841b444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e1b082bbdd2df7693ce178f4d33749"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class WorkTag , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType &gt; </td></tr>
<tr class="memitem:ac2e1b082bbdd2df7693ce178f4d33749"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ac2e1b082bbdd2df7693ce178f4d33749">grid_parallel_for</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;local_grid, const DecompositionType &amp;decomposition, const EntityType &amp;entity_type, const WorkTag &amp;work_tag, const FunctorType &amp;functor)</td></tr>
<tr class="memdesc:ac2e1b082bbdd2df7693ce178f4d33749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a functor with a work tag in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local.  <br /></td></tr>
<tr class="separator:ac2e1b082bbdd2df7693ce178f4d33749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda357df1d146e578d38366e081b6624"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class ExecutionSpace , std::size_t NumSpace&gt; </td></tr>
<tr class="memitem:afda357df1d146e578d38366e081b6624"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#afda357df1d146e578d38366e081b6624">grid_parallel_for</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const Kokkos::Array&lt; <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt;, NumSpace &gt; &amp;index_spaces, const FunctorType &amp;functor)</td></tr>
<tr class="memdesc:afda357df1d146e578d38366e081b6624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a functor in parallel with a linear execution policy specified by the set of given index spaces. 4D specialization.  <br /></td></tr>
<tr class="separator:afda357df1d146e578d38366e081b6624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7824cb8412bd64ae4056c428f36c1c9c"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class ExecutionSpace , std::size_t NumSpace&gt; </td></tr>
<tr class="memitem:a7824cb8412bd64ae4056c428f36c1c9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a7824cb8412bd64ae4056c428f36c1c9c">grid_parallel_for</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const Kokkos::Array&lt; <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt;, NumSpace &gt; &amp;index_spaces, const FunctorType &amp;functor)</td></tr>
<tr class="memdesc:a7824cb8412bd64ae4056c428f36c1c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a functor in parallel with a linear execution policy specified by the set of given index spaces. 3D specialization.  <br /></td></tr>
<tr class="separator:a7824cb8412bd64ae4056c428f36c1c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45372f78f3e6880b22331ef24d113e6e"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class ExecutionSpace , std::size_t NumSpace&gt; </td></tr>
<tr class="memitem:a45372f78f3e6880b22331ef24d113e6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a45372f78f3e6880b22331ef24d113e6e">grid_parallel_for</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const Kokkos::Array&lt; <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt;, NumSpace &gt; &amp;index_spaces, const FunctorType &amp;functor)</td></tr>
<tr class="memdesc:a45372f78f3e6880b22331ef24d113e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a functor in parallel with a linear execution policy specified by the set of given index spaces. 2D specialization.  <br /></td></tr>
<tr class="separator:a45372f78f3e6880b22331ef24d113e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a58a3b10046140ae6a75b252dbade6"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class ExecutionSpace , long N, class ReduceType &gt; </td></tr>
<tr class="memitem:ac2a58a3b10046140ae6a75b252dbade6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ac2a58a3b10046140ae6a75b252dbade6">grid_parallel_reduce</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;index_space, const FunctorType &amp;functor, ReduceType &amp;reducer)</td></tr>
<tr class="memdesc:ac2a58a3b10046140ae6a75b252dbade6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a reduction functor in parallel with a multidimensional execution policy specified by the given index space.  <br /></td></tr>
<tr class="separator:ac2a58a3b10046140ae6a75b252dbade6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3578b89bdd7bd62f95ff985a77b8986"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class WorkTag , class ExecutionSpace , long N, class ReduceType &gt; </td></tr>
<tr class="memitem:ae3578b89bdd7bd62f95ff985a77b8986"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ae3578b89bdd7bd62f95ff985a77b8986">grid_parallel_reduce</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;index_space, const WorkTag &amp;work_tag, const FunctorType &amp;functor, ReduceType &amp;reducer)</td></tr>
<tr class="memdesc:ae3578b89bdd7bd62f95ff985a77b8986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a reduction functor with a work tag in parallel with a multidimensional execution policy specified by the given index space.  <br /></td></tr>
<tr class="separator:ae3578b89bdd7bd62f95ff985a77b8986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f60204e3f1448420140403bc39d3ea"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType , class ReduceType &gt; </td></tr>
<tr class="memitem:a14f60204e3f1448420140403bc39d3ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a14f60204e3f1448420140403bc39d3ea">grid_parallel_reduce</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;local_grid, const DecompositionType &amp;decomposition, const EntityType &amp;entity_type, const FunctorType &amp;functor, ReduceType &amp;reducer)</td></tr>
<tr class="memdesc:a14f60204e3f1448420140403bc39d3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a reduction functor in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local.  <br /></td></tr>
<tr class="separator:a14f60204e3f1448420140403bc39d3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10581196134700af84ad9a4b73f2ed4"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class WorkTag , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType , class ReduceType &gt; </td></tr>
<tr class="memitem:aa10581196134700af84ad9a4b73f2ed4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aa10581196134700af84ad9a4b73f2ed4">grid_parallel_reduce</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;local_grid, const DecompositionType &amp;decomposition, const EntityType &amp;entity_type, const WorkTag &amp;work_tag, const FunctorType &amp;functor, ReduceType &amp;reducer)</td></tr>
<tr class="memdesc:aa10581196134700af84ad9a4b73f2ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a reduction functor with a work tag in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local.  <br /></td></tr>
<tr class="separator:aa10581196134700af84ad9a4b73f2ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df563913201dda5b4483f9d076ea905"><td class="memTemplParams" colspan="2">template&lt;class LocalGridType , std::size_t NSD = LocalGridType::num_space_dim&gt; </td></tr>
<tr class="memitem:a7df563913201dda5b4483f9d076ea905"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; 3==NSD, std::vector&lt; int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a7df563913201dda5b4483f9d076ea905">getTopology</a> (const LocalGridType &amp;local_grid)</td></tr>
<tr class="memdesc:a7df563913201dda5b4483f9d076ea905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build neighbor topology of 27 nearest 3D neighbors. Some of the ranks in this list may be invalid.  <br /></td></tr>
<tr class="separator:a7df563913201dda5b4483f9d076ea905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bd1a63701dab16670dbdcca017f607"><td class="memTemplParams" colspan="2">template&lt;class LocalGridType , std::size_t NSD = LocalGridType::num_space_dim&gt; </td></tr>
<tr class="memitem:a65bd1a63701dab16670dbdcca017f607"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; 2==NSD, std::vector&lt; int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a65bd1a63701dab16670dbdcca017f607">getTopology</a> (const LocalGridType &amp;local_grid)</td></tr>
<tr class="memdesc:a65bd1a63701dab16670dbdcca017f607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build neighbor topology of 8 nearest 2D neighbors. Some of the ranks in this list may be invalid.  <br /></td></tr>
<tr class="separator:a65bd1a63701dab16670dbdcca017f607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583a9ee0c0e31310b730fa3ca3819721"><td class="memTemplParams" colspan="2">template&lt;class LocalGridType , class PositionSliceType &gt; </td></tr>
<tr class="memitem:a583a9ee0c0e31310b730fa3ca3819721"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a583a9ee0c0e31310b730fa3ca3819721">migrateCount</a> (const LocalGridType &amp;local_grid, const PositionSliceType &amp;positions, const int minimum_halo_width)</td></tr>
<tr class="memdesc:a583a9ee0c0e31310b730fa3ca3819721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for the number of particles that must be communicated.  <br /></td></tr>
<tr class="separator:a583a9ee0c0e31310b730fa3ca3819721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2557f422723e7377c0b4228da4c6c02"><td class="memTemplParams" colspan="2">template&lt;class LocalGridType , class PositionSliceType &gt; </td></tr>
<tr class="memitem:ac2557f422723e7377c0b4228da4c6c02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1Distributor.html">Cabana::Distributor</a>&lt; typename PositionSliceType::memory_space &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ac2557f422723e7377c0b4228da4c6c02">createParticleGridDistributor</a> (const LocalGridType &amp;local_grid, PositionSliceType &amp;positions)</td></tr>
<tr class="memdesc:ac2557f422723e7377c0b4228da4c6c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which data should be migrated from one uniquely-owned decomposition to another uniquely-owned decomposition, using bounds of a <a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> grid and taking periodic boundaries into account.  <br /></td></tr>
<tr class="separator:ac2557f422723e7377c0b4228da4c6c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4371257b756699167df4544e4f2de13"><td class="memTemplParams" colspan="2">template&lt;class LocalGridType , class ParticlePositions , class ParticleContainer &gt; </td></tr>
<tr class="memitem:af4371257b756699167df4544e4f2de13"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#af4371257b756699167df4544e4f2de13">particleGridMigrate</a> (const LocalGridType &amp;local_grid, const ParticlePositions &amp;positions, ParticleContainer &amp;particles, const int min_halo_width, const bool force_migrate=false)</td></tr>
<tr class="memdesc:af4371257b756699167df4544e4f2de13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrate data from one uniquely-owned decomposition to another uniquely-owned decomposition, using the bounds and periodic boundaries of a <a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> grid to determine which particles should be moved. In-place variant.  <br /></td></tr>
<tr class="separator:af4371257b756699167df4544e4f2de13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb928c073163bff90d4ca8a7d460fe18"><td class="memTemplParams" colspan="2">template&lt;class LocalGridType , class ParticlePositions , class ParticleContainer &gt; </td></tr>
<tr class="memitem:adb928c073163bff90d4ca8a7d460fe18"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#adb928c073163bff90d4ca8a7d460fe18">particleGridMigrate</a> (const LocalGridType &amp;local_grid, const ParticlePositions &amp;positions, const ParticleContainer &amp;src_particles, ParticleContainer &amp;dst_particles, const int min_halo_width, const bool force_migrate=false)</td></tr>
<tr class="memdesc:adb928c073163bff90d4ca8a7d460fe18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrate data from one uniquely-owned decomposition to another uniquely-owned decomposition, using the bounds and periodic boundaries of a <a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> grid to determine which particles should be moved. Separate AoSoA variant.  <br /></td></tr>
<tr class="separator:adb928c073163bff90d4ca8a7d460fe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfb7e5d897db7fcc9dd74a9de76aeac"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class InitFunctor , class ParticleListType , class LocalGridType &gt; </td></tr>
<tr class="memitem:afdfb7e5d897db7fcc9dd74a9de76aeac"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#afdfb7e5d897db7fcc9dd74a9de76aeac">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">Cabana::InitRandom</a>, const ExecutionSpace &amp;exec_space, const InitFunctor &amp;create_functor, ParticleListType &amp;particle_list, const int particles_per_cell, LocalGridType &amp;local_grid, const std::size_t previous_num_particles=0, const bool shrink_to_fit=true, const uint64_t seed=123456, typename std::enable_if&lt; <a class="el" href="structCajita_1_1is__particle__list.html">Cajita::is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *=0)</td></tr>
<tr class="memdesc:afdfb7e5d897db7fcc9dd74a9de76aeac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a random number of particles in each cell given an initialization functor.  <br /></td></tr>
<tr class="separator:afdfb7e5d897db7fcc9dd74a9de76aeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407e798cff4a8f57514231c06eb6ffd2"><td class="memTemplParams" colspan="2">template&lt;class InitFunctor , class ParticleListType , class LocalGridType &gt; </td></tr>
<tr class="memitem:a407e798cff4a8f57514231c06eb6ffd2"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a407e798cff4a8f57514231c06eb6ffd2">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">Cabana::InitRandom</a> tag, const InitFunctor &amp;create_functor, ParticleListType &amp;particle_list, const int particles_per_cell, LocalGridType &amp;local_grid, const std::size_t previous_num_particles=0, const bool shrink_to_fit=true, const uint64_t seed=123456, typename std::enable_if&lt; <a class="el" href="structCajita_1_1is__particle__list.html">Cajita::is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *=0)</td></tr>
<tr class="memdesc:a407e798cff4a8f57514231c06eb6ffd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize random particles per cell given an initialization functor.  <br /></td></tr>
<tr class="separator:a407e798cff4a8f57514231c06eb6ffd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324858542047fb724ebd05aaf16fee44"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class PositionType , class LocalGridType &gt; </td></tr>
<tr class="memitem:a324858542047fb724ebd05aaf16fee44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a324858542047fb724ebd05aaf16fee44">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">Cabana::InitRandom</a>, const ExecutionSpace &amp;exec_space, PositionType &amp;positions, const int particles_per_cell, LocalGridType &amp;local_grid, const std::size_t previous_num_particles=0, const uint64_t seed=123456, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">Cabana::is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a324858542047fb724ebd05aaf16fee44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a random number of particles in each cell.  <br /></td></tr>
<tr class="separator:a324858542047fb724ebd05aaf16fee44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430493c1c7cf364045b12c3a073ede0d"><td class="memTemplParams" colspan="2">template&lt;class PositionType , class LocalGridType &gt; </td></tr>
<tr class="memitem:a430493c1c7cf364045b12c3a073ede0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a430493c1c7cf364045b12c3a073ede0d">createParticles</a> (<a class="el" href="structCabana_1_1InitRandom.html">Cabana::InitRandom</a> tag, PositionType &amp;positions, const int particles_per_cell, LocalGridType &amp;local_grid, const std::size_t previous_num_particles=0, const uint64_t seed=123456, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">Cabana::is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:a430493c1c7cf364045b12c3a073ede0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a random number of particles in each cell.  <br /></td></tr>
<tr class="separator:a430493c1c7cf364045b12c3a073ede0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdc6ecfb7f3dfb8fbac5699856b8be2"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class InitFunctor , class ParticleListType , class LocalGridType &gt; </td></tr>
<tr class="memitem:a2fdc6ecfb7f3dfb8fbac5699856b8be2"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a2fdc6ecfb7f3dfb8fbac5699856b8be2">createParticles</a> (<a class="el" href="structCabana_1_1InitUniform.html">Cabana::InitUniform</a>, const ExecutionSpace &amp;exec_space, const InitFunctor &amp;create_functor, ParticleListType &amp;particle_list, const int particles_per_cell_dim, LocalGridType &amp;local_grid, const std::size_t previous_num_particles=0, const bool shrink_to_fit=true, typename std::enable_if&lt; <a class="el" href="structCajita_1_1is__particle__list.html">Cajita::is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *=0)</td></tr>
<tr class="memdesc:a2fdc6ecfb7f3dfb8fbac5699856b8be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize uniform particles per cell given an initialization functor.  <br /></td></tr>
<tr class="separator:a2fdc6ecfb7f3dfb8fbac5699856b8be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d1de983b9c41c01e317d560dbc5ef6"><td class="memTemplParams" colspan="2">template&lt;class InitFunctor , class ParticleListType , class LocalGridType &gt; </td></tr>
<tr class="memitem:a56d1de983b9c41c01e317d560dbc5ef6"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a56d1de983b9c41c01e317d560dbc5ef6">createParticles</a> (<a class="el" href="structCabana_1_1InitUniform.html">Cabana::InitUniform</a> tag, const InitFunctor &amp;create_functor, ParticleListType &amp;particle_list, const int particles_per_cell_dim, LocalGridType &amp;local_grid, const std::size_t previous_num_particles=0, const bool shrink_to_fit=true, typename std::enable_if&lt; <a class="el" href="structCajita_1_1is__particle__list.html">Cajita::is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *=0)</td></tr>
<tr class="memdesc:a56d1de983b9c41c01e317d560dbc5ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize uniform particles per cell given an initialization functor.  <br /></td></tr>
<tr class="separator:a56d1de983b9c41c01e317d560dbc5ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07b06c056bbbcb534ee8db9e8f6b641"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class PositionType , class LocalGridType &gt; </td></tr>
<tr class="memitem:af07b06c056bbbcb534ee8db9e8f6b641"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#af07b06c056bbbcb534ee8db9e8f6b641">createParticles</a> (<a class="el" href="structCabana_1_1InitUniform.html">Cabana::InitUniform</a>, const ExecutionSpace &amp;exec_space, PositionType &amp;positions, const int particles_per_cell_dim, LocalGridType &amp;local_grid, const std::size_t previous_num_particles=0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">Cabana::is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:af07b06c056bbbcb534ee8db9e8f6b641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a uniform number of particles in each cell.  <br /></td></tr>
<tr class="separator:af07b06c056bbbcb534ee8db9e8f6b641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3bea6775d466505131d91596094875"><td class="memTemplParams" colspan="2">template&lt;class PositionType , class LocalGridType &gt; </td></tr>
<tr class="memitem:aba3bea6775d466505131d91596094875"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aba3bea6775d466505131d91596094875">createParticles</a> (<a class="el" href="structCabana_1_1InitUniform.html">Cabana::InitUniform</a> tag, PositionType &amp;positions, const int particles_per_cell_dim, LocalGridType &amp;local_grid, const std::size_t previous_num_particles=0, typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">Cabana::is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *=0)</td></tr>
<tr class="memdesc:aba3bea6775d466505131d91596094875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a uniform number of particles in each cell.  <br /></td></tr>
<tr class="separator:aba3bea6775d466505131d91596094875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe00d64b936b78a9bdcebf8499486202"><td class="memTemplParams" colspan="2">template&lt;class MemorySpace , class... FieldTags&gt; </td></tr>
<tr class="memitem:abe00d64b936b78a9bdcebf8499486202"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#abe00d64b936b78a9bdcebf8499486202">createParticleList</a> (const std::string &amp;label, <a class="el" href="structCabana_1_1ParticleTraits.html">Cabana::ParticleTraits</a>&lt; FieldTags... &gt;)</td></tr>
<tr class="memdesc:abe00d64b936b78a9bdcebf8499486202"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCajita_1_1ParticleList.html" title="List of particle fields stored in AoSoA with associated Cajita mesh.">ParticleList</a> creation function.  <br /></td></tr>
<tr class="separator:abe00d64b936b78a9bdcebf8499486202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6f0025c053a6112442f5be3d7375b1"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class MemorySpace , class EntityType , class MeshType &gt; </td></tr>
<tr class="memitem:afb6f0025c053a6112442f5be3d7375b1"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1ReferenceConjugateGradient.html">ReferenceConjugateGradient</a>&lt; Scalar, EntityType, MeshType, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#afb6f0025c053a6112442f5be3d7375b1">createReferenceConjugateGradient</a> (const <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &amp;layout)</td></tr>
<tr class="memdesc:afb6f0025c053a6112442f5be3d7375b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for reference structured preconditioned block conjugate gradient.  <br /></td></tr>
<tr class="separator:afb6f0025c053a6112442f5be3d7375b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d031b487f27e16a7b6bcc0c3e74c38d"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:a3d031b487f27e16a7b6bcc0c3e74c38d"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION constexpr Integer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a3d031b487f27e16a7b6bcc0c3e74c38d">bitLength</a> (Integer input_int) noexcept</td></tr>
<tr class="memdesc:a3d031b487f27e16a7b6bcc0c3e74c38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Host/Device) Compute the least bit number/length needed to represent the given input integer  <br /></td></tr>
<tr class="separator:a3d031b487f27e16a7b6bcc0c3e74c38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc377ceced244c95c930331c4197420"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:abcc377ceced244c95c930331c4197420"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION constexpr Integer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#abcc377ceced244c95c930331c4197420">bitCount</a> (Integer input_int) noexcept</td></tr>
<tr class="memdesc:abcc377ceced244c95c930331c4197420"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Host/Device) Compute the lease bit number needed to index input integer  <br /></td></tr>
<tr class="separator:abcc377ceced244c95c930331c4197420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bdeb3e5e90ec8bba2ef54b5b6eedf9"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:af2bdeb3e5e90ec8bba2ef54b5b6eedf9"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION constexpr Integer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#af2bdeb3e5e90ec8bba2ef54b5b6eedf9">binaryReverse</a> (Integer input_int, char loc=sizeof(Integer) *8 - 1)</td></tr>
<tr class="memdesc:af2bdeb3e5e90ec8bba2ef54b5b6eedf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Host/Device) Given a integer, reverse the corresponding binary string, return the resulting integer.  <br /></td></tr>
<tr class="separator:af2bdeb3e5e90ec8bba2ef54b5b6eedf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ef69b7e5e28ef90030f9ef2bcf5ce4"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:aa3ef69b7e5e28ef90030f9ef2bcf5ce4"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION constexpr unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aa3ef69b7e5e28ef90030f9ef2bcf5ce4">countLeadingZeros</a> (Integer input_int)</td></tr>
<tr class="memdesc:aa3ef69b7e5e28ef90030f9ef2bcf5ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Host/Device) Count the leading zeros in the corresponding binary string of the input integer  <br /></td></tr>
<tr class="separator:aa3ef69b7e5e28ef90030f9ef2bcf5ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb6af7bef9ec846937ef2b009be9e8f"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a2eb6af7bef9ec846937ef2b009be9e8f">bitPack</a> (const uint64_t mask, const uint64_t data)</td></tr>
<tr class="memdesc:a2eb6af7bef9ec846937ef2b009be9e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Host/Device) Pack up the data bits where the corresponding bit of the mask is 1  <br /></td></tr>
<tr class="separator:a2eb6af7bef9ec846937ef2b009be9e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abcb064c31df940d8f0eb78b83dfff8"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a7abcb064c31df940d8f0eb78b83dfff8">bitSpread</a> (const uint64_t mask, const int data)</td></tr>
<tr class="memdesc:a7abcb064c31df940d8f0eb78b83dfff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Host/Device) Spread out the data bits where the corresponding bit of the mask is 1  <br /></td></tr>
<tr class="separator:a7abcb064c31df940d8f0eb78b83dfff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b44fb276ae635458abbea70f92f9d42"><td class="memTemplParams" colspan="2">template&lt;typename MemorySpace , class Scalar , unsigned long long CellPerTileDim = 4, <a class="el" href="namespaceCajita.html#a2ec822f40e278e94dbe22325c2b4c824">HashTypes</a> Hash = HashTypes::Naive, typename Key  = uint64_t, typename Value  = uint64_t&gt; </td></tr>
<tr class="memitem:a0b44fb276ae635458abbea70f92f9d42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCajita_1_1SparseMap.html">SparseMap</a>&lt; MemorySpace, CellPerTileDim, Hash, Key, Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a0b44fb276ae635458abbea70f92f9d42">createSparseMap</a> (const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar &gt; &gt; &gt; &amp;global_mesh, int pre_alloc_size)</td></tr>
<tr class="memdesc:a0b44fb276ae635458abbea70f92f9d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for <a class="el" href="classCajita_1_1SparseMap.html" title="Sparse index space, with a hierarchical structure (cell-&gt;tile-&gt;block)">SparseMap</a> from GlobalMesh&lt;SparseMesh&gt;  <br /></td></tr>
<tr class="separator:a0b44fb276ae635458abbea70f92f9d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d407b80adf923a5368d8ec5c69b3c0d"><td class="memTemplParams" colspan="2"><a id="a9d407b80adf923a5368d8ec5c69b3c0d" name="a9d407b80adf923a5368d8ec5c69b3c0d"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:a9d407b80adf923a5368d8ec5c69b3c0d"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt; <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_physical_cell_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setSplineData</b> (<a class="el" href="structCajita_1_1SplinePhysicalCellSize.html">SplinePhysicalCellSize</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;data, const int d, const Scalar dx)</td></tr>
<tr class="memdesc:a9d407b80adf923a5368d8ec5c69b3c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign physical cell size to the spline data. <br /></td></tr>
<tr class="separator:a9d407b80adf923a5368d8ec5c69b3c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c21144a228457dedbe72ff345e840cf"><td class="memTemplParams" colspan="2"><a id="a8c21144a228457dedbe72ff345e840cf" name="a8c21144a228457dedbe72ff345e840cf"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:a8c21144a228457dedbe72ff345e840cf"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt;!<a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_physical_cell_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setSplineData</b> (<a class="el" href="structCajita_1_1SplinePhysicalCellSize.html">SplinePhysicalCellSize</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;, const int, const Scalar)</td></tr>
<tr class="memdesc:a8c21144a228457dedbe72ff345e840cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical cell size spline data template helper. <br /></td></tr>
<tr class="separator:a8c21144a228457dedbe72ff345e840cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc49e2db588e26d273aea04a1921b62"><td class="memTemplParams" colspan="2"><a id="abdc49e2db588e26d273aea04a1921b62" name="abdc49e2db588e26d273aea04a1921b62"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:abdc49e2db588e26d273aea04a1921b62"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt; <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_logical_position &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setSplineData</b> (<a class="el" href="structCajita_1_1SplineLogicalPosition.html">SplineLogicalPosition</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;data, const int d, const Scalar x)</td></tr>
<tr class="memdesc:abdc49e2db588e26d273aea04a1921b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign logical position to the spline data. <br /></td></tr>
<tr class="separator:abdc49e2db588e26d273aea04a1921b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d7faec059175d6a08293b59ab551f2"><td class="memTemplParams" colspan="2"><a id="a91d7faec059175d6a08293b59ab551f2" name="a91d7faec059175d6a08293b59ab551f2"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:a91d7faec059175d6a08293b59ab551f2"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt;!<a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_logical_position &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setSplineData</b> (<a class="el" href="structCajita_1_1SplineLogicalPosition.html">SplineLogicalPosition</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;, const int, const Scalar)</td></tr>
<tr class="memdesc:a91d7faec059175d6a08293b59ab551f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical position spline data template helper. <br /></td></tr>
<tr class="separator:a91d7faec059175d6a08293b59ab551f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace842b1ce899a6d25bd0078944c7525"><td class="memTemplParams" colspan="2"><a id="aace842b1ce899a6d25bd0078944c7525" name="aace842b1ce899a6d25bd0078944c7525"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:aace842b1ce899a6d25bd0078944c7525"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt; <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_weight_values &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setSplineData</b> (<a class="el" href="structCajita_1_1SplineWeightValues.html">SplineWeightValues</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;data, const Scalar x[NumSpaceDim])</td></tr>
<tr class="memdesc:aace842b1ce899a6d25bd0078944c7525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign weight values to the spline data. <br /></td></tr>
<tr class="separator:aace842b1ce899a6d25bd0078944c7525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658858f7d50f187cccbd7737cdb679e9"><td class="memTemplParams" colspan="2"><a id="a658858f7d50f187cccbd7737cdb679e9" name="a658858f7d50f187cccbd7737cdb679e9"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:a658858f7d50f187cccbd7737cdb679e9"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt;!<a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_weight_values &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setSplineData</b> (<a class="el" href="structCajita_1_1SplineWeightValues.html">SplineWeightValues</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;, const Scalar[NumSpaceDim])</td></tr>
<tr class="memdesc:a658858f7d50f187cccbd7737cdb679e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weight value spline data template helper. <br /></td></tr>
<tr class="separator:a658858f7d50f187cccbd7737cdb679e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32031cb5843b9534ba7b327744b40a7"><td class="memTemplParams" colspan="2"><a id="aa32031cb5843b9534ba7b327744b40a7" name="aa32031cb5843b9534ba7b327744b40a7"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:aa32031cb5843b9534ba7b327744b40a7"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt; <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_weight_physical_gradients &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setSplineData</b> (<a class="el" href="structCajita_1_1SplineWeightPhysicalGradients.html">SplineWeightPhysicalGradients</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;data, const Scalar x[NumSpaceDim], const Scalar rdx[NumSpaceDim])</td></tr>
<tr class="memdesc:aa32031cb5843b9534ba7b327744b40a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign weight physical gradients to the spline data. <br /></td></tr>
<tr class="separator:aa32031cb5843b9534ba7b327744b40a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4164ac64539b2eeb68e09e7f37a158ca"><td class="memTemplParams" colspan="2"><a id="a4164ac64539b2eeb68e09e7f37a158ca" name="a4164ac64539b2eeb68e09e7f37a158ca"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:a4164ac64539b2eeb68e09e7f37a158ca"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt;!<a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_weight_physical_gradients &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setSplineData</b> (<a class="el" href="structCajita_1_1SplineWeightPhysicalGradients.html">SplineWeightPhysicalGradients</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;, const Scalar[NumSpaceDim], const Scalar[NumSpaceDim])</td></tr>
<tr class="memdesc:a4164ac64539b2eeb68e09e7f37a158ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weight physical gradients spline data template helper. <br /></td></tr>
<tr class="separator:a4164ac64539b2eeb68e09e7f37a158ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa080c258d122a49321289c3b214eed6b"><td class="memTemplParams" colspan="2"><a id="aa080c258d122a49321289c3b214eed6b" name="aa080c258d122a49321289c3b214eed6b"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:aa080c258d122a49321289c3b214eed6b"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt; <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_physical_distance &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setSplineData</b> (<a class="el" href="structCajita_1_1SplinePhysicalDistance.html">SplinePhysicalDistance</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;data, const Scalar low_x[NumSpaceDim], const Scalar p[NumSpaceDim], const Scalar dx[NumSpaceDim])</td></tr>
<tr class="memdesc:aa080c258d122a49321289c3b214eed6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign physical distance to the spline data. <br /></td></tr>
<tr class="separator:aa080c258d122a49321289c3b214eed6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f778bd88235d08fff4108e3fa76a70"><td class="memTemplParams" colspan="2"><a id="a39f778bd88235d08fff4108e3fa76a70" name="a39f778bd88235d08fff4108e3fa76a70"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:a39f778bd88235d08fff4108e3fa76a70"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt;!<a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_physical_distance &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setSplineData</b> (<a class="el" href="structCajita_1_1SplinePhysicalDistance.html">SplinePhysicalDistance</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;, const Scalar[NumSpaceDim], const Scalar[NumSpaceDim], const Scalar[NumSpaceDim])</td></tr>
<tr class="memdesc:a39f778bd88235d08fff4108e3fa76a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical distance spline data template helper. <br /></td></tr>
<tr class="separator:a39f778bd88235d08fff4108e3fa76a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24112fb41b1a433bc94d8be2c00751c5"><td class="memTemplParams" colspan="2"><a id="a24112fb41b1a433bc94d8be2c00751c5" name="a24112fb41b1a433bc94d8be2c00751c5"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class MemorySpace , class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:a24112fb41b1a433bc94d8be2c00751c5"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>evaluateSpline</b> (const <a class="el" href="classCajita_1_1LocalMesh.html">LocalMesh</a>&lt; MemorySpace, <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &amp;local_mesh, const Scalar p[NumSpaceDim], <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;data)</td></tr>
<tr class="memdesc:a24112fb41b1a433bc94d8be2c00751c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate spline data at a point in a uniform mesh. <br /></td></tr>
<tr class="separator:a24112fb41b1a433bc94d8be2c00751c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a>: grid and particle-grid data structures and algorithms. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae72bb9627157c6ffd385b4ae8b831d20" name="ae72bb9627157c6ffd385b4ae8b831d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72bb9627157c6ffd385b4ae8b831d20">&#9670;&#160;</a></span>appendDimension() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N+1 &gt; Cajita::appendDimension </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an N-dimensional index space append an additional dimension with the given range. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCajita_1_1IndexSpace.html" title="Structured index space.">IndexSpace</a> with dimension N+1. </dd></dl>

</div>
</div>
<a id="a0652ddec74a14c5efdd4178f98cf0e38" name="a0652ddec74a14c5efdd4178f98cf0e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0652ddec74a14c5efdd4178f98cf0e38">&#9670;&#160;</a></span>appendDimension() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N+1 &gt; Cajita::appendDimension </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an N-dimensional index space append an additional dimension with the given size. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCajita_1_1IndexSpace.html" title="Structured index space.">IndexSpace</a> with dimension N+1. </dd></dl>

</div>
</div>
<a id="af2bdeb3e5e90ec8bba2ef54b5b6eedf9" name="af2bdeb3e5e90ec8bba2ef54b5b6eedf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bdeb3e5e90ec8bba2ef54b5b6eedf9">&#9670;&#160;</a></span>binaryReverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION constexpr Integer Cajita::binaryReverse </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>input_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>loc</em> = <code>sizeof(&#160;Integer&#160;)&#160;*&#160;8&#160;-&#160;1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Host/Device) Given a integer, reverse the corresponding binary string, return the resulting integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_int</td><td>integer that is going to be evaluated </td></tr>
    <tr><td class="paramname">loc</td><td>location for next round reverse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcc377ceced244c95c930331c4197420" name="abcc377ceced244c95c930331c4197420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc377ceced244c95c930331c4197420">&#9670;&#160;</a></span>bitCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION constexpr Integer Cajita::bitCount </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>input_int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Host/Device) Compute the lease bit number needed to index input integer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_int</td><td>integer that is going to be evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d031b487f27e16a7b6bcc0c3e74c38d" name="a3d031b487f27e16a7b6bcc0c3e74c38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d031b487f27e16a7b6bcc0c3e74c38d">&#9670;&#160;</a></span>bitLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION constexpr Integer Cajita::bitLength </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>input_int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Host/Device) Compute the least bit number/length needed to represent the given input integer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_int</td><td>integer that is going to be evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2eb6af7bef9ec846937ef2b009be9e8f" name="a2eb6af7bef9ec846937ef2b009be9e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb6af7bef9ec846937ef2b009be9e8f">&#9670;&#160;</a></span>bitPack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION constexpr int Cajita::bitPack </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Host/Device) Pack up the data bits where the corresponding bit of the mask is 1 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>mask value </td></tr>
    <tr><td class="paramname">data</td><td>integer to be packed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7abcb064c31df940d8f0eb78b83dfff8" name="a7abcb064c31df940d8f0eb78b83dfff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abcb064c31df940d8f0eb78b83dfff8">&#9670;&#160;</a></span>bitSpread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION constexpr uint64_t Cajita::bitSpread </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Host/Device) Spread out the data bits where the corresponding bit of the mask is 1 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>mask value </td></tr>
    <tr><td class="paramname">data</td><td>integer to be spreaded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3ef69b7e5e28ef90030f9ef2bcf5ce4" name="aa3ef69b7e5e28ef90030f9ef2bcf5ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ef69b7e5e28ef90030f9ef2bcf5ce4">&#9670;&#160;</a></span>countLeadingZeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION constexpr unsigned Cajita::countLeadingZeros </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>input_int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Host/Device) Count the leading zeros in the corresponding binary string of the input integer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_int</td><td>integer that is going to be evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a66aaed41884fd04d9d7b1ab464e5cd" name="a4a66aaed41884fd04d9d7b1ab464e5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a66aaed41884fd04d9d7b1ab464e5cd">&#9670;&#160;</a></span>createArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params, class EntityType , class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt; &gt; Cajita::createArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an array with the given array layout. Views are constructed over the ghosted index space of the layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>A label for the view. </td></tr>
    <tr><td class="paramname">layout</td><td>The array layout over which to construct the view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to an <a class="el" href="classCajita_1_1Array.html" title="Array of field data on the local mesh.">Array</a>. </dd></dl>

</div>
</div>
<a id="a33ad222eb8b2ed544af3ce40e9fe7b36" name="a33ad222eb8b2ed544af3ce40e9fe7b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ad222eb8b2ed544af3ce40e9fe7b36">&#9670;&#160;</a></span>createArrayLayout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EntityType , class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &gt; Cajita::createArrayLayout </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt; MeshType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>halo_cell_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dofs_per_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EntityType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an array layout over the entities of a grid given local grid parameters. An intermediate local grid will be created and assigned to the layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_grid</td><td>The local grid over which to create the layout. </td></tr>
    <tr><td class="paramname">halo_cell_width</td><td>The number of halo cells surrounding the locally owned cells. </td></tr>
    <tr><td class="paramname">dofs_per_entity</td><td>The number of degrees-of-freedom per grid entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to an <a class="el" href="classCajita_1_1ArrayLayout.html" title="Entity layout for array data on the local mesh.">ArrayLayout</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>EntityType The entity: <a class="el" href="structCajita_1_1Cell.html" title="Mesh cell tag.">Cell</a>, <a class="el" href="structCajita_1_1Node.html" title="Mesh node tag.">Node</a>, <a class="el" href="structCajita_1_1Face.html" title="Mesh face tag.">Face</a>, or <a class="el" href="structCajita_1_1Edge.html" title="Mesh edge tag.">Edge</a> </dd></dl>

</div>
</div>
<a id="adefcb7bda05af73d9acd1b8c4d4e6b00" name="adefcb7bda05af73d9acd1b8c4d4e6b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefcb7bda05af73d9acd1b8c4d4e6b00">&#9670;&#160;</a></span>createArrayLayout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EntityType , class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &gt; Cajita::createArrayLayout </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dofs_per_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EntityType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an array layout over the entities of a local grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_grid</td><td>The local grid over which to create the layout. </td></tr>
    <tr><td class="paramname">dofs_per_entity</td><td>The number of degrees-of-freedom per grid entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to an <a class="el" href="classCajita_1_1ArrayLayout.html" title="Entity layout for array data on the local mesh.">ArrayLayout</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>EntityType The entity: <a class="el" href="structCajita_1_1Cell.html" title="Mesh cell tag.">Cell</a>, <a class="el" href="structCajita_1_1Node.html" title="Mesh node tag.">Node</a>, <a class="el" href="structCajita_1_1Face.html" title="Mesh face tag.">Face</a>, or <a class="el" href="structCajita_1_1Edge.html" title="Mesh edge tag.">Edge</a> </dd></dl>

</div>
</div>
<a id="a0fdf1c2aa21fee549c55f4610e9ac5b8" name="a0fdf1c2aa21fee549c55f4610e9ac5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdf1c2aa21fee549c55f4610e9ac5b8">&#9670;&#160;</a></span>createExecutionPolicy() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::RangePolicy&lt; ExecutionSpace &gt; Cajita::createExecutionPolicy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a multi-dimensional execution policy over an index space. </p>
<dl class="section return"><dt>Returns</dt><dd>Kokkos::RangePolicy Rank-1 specialization. </dd></dl>

</div>
</div>
<a id="ab7ff824e39e183fe89d3edae6acfae2d" name="ab7ff824e39e183fe89d3edae6acfae2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ff824e39e183fe89d3edae6acfae2d">&#9670;&#160;</a></span>createExecutionPolicy() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class WorkTag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::RangePolicy&lt; ExecutionSpace, WorkTag &gt; Cajita::createExecutionPolicy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorkTag &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a multi-dimensional execution policy over an index space. </p>
<dl class="section return"><dt>Returns</dt><dd>Kokkos::RangePolicy</dd></dl>
<p>Rank-1 specialization with a work tag. </p>

</div>
</div>
<a id="a2ebdf82160fd53a757e368eb94c65246" name="a2ebdf82160fd53a757e368eb94c65246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebdf82160fd53a757e368eb94c65246">&#9670;&#160;</a></span>createExecutionPolicy() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexSpace_t , class ExecutionSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::MDRangePolicy&lt; ExecutionSpace, Kokkos::Rank&lt; IndexSpace_t::Rank &gt; &gt; Cajita::createExecutionPolicy </td>
          <td>(</td>
          <td class="paramtype">const IndexSpace_t &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a multi-dimensional execution policy over an index space. </p>
<dl class="section return"><dt>Returns</dt><dd>Kokkos::MDRangePolicy </dd></dl>

</div>
</div>
<a id="aeacc6c22c6ce7bb70ff0d9f78b9797b5" name="aeacc6c22c6ce7bb70ff0d9f78b9797b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacc6c22c6ce7bb70ff0d9f78b9797b5">&#9670;&#160;</a></span>createExecutionPolicy() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexSpace_t , class ExecutionSpace , class WorkTag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::MDRangePolicy&lt; ExecutionSpace, WorkTag, Kokkos::Rank&lt; IndexSpace_t::Rank &gt; &gt; Cajita::createExecutionPolicy </td>
          <td>(</td>
          <td class="paramtype">const IndexSpace_t &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorkTag &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a multi-dimensional execution policy over an index space with a work tag. </p>
<dl class="section return"><dt>Returns</dt><dd>Kokkos::MDRangePolicy </dd></dl>

</div>
</div>
<a id="aa4e950c1c2bb6e812a513515c342940e" name="aa4e950c1c2bb6e812a513515c342940e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e950c1c2bb6e812a513515c342940e">&#9670;&#160;</a></span>createGlobalGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt; MeshType &gt; &gt; Cajita::createGlobalGrid </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; MeshType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; bool, MeshType::num_space_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>periodic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1BlockPartitioner.html">BlockPartitioner</a>&lt; MeshType::num_space_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The communicator over which to define the grid. </td></tr>
    <tr><td class="paramname">global_mesh</td><td>The global mesh data. </td></tr>
    <tr><td class="paramname">periodic</td><td>Whether each logical dimension is periodic. </td></tr>
    <tr><td class="paramname">partitioner</td><td>The grid partitioner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <a class="el" href="classCajita_1_1GlobalGrid.html" title="Global logical grid.">GlobalGrid</a>. </dd></dl>

</div>
</div>
<a id="aecb8877728a72318f7c6384446f700fb" name="aecb8877728a72318f7c6384446f700fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb8877728a72318f7c6384446f700fb">&#9670;&#160;</a></span>createGlobalGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt; Cajita::createGlobalGrid </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; bool, <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt;::num_space_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>periodic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1BlockPartitioner.html">BlockPartitioner</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt;::num_space_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sparse global grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The communicator over which to define the grid. </td></tr>
    <tr><td class="paramname">global_mesh</td><td>The global mesh data. </td></tr>
    <tr><td class="paramname">periodic</td><td>Whether each logical dimension is periodic. </td></tr>
    <tr><td class="paramname">partitioner</td><td>The grid partitioner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <a class="el" href="classCajita_1_1GlobalGrid.html" title="Global logical grid.">GlobalGrid</a>. </dd></dl>

</div>
</div>
<a id="a342119f5d5b011c689cc474e16cc70e5" name="a342119f5d5b011c689cc474e16cc70e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342119f5d5b011c689cc474e16cc70e5">&#9670;&#160;</a></span>createHalo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class Pattern , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cajita::createHalo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pattern &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a halo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to build the halo for. </td></tr>
    <tr><td class="paramname">pattern</td><td>The pattern to build the halo from. </td></tr>
    <tr><td class="paramname">width</td><td>Must be less than or equal to the width of the array halo. Defaults to the width of the array halo. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The scalar type and memory space are specified via the input arrays so the proper buffers may be allocated. This means a halo constructed via this method is only compatible with arrays that have the same scalar and device type as the input array. </dd></dl>

</div>
</div>
<a id="abb8e3f33f12e80ce359f1d4840ee641c" name="abb8e3f33f12e80ce359f1d4840ee641c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8e3f33f12e80ce359f1d4840ee641c">&#9670;&#160;</a></span>createHalo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class MemorySpace , class EntityType , class MeshType , class Pattern &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cajita::createHalo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pattern &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a halo with a layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layout</td><td>The array layout to build the halo for. </td></tr>
    <tr><td class="paramname">pattern</td><td>The pattern to build the halo from. </td></tr>
    <tr><td class="paramname">width</td><td>Must be less than or equal to the width of the array halo. Defaults to the width of the array halo. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The scalar type and memory space must be specified so the proper buffers may be allocated. This means a halo constructed via this method is only compatible with arrays that have the same scalar and memory space. </dd></dl>

</div>
</div>
<a id="a047ee0472b03e9ef8798fc34f110c28d" name="a047ee0472b03e9ef8798fc34f110c28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047ee0472b03e9ef8798fc34f110c28d">&#9670;&#160;</a></span>createHalo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pattern , class... ArrayTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cajita::createHalo </td>
          <td>(</td>
          <td class="paramtype">const Pattern &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypes &amp;...&#160;</td>
          <td class="paramname"><em>arrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCajita_1_1Halo.html">Halo</a> creation function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern to build the halo from. </td></tr>
    <tr><td class="paramname">width</td><td>Must be less than or equal to the width of the array halo. </td></tr>
    <tr><td class="paramname">arrays</td><td>The arrays over which to build the halo. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <a class="el" href="classCajita_1_1Halo.html">Halo</a>. </dd></dl>

</div>
</div>
<a id="a5c393ffd77e2c1f52c016967d4f29b36" name="a5c393ffd77e2c1f52c016967d4f29b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c393ffd77e2c1f52c016967d4f29b36">&#9670;&#160;</a></span>createHypreSemiStructuredSolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreSemiStructuredSolver.html">HypreSemiStructuredSolver</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt; Cajita::createHypreSemiStructuredSolver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayLayout_t &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_preconditioner</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_vars</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a HYPRE semi-structured solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver_type</td><td>Solver name. </td></tr>
    <tr><td class="paramname">layout</td><td>The <a class="el" href="classCajita_1_1ArrayLayout.html" title="Entity layout for array data on the local mesh.">ArrayLayout</a> defining the vector space of the solver. </td></tr>
    <tr><td class="paramname">is_preconditioner</td><td>Use as a preconditioner. </td></tr>
    <tr><td class="paramname">n_vars</td><td>Number of variables in the solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a245f4b046906b9df567d04ec0b3134c7" name="a245f4b046906b9df567d04ec0b3134c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245f4b046906b9df567d04ec0b3134c7">&#9670;&#160;</a></span>createHypreStructBiCGSTAB()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructBiCGSTAB.html">HypreStructBiCGSTAB</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt; Cajita::createHypreStructBiCGSTAB </td>
          <td>(</td>
          <td class="paramtype">const ArrayLayout_t &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_preconditioner</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a HYPRE BiCGSTAB structured solver. </p><dl class="section return"><dt>Returns</dt><dd>Shared pointer to <a class="el" href="classCajita_1_1HypreStructBiCGSTAB.html" title="BiCGSTAB solver.">HypreStructBiCGSTAB</a>. </dd></dl>

</div>
</div>
<a id="a5181ce534138c85176950c6bff1d1a04" name="a5181ce534138c85176950c6bff1d1a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5181ce534138c85176950c6bff1d1a04">&#9670;&#160;</a></span>createHypreStructDiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructDiagonal.html">HypreStructDiagonal</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt; Cajita::createHypreStructDiagonal </td>
          <td>(</td>
          <td class="paramtype">const ArrayLayout_t &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_preconditioner</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a HYPRE Diagonal structured solver. </p><dl class="section return"><dt>Returns</dt><dd>Shared pointer to <a class="el" href="classCajita_1_1HypreStructDiagonal.html" title="Diagonal preconditioner.">HypreStructDiagonal</a>. </dd></dl>

</div>
</div>
<a id="a5d71f02651fd8a97cdc442fb874a495f" name="a5d71f02651fd8a97cdc442fb874a495f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d71f02651fd8a97cdc442fb874a495f">&#9670;&#160;</a></span>createHypreStructGMRES()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructGMRES.html">HypreStructGMRES</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt; Cajita::createHypreStructGMRES </td>
          <td>(</td>
          <td class="paramtype">const ArrayLayout_t &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_preconditioner</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a HYPRE GMRES structured solver. </p><dl class="section return"><dt>Returns</dt><dd>Shared pointer to <a class="el" href="classCajita_1_1HypreStructGMRES.html" title="GMRES solver.">HypreStructGMRES</a>. </dd></dl>

</div>
</div>
<a id="a50c0ac9ccf5f75940088f70085aac42a" name="a50c0ac9ccf5f75940088f70085aac42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c0ac9ccf5f75940088f70085aac42a">&#9670;&#160;</a></span>createHypreStructJacobi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructJacobi.html">HypreStructJacobi</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt; Cajita::createHypreStructJacobi </td>
          <td>(</td>
          <td class="paramtype">const ArrayLayout_t &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_preconditioner</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a HYPRE Jacobi structured solver. </p><dl class="section return"><dt>Returns</dt><dd>Shared pointer to <a class="el" href="classCajita_1_1HypreStructJacobi.html" title="Jacobi solver.">HypreStructJacobi</a>. </dd></dl>

</div>
</div>
<a id="a3c92d4aae32d9f5d56b31a0b8279ceb7" name="a3c92d4aae32d9f5d56b31a0b8279ceb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c92d4aae32d9f5d56b31a0b8279ceb7">&#9670;&#160;</a></span>createHypreStructPCG()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructPCG.html">HypreStructPCG</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt; Cajita::createHypreStructPCG </td>
          <td>(</td>
          <td class="paramtype">const ArrayLayout_t &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_preconditioner</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a HYPRE PCG structured solver. </p><dl class="section return"><dt>Returns</dt><dd>Shared pointer to <a class="el" href="classCajita_1_1HypreStructPCG.html" title="PCG solver.">HypreStructPCG</a>. </dd></dl>

</div>
</div>
<a id="a1caff74a3aa4d7f764fe7467419224bb" name="a1caff74a3aa4d7f764fe7467419224bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1caff74a3aa4d7f764fe7467419224bb">&#9670;&#160;</a></span>createHypreStructPFMG()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructPFMG.html">HypreStructPFMG</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt; Cajita::createHypreStructPFMG </td>
          <td>(</td>
          <td class="paramtype">const ArrayLayout_t &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_preconditioner</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a HYPRE PFMG structured solver. </p><dl class="section return"><dt>Returns</dt><dd>Shared pointer to <a class="el" href="classCajita_1_1HypreStructPFMG.html" title="PFMG solver.">HypreStructPFMG</a>. </dd></dl>

</div>
</div>
<a id="a45c7de540918841a4f8dc4ddfb521edf" name="a45c7de540918841a4f8dc4ddfb521edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c7de540918841a4f8dc4ddfb521edf">&#9670;&#160;</a></span>createHypreStructSMG()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructSMG.html">HypreStructSMG</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt; Cajita::createHypreStructSMG </td>
          <td>(</td>
          <td class="paramtype">const ArrayLayout_t &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_preconditioner</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a HYPRE SMG structured solver. </p><dl class="section return"><dt>Returns</dt><dd>Shared pointer to <a class="el" href="classCajita_1_1HypreStructSMG.html" title="SMG solver.">HypreStructSMG</a>. </dd></dl>

</div>
</div>
<a id="a5c28a5827014301ee6072123bd0ab97e" name="a5c28a5827014301ee6072123bd0ab97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c28a5827014301ee6072123bd0ab97e">&#9670;&#160;</a></span>createHypreStructuredSolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructuredSolver.html">HypreStructuredSolver</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt; Cajita::createHypreStructuredSolver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayLayout_t &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_preconditioner</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a HYPRE structured solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver_type</td><td>Solver name. </td></tr>
    <tr><td class="paramname">layout</td><td>The <a class="el" href="classCajita_1_1ArrayLayout.html" title="Entity layout for array data on the local mesh.">ArrayLayout</a> defining the vector space of the solver. </td></tr>
    <tr><td class="paramname">is_preconditioner</td><td>Use as a preconditioner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <a class="el" href="classCajita_1_1HypreStructuredSolver.html" title="Hypre structured solver interface for scalar fields.">HypreStructuredSolver</a>. </dd></dl>

</div>
</div>
<a id="a3f523da3312248cc6caa4ca35b79b66b" name="a3f523da3312248cc6caa4ca35b79b66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f523da3312248cc6caa4ca35b79b66b">&#9670;&#160;</a></span>createLocalGrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &gt; Cajita::createLocalGrid </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt; MeshType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>halo_cell_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a local grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_grid</td><td>The global grid from which the local grid will be constructed. </td></tr>
    <tr><td class="paramname">halo_cell_width</td><td>The number of halo cells surrounding the locally owned cells. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a>. </dd></dl>

</div>
</div>
<a id="a5176bf2393c60ac5fc930c521ac2809c" name="a5176bf2393c60ac5fc930c521ac2809c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5176bf2393c60ac5fc930c521ac2809c">&#9670;&#160;</a></span>createLocalMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCajita_1_1LocalMesh.html">LocalMesh</a>&lt; MemorySpace, MeshType &gt; Cajita::createLocalMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for local mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <a class="el" href="classCajita_1_1LocalMesh.html">LocalMesh</a>. </dd></dl>

</div>
</div>
<a id="a6558146b8c8a36758de47e1cebbfc1dc" name="a6558146b8c8a36758de47e1cebbfc1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6558146b8c8a36758de47e1cebbfc1dc">&#9670;&#160;</a></span>createNonUniformGlobalMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1NonUniformMesh.html">NonUniformMesh</a>&lt; Scalar, 2 &gt; &gt; &gt; Cajita::createNonUniformGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>j_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a non-uniform 2D mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Mesh scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_edges,j_edges</td><td>List of edges defining the mesh in each dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <a class="el" href="classCajita_1_1GlobalMesh.html" title="Global mesh partial specialization for uniform mesh.">GlobalMesh</a>. </dd></dl>

</div>
</div>
<a id="a37e22d3e3c25b63a4b0b248fbb2a798d" name="a37e22d3e3c25b63a4b0b248fbb2a798d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e22d3e3c25b63a4b0b248fbb2a798d">&#9670;&#160;</a></span>createNonUniformGlobalMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1NonUniformMesh.html">NonUniformMesh</a>&lt; Scalar, 3 &gt; &gt; &gt; Cajita::createNonUniformGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>j_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>k_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a non-uniform 3D mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_edges,j_edges,k_edges</td><td>List of edges defining the mesh in each dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <a class="el" href="classCajita_1_1GlobalMesh.html" title="Global mesh partial specialization for uniform mesh.">GlobalMesh</a>. </dd></dl>

</div>
</div>
<a id="ac2557f422723e7377c0b4228da4c6c02" name="ac2557f422723e7377c0b4228da4c6c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2557f422723e7377c0b4228da4c6c02">&#9670;&#160;</a></span>createParticleGridDistributor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalGridType , class PositionSliceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Distributor.html">Cabana::Distributor</a>&lt; typename PositionSliceType::memory_space &gt; Cajita::createParticleGridDistributor </td>
          <td>(</td>
          <td class="paramtype">const LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionSliceType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine which data should be migrated from one uniquely-owned decomposition to another uniquely-owned decomposition, using bounds of a <a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> grid and taking periodic boundaries into account. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LocalGridType</td><td><a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> type. </td></tr>
    <tr><td class="paramname">PositionSliceType</td><td>Position type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_grid</td><td>The local grid containing periodicity and system bound information. </td></tr>
    <tr><td class="paramname">positions</td><td>The particle positions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Distributor for later migration. </dd></dl>

</div>
</div>
<a id="abe00d64b936b78a9bdcebf8499486202" name="abe00d64b936b78a9bdcebf8499486202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe00d64b936b78a9bdcebf8499486202">&#9670;&#160;</a></span>createParticleList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace , class... FieldTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cajita::createParticleList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCabana_1_1ParticleTraits.html">Cabana::ParticleTraits</a>&lt; FieldTags... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCajita_1_1ParticleList.html" title="List of particle fields stored in AoSoA with associated Cajita mesh.">ParticleList</a> creation function. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCajita_1_1ParticleList.html" title="List of particle fields stored in AoSoA with associated Cajita mesh.">ParticleList</a> </dd></dl>

</div>
</div>
<a id="a407e798cff4a8f57514231c06eb6ffd2" name="a407e798cff4a8f57514231c06eb6ffd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407e798cff4a8f57514231c06eb6ffd2">&#9670;&#160;</a></span>createParticles() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InitFunctor , class ParticleListType , class LocalGridType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Cajita::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">Cabana::InitRandom</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InitFunctor &amp;&#160;</td>
          <td class="paramname"><em>create_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleListType &amp;&#160;</td>
          <td class="paramname"><em>particle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>particles_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>previous_num_particles</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shrink_to_fit</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>123456</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structCajita_1_1is__particle__list.html">Cajita::is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize random particles per cell given an initialization functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">create_functor</td><td>A functor which populates a particle given the logical position of a particle. This functor returns true if a particle was created and false if it was not giving the signature: <pre class="fragment">bool createFunctor( const double pid, const double px[3], const double pv,
                    typename ParticleAoSoA::tuple_type&amp; particle );
</pre> </td></tr>
    <tr><td class="paramname">particle_list</td><td>The <a class="el" href="classCajita_1_1ParticleList.html" title="List of particle fields stored in AoSoA with associated Cajita mesh.">ParticleList</a> to populate. This will be filled with particles and resized to a size equal to the number of particles created. </td></tr>
    <tr><td class="paramname">particles_per_cell</td><td>The number of particles to sample each cell with. </td></tr>
    <tr><td class="paramname">local_grid</td><td>The <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> over which particles will be created. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">shrink_to_fit</td><td>Optionally remove unused allocated space after creation. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a430493c1c7cf364045b12c3a073ede0d" name="a430493c1c7cf364045b12c3a073ede0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430493c1c7cf364045b12c3a073ede0d">&#9670;&#160;</a></span>createParticles() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType , class LocalGridType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">Cabana::InitRandom</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>particles_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>previous_num_particles</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>123456</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">Cabana::is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a random number of particles in each cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">positions</td><td>Particle positions slice. This should be already the size of the number of grid cells times particles_per_cell.s </td></tr>
    <tr><td class="paramname">particles_per_cell</td><td>The number of particles to sample each cell with. </td></tr>
    <tr><td class="paramname">local_grid</td><td>The <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> over which particles will be created. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdfb7e5d897db7fcc9dd74a9de76aeac" name="afdfb7e5d897db7fcc9dd74a9de76aeac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfb7e5d897db7fcc9dd74a9de76aeac">&#9670;&#160;</a></span>createParticles() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class InitFunctor , class ParticleListType , class LocalGridType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Cajita::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">Cabana::InitRandom</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InitFunctor &amp;&#160;</td>
          <td class="paramname"><em>create_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleListType &amp;&#160;</td>
          <td class="paramname"><em>particle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>particles_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>previous_num_particles</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shrink_to_fit</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>123456</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structCajita_1_1is__particle__list.html">Cajita::is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a random number of particles in each cell given an initialization functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">create_functor</td><td>A functor which populates a particle given the logical position of a particle. This functor returns true if a particle was created and false if it was not giving the signature: <pre class="fragment">bool createFunctor( const double pid, const double px[3], const double pv,
                    typename ParticleAoSoA::tuple_type&amp; particle );
</pre> </td></tr>
    <tr><td class="paramname">particle_list</td><td>The <a class="el" href="classCajita_1_1ParticleList.html" title="List of particle fields stored in AoSoA with associated Cajita mesh.">ParticleList</a> to populate. This will be filled with particles and resized to a size equal to the number of particles created. </td></tr>
    <tr><td class="paramname">particles_per_cell</td><td>The number of particles to sample each cell with. </td></tr>
    <tr><td class="paramname">local_grid</td><td>The <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> over which particles will be created. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">shrink_to_fit</td><td>Optionally remove unused allocated space after creation. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a324858542047fb724ebd05aaf16fee44" name="a324858542047fb724ebd05aaf16fee44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324858542047fb724ebd05aaf16fee44">&#9670;&#160;</a></span>createParticles() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class PositionType , class LocalGridType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitRandom.html">Cabana::InitRandom</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>particles_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>previous_num_particles</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>123456</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">Cabana::is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a random number of particles in each cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">positions</td><td>Particle positions slice. This should be already the size of the number of grid cells times particles_per_cell.s </td></tr>
    <tr><td class="paramname">particles_per_cell</td><td>The number of particles to sample each cell with. </td></tr>
    <tr><td class="paramname">local_grid</td><td>The <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> over which particles will be created. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for generating particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56d1de983b9c41c01e317d560dbc5ef6" name="a56d1de983b9c41c01e317d560dbc5ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d1de983b9c41c01e317d560dbc5ef6">&#9670;&#160;</a></span>createParticles() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InitFunctor , class ParticleListType , class LocalGridType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Cajita::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitUniform.html">Cabana::InitUniform</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InitFunctor &amp;&#160;</td>
          <td class="paramname"><em>create_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleListType &amp;&#160;</td>
          <td class="paramname"><em>particle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>particles_per_cell_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>previous_num_particles</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shrink_to_fit</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structCajita_1_1is__particle__list.html">Cajita::is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize uniform particles per cell given an initialization functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">create_functor</td><td>A functor which populates a particle given the logical position of a particle. This functor returns true if a particle was created and false if it was not giving the signature: <pre class="fragment">bool createFunctor( const double pid, const double px[3], const double pv,
                    typename ParticleAoSoA::tuple_type&amp; particle );
</pre> </td></tr>
    <tr><td class="paramname">particle_list</td><td>The <a class="el" href="classCajita_1_1ParticleList.html" title="List of particle fields stored in AoSoA with associated Cajita mesh.">ParticleList</a> to populate. This will be filled with particles and resized to a size equal to the number of particles created. </td></tr>
    <tr><td class="paramname">particles_per_cell_dim</td><td>The number of particles to populate each cell dimension with. </td></tr>
    <tr><td class="paramname">local_grid</td><td>The <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> over which particles will be created. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">shrink_to_fit</td><td>Optionally remove unused allocated space after creation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba3bea6775d466505131d91596094875" name="aba3bea6775d466505131d91596094875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3bea6775d466505131d91596094875">&#9670;&#160;</a></span>createParticles() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PositionType , class LocalGridType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitUniform.html">Cabana::InitUniform</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>particles_per_cell_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>previous_num_particles</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">Cabana::is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a uniform number of particles in each cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Initialization type tag. </td></tr>
    <tr><td class="paramname">positions</td><td>Particle positions slice. This should be already the size of the number of grid cells times particles_per_cell.s </td></tr>
    <tr><td class="paramname">particles_per_cell_dim</td><td>The number of particles to populate each cell dimension with. </td></tr>
    <tr><td class="paramname">local_grid</td><td>The <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> over which particles will be created. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fdc6ecfb7f3dfb8fbac5699856b8be2" name="a2fdc6ecfb7f3dfb8fbac5699856b8be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdc6ecfb7f3dfb8fbac5699856b8be2">&#9670;&#160;</a></span>createParticles() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class InitFunctor , class ParticleListType , class LocalGridType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Cajita::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitUniform.html">Cabana::InitUniform</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InitFunctor &amp;&#160;</td>
          <td class="paramname"><em>create_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleListType &amp;&#160;</td>
          <td class="paramname"><em>particle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>particles_per_cell_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>previous_num_particles</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shrink_to_fit</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structCajita_1_1is__particle__list.html">Cajita::is_particle_list</a>&lt; ParticleListType &gt;::value, int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize uniform particles per cell given an initialization functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">create_functor</td><td>A functor which populates a particle given the logical position of a particle. This functor returns true if a particle was created and false if it was not giving the signature: <pre class="fragment">bool createFunctor( const double px[3],
                    typename ParticleAoSoA::tuple_type&amp; particle );
</pre> </td></tr>
    <tr><td class="paramname">particle_list</td><td>The <a class="el" href="classCajita_1_1ParticleList.html" title="List of particle fields stored in AoSoA with associated Cajita mesh.">ParticleList</a> to populate. This will be filled with particles and resized to a size equal to the number of particles created. </td></tr>
    <tr><td class="paramname">particles_per_cell_dim</td><td>The number of particles to populate each cell dimension with. </td></tr>
    <tr><td class="paramname">local_grid</td><td>The <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> over which particles will be created. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
    <tr><td class="paramname">shrink_to_fit</td><td>Optionally remove unused allocated space after creation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af07b06c056bbbcb534ee8db9e8f6b641" name="af07b06c056bbbcb534ee8db9e8f6b641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07b06c056bbbcb534ee8db9e8f6b641">&#9670;&#160;</a></span>createParticles() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class PositionType , class LocalGridType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::createParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1InitUniform.html">Cabana::InitUniform</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>particles_per_cell_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>previous_num_particles</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;(<a class="el" href="structCabana_1_1is__slice.html">Cabana::is_slice</a>&lt; PositionType &gt;::value||Kokkos::is_view&lt; PositionType &gt;::value), int &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a uniform number of particles in each cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec_space</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">positions</td><td>Particle positions slice. This should be already the size of the number of grid cells times particles_per_cell.s </td></tr>
    <tr><td class="paramname">particles_per_cell_dim</td><td>The number of particles to populate each cell dimension with. </td></tr>
    <tr><td class="paramname">local_grid</td><td>The <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> over which particles will be created. </td></tr>
    <tr><td class="paramname">previous_num_particles</td><td>Optionally specify how many particles are already in the container (and should be unchanged). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb6f0025c053a6112442f5be3d7375b1" name="afb6f0025c053a6112442f5be3d7375b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6f0025c053a6112442f5be3d7375b1">&#9670;&#160;</a></span>createReferenceConjugateGradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class MemorySpace , class EntityType , class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1ReferenceConjugateGradient.html">ReferenceConjugateGradient</a>&lt; Scalar, EntityType, MeshType, MemorySpace &gt; &gt; Cajita::createReferenceConjugateGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for reference structured preconditioned block conjugate gradient. </p>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <a class="el" href="classCajita_1_1ReferenceConjugateGradient.html" title="Reference structured preconditioned block conjugate gradient implementation.">ReferenceConjugateGradient</a>. </dd></dl>

</div>
</div>
<a id="a60732be857858da54d80ef3d79d90a2b" name="a60732be857858da54d80ef3d79d90a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60732be857858da54d80ef3d79d90a2b">&#9670;&#160;</a></span>createScalarGradientG2P()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCajita_1_1ScalarGradientG2P.html">ScalarGradientG2P</a>&lt; ViewType &gt; Cajita::createScalarGradientG2P </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ViewType::value_type &amp;&#160;</td>
          <td class="paramname"><em>multiplier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for grid-to-point with scalar gradient. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCajita_1_1ScalarGradientG2P.html" title="Grid-to-point scalar gradient functor.">ScalarGradientG2P</a> interpolation functor. </dd></dl>

</div>
</div>
<a id="abac7b11ead96b662cabf7db52327e4ab" name="abac7b11ead96b662cabf7db52327e4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac7b11ead96b662cabf7db52327e4ab">&#9670;&#160;</a></span>createScalarGradientP2G()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCajita_1_1ScalarGradientP2G.html">ScalarGradientP2G</a>&lt; ViewType &gt; Cajita::createScalarGradientP2G </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ViewType::value_type &amp;&#160;</td>
          <td class="paramname"><em>multiplier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for point-to-grid with scalar gradient. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCajita_1_1ScalarGradientP2G.html" title="Point-to-grid scalar gradient functor.">ScalarGradientP2G</a> interpolation functor. </dd></dl>

</div>
</div>
<a id="af216844047716b9ed30e193350c0ac87" name="af216844047716b9ed30e193350c0ac87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af216844047716b9ed30e193350c0ac87">&#9670;&#160;</a></span>createScalarValueG2P()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCajita_1_1ScalarValueG2P.html">ScalarValueG2P</a>&lt; ViewType &gt; Cajita::createScalarValueG2P </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ViewType::value_type &amp;&#160;</td>
          <td class="paramname"><em>multiplier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for grid-to-point with scalar value. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCajita_1_1ScalarValueG2P.html" title="Grid-to-point scalar value functor.">ScalarValueG2P</a> interpolation functor. </dd></dl>

</div>
</div>
<a id="aff6673ee759e0056d8080f12b178e612" name="aff6673ee759e0056d8080f12b178e612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6673ee759e0056d8080f12b178e612">&#9670;&#160;</a></span>createScalarValueP2G()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCajita_1_1ScalarValueP2G.html">ScalarValueP2G</a>&lt; ViewType &gt; Cajita::createScalarValueP2G </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ViewType::value_type &amp;&#160;</td>
          <td class="paramname"><em>multiplier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for point-to-grid with scalar value. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCajita_1_1ScalarValueP2G.html" title="Point-to-grid scalar value functor.">ScalarValueP2G</a> interpolation functor. </dd></dl>

</div>
</div>
<a id="a57b3d8e281a87bbbad41d683ccdc2932" name="a57b3d8e281a87bbbad41d683ccdc2932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b3d8e281a87bbbad41d683ccdc2932">&#9670;&#160;</a></span>createSparseGlobalMesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt; Cajita::createSparseGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_low_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_high_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>cell_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create sparse mesh with uniform cell size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Mesh floating point type. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>Spatial dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_low_corner,global_high_corner</td><td>Location of the mesh corner. </td></tr>
    <tr><td class="paramname">cell_size</td><td>Uniform cell size for every dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <a class="el" href="classCajita_1_1GlobalMesh.html" title="Global mesh partial specialization for uniform mesh.">GlobalMesh</a>. </dd></dl>

</div>
</div>
<a id="a3fa0745c47c59a4b2b217d2e8c381917" name="a3fa0745c47c59a4b2b217d2e8c381917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa0745c47c59a4b2b217d2e8c381917">&#9670;&#160;</a></span>createSparseGlobalMesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt; Cajita::createSparseGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_low_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_high_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_num_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create sparse mesh with total number of cells. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Mesh floating point type. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>Spatial dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_low_corner,global_high_corner</td><td>Location of the mesh corner. </td></tr>
    <tr><td class="paramname">global_num_cell</td><td>Array ofnumber of cells per dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <a class="el" href="classCajita_1_1GlobalMesh.html" title="Global mesh partial specialization for uniform mesh.">GlobalMesh</a>. </dd></dl>

</div>
</div>
<a id="a719fca8fb1f9b118e0861f7945acba31" name="a719fca8fb1f9b118e0861f7945acba31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719fca8fb1f9b118e0861f7945acba31">&#9670;&#160;</a></span>createSparseGlobalMesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt; Cajita::createSparseGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_low_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_high_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create sparse mesh with uniform cell size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Mesh floating point type. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>Spatial dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_low_corner,global_high_corner</td><td>Location of the mesh corner. </td></tr>
    <tr><td class="paramname">cell_size</td><td>Array ofuniform cell size per dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <a class="el" href="classCajita_1_1GlobalMesh.html" title="Global mesh partial specialization for uniform mesh.">GlobalMesh</a>. </dd></dl>

</div>
</div>
<a id="a0b44fb276ae635458abbea70f92f9d42" name="a0b44fb276ae635458abbea70f92f9d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b44fb276ae635458abbea70f92f9d42">&#9670;&#160;</a></span>createSparseMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemorySpace , class Scalar , unsigned long long CellPerTileDim = 4, <a class="el" href="namespaceCajita.html#a2ec822f40e278e94dbe22325c2b4c824">HashTypes</a> Hash = HashTypes::Naive, typename Key  = uint64_t, typename Value  = uint64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCajita_1_1SparseMap.html">SparseMap</a>&lt; MemorySpace, CellPerTileDim, Hash, Key, Value &gt; Cajita::createSparseMap </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pre_alloc_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for <a class="el" href="classCajita_1_1SparseMap.html" title="Sparse index space, with a hierarchical structure (cell-&gt;tile-&gt;block)">SparseMap</a> from GlobalMesh&lt;SparseMesh&gt; </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classCajita_1_1SparseMap.html" title="Sparse index space, with a hierarchical structure (cell-&gt;tile-&gt;block)">SparseMap</a> </dd></dl>

</div>
</div>
<a id="a966e2b4b433fdf383c0809965cdaaac9" name="a966e2b4b433fdf383c0809965cdaaac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966e2b4b433fdf383c0809965cdaaac9">&#9670;&#160;</a></span>createSubarray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, typename <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt;::subview_layout, typename <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt;::memory_space, typename <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt;::subview_memory_traits &gt; &gt; Cajita::createSubarray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dof_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dof_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a subarray of the given array over the given range of degrees of freedom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array from which to create a subarray </td></tr>
    <tr><td class="paramname">dof_min</td><td>The minimum degree-of-freedom index of the subarray. </td></tr>
    <tr><td class="paramname">dof_max</td><td>The maximum degree-of-freedom index of the subarray. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a new <a class="el" href="classCajita_1_1Array.html" title="Array of field data on the local mesh.">Array</a>. </dd></dl>

</div>
</div>
<a id="afffd9f583a762bf067ff0d583b5e3498" name="afffd9f583a762bf067ff0d583b5e3498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffd9f583a762bf067ff0d583b5e3498">&#9670;&#160;</a></span>createSubview() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION auto Cajita::createSubview </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( Kokkos::subview( view, index_space.range( 0 ) ) )
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a view create a subview over the given index space. </p>
<dl class="section return"><dt>Returns</dt><dd>subview of the original Kokkos::View</dd></dl>
<p>Rank-1 specialization. </p>

</div>
</div>
<a id="a4594470daa8143fa9a8f65e5689c3ae7" name="a4594470daa8143fa9a8f65e5689c3ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4594470daa8143fa9a8f65e5689c3ae7">&#9670;&#160;</a></span>createSubview() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION auto Cajita::createSubview </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( Kokkos::subview( view, index_space.range( 0 ),
                                  index_space.range( 1 ) ) )
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a view create a subview over the given index space. </p>
<dl class="section return"><dt>Returns</dt><dd>subview of the original Kokkos::View</dd></dl>
<p>Rank-2 specialization. </p>

</div>
</div>
<a id="aeb002d4e9b61930c1478eaf4f00d610f" name="aeb002d4e9b61930c1478eaf4f00d610f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb002d4e9b61930c1478eaf4f00d610f">&#9670;&#160;</a></span>createSubview() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION auto Cajita::createSubview </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( Kokkos::subview( view, index_space.range( 0 ),
                                  index_space.range( 1 ),
                                  index_space.range( 2 ) ) )
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a view create a subview over the given index space. </p>
<dl class="section return"><dt>Returns</dt><dd>subview of the original Kokkos::View</dd></dl>
<p>Rank-3 specialization. </p>

</div>
</div>
<a id="a413c2645baa122d4cb8f079597e43fce" name="a413c2645baa122d4cb8f079597e43fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413c2645baa122d4cb8f079597e43fce">&#9670;&#160;</a></span>createSubview() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION auto Cajita::createSubview </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( Kokkos::subview( view, index_space.range( 0 ),
                                  index_space.range( 1 ),
                                  index_space.range( 2 ),
                                  index_space.range( 3 ) ) )
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a view create a subview over the given index space. </p>
<dl class="section return"><dt>Returns</dt><dd>subview of the original Kokkos::View</dd></dl>
<p>Rank-4 specialization. </p>

</div>
</div>
<a id="aec36af19ffac23853a2e1429544e6d7b" name="aec36af19ffac23853a2e1429544e6d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec36af19ffac23853a2e1429544e6d7b">&#9670;&#160;</a></span>createTensorDivergenceP2G()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCajita_1_1TensorDivergenceP2G.html">TensorDivergenceP2G</a>&lt; ViewType &gt; Cajita::createTensorDivergenceP2G </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ViewType::value_type &amp;&#160;</td>
          <td class="paramname"><em>multiplier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for point-to-grid with tensor divergence. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCajita_1_1TensorDivergenceP2G.html" title="Point-to-grid tensor divergence functor.">TensorDivergenceP2G</a> interpolation functor. </dd></dl>

</div>
</div>
<a id="a16ade2ab7814eff8c8fcf0458db57834" name="a16ade2ab7814eff8c8fcf0458db57834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ade2ab7814eff8c8fcf0458db57834">&#9670;&#160;</a></span>createUniformGlobalMesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt; Cajita::createUniformGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_low_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_high_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>cell_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create uniform mesh with uniform cell size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Mesh floating point type. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>Spatial dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_low_corner,global_high_corner</td><td>Location of the mesh corner. </td></tr>
    <tr><td class="paramname">cell_size</td><td>Uniform cell size for every dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <a class="el" href="classCajita_1_1GlobalMesh.html" title="Global mesh partial specialization for uniform mesh.">GlobalMesh</a>. </dd></dl>

</div>
</div>
<a id="ab5d19738dfc2e199c3c650f6ded685cc" name="ab5d19738dfc2e199c3c650f6ded685cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d19738dfc2e199c3c650f6ded685cc">&#9670;&#160;</a></span>createUniformGlobalMesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt; Cajita::createUniformGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_low_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_high_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_num_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create uniform mesh with total number of cells. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Mesh floating point type. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>Spatial dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_low_corner,global_high_corner</td><td>Location of the mesh corner. </td></tr>
    <tr><td class="paramname">global_num_cell</td><td>Array ofnumber of cells per dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <a class="el" href="classCajita_1_1GlobalMesh.html" title="Global mesh partial specialization for uniform mesh.">GlobalMesh</a>. </dd></dl>

</div>
</div>
<a id="a58f119fd6e65291b17c727cde04e75ea" name="a58f119fd6e65291b17c727cde04e75ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f119fd6e65291b17c727cde04e75ea">&#9670;&#160;</a></span>createUniformGlobalMesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt; Cajita::createUniformGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_low_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_high_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create uniform mesh with uniform cell size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Mesh floating point type. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>Spatial dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_low_corner,global_high_corner</td><td>Location of the mesh corner. </td></tr>
    <tr><td class="paramname">cell_size</td><td>Array ofuniform cell size per dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to a <a class="el" href="classCajita_1_1GlobalMesh.html" title="Global mesh partial specialization for uniform mesh.">GlobalMesh</a>. </dd></dl>

</div>
</div>
<a id="a03d90eb25c79d9ff881e21aecee1a203" name="a03d90eb25c79d9ff881e21aecee1a203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d90eb25c79d9ff881e21aecee1a203">&#9670;&#160;</a></span>createVectorDivergenceG2P()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCajita_1_1VectorDivergenceG2P.html">VectorDivergenceG2P</a>&lt; ViewType &gt; Cajita::createVectorDivergenceG2P </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ViewType::value_type &amp;&#160;</td>
          <td class="paramname"><em>multiplier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for grid-to-point with vector divergence. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCajita_1_1VectorDivergenceG2P.html" title="Grid-to-point vector value functor.">VectorDivergenceG2P</a> interpolation functor. </dd></dl>

</div>
</div>
<a id="a2e5f57cb216ead977713612d719178de" name="a2e5f57cb216ead977713612d719178de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5f57cb216ead977713612d719178de">&#9670;&#160;</a></span>createVectorDivergenceP2G()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCajita_1_1VectorDivergenceP2G.html">VectorDivergenceP2G</a>&lt; ViewType &gt; Cajita::createVectorDivergenceP2G </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ViewType::value_type &amp;&#160;</td>
          <td class="paramname"><em>multiplier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for point-to-grid with vector divergence. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCajita_1_1VectorDivergenceP2G.html" title="Point-to-grid vector divergence functor.">VectorDivergenceP2G</a> interpolation functor. </dd></dl>

</div>
</div>
<a id="ac5a7aa16c0af807d86e915f85c6d4eba" name="ac5a7aa16c0af807d86e915f85c6d4eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a7aa16c0af807d86e915f85c6d4eba">&#9670;&#160;</a></span>createVectorGradientG2P()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCajita_1_1VectorGradientG2P.html">VectorGradientG2P</a>&lt; ViewType &gt; Cajita::createVectorGradientG2P </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ViewType::value_type &amp;&#160;</td>
          <td class="paramname"><em>multiplier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for grid-to-point with vector gradient. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCajita_1_1VectorGradientG2P.html" title="Grid-to-point vector gradient functor.">VectorGradientG2P</a> interpolation functor. </dd></dl>

</div>
</div>
<a id="a550995d7068512563be8850fabede1bf" name="a550995d7068512563be8850fabede1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550995d7068512563be8850fabede1bf">&#9670;&#160;</a></span>createVectorValueG2P()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCajita_1_1VectorValueG2P.html">VectorValueG2P</a>&lt; ViewType &gt; Cajita::createVectorValueG2P </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ViewType::value_type &amp;&#160;</td>
          <td class="paramname"><em>multiplier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for grid-to-point with vector value. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCajita_1_1VectorValueG2P.html" title="Grid-to-point vector value functor.">VectorValueG2P</a> interpolation functor. </dd></dl>

</div>
</div>
<a id="a153b58a7f96c06db398c646e51071a76" name="a153b58a7f96c06db398c646e51071a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153b58a7f96c06db398c646e51071a76">&#9670;&#160;</a></span>createVectorValueP2G()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCajita_1_1VectorValueP2G.html">VectorValueP2G</a>&lt; ViewType &gt; Cajita::createVectorValueP2G </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ViewType::value_type &amp;&#160;</td>
          <td class="paramname"><em>multiplier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation function for point-to-grid with vector value. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCajita_1_1VectorValueP2G.html" title="Point-to-grid vector value functor.">VectorValueP2G</a> interpolation functor. </dd></dl>

</div>
</div>
<a id="a35f6ec432d9d9173b3882e0a9fcad001" name="a35f6ec432d9d9173b3882e0a9fcad001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f6ec432d9d9173b3882e0a9fcad001">&#9670;&#160;</a></span>createView() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt; Scalar *, Params..., Kokkos::MemoryUnmanaged &gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space and a data pointer create an unmanaged view over the extent of that index space. </p>
<dl class="section return"><dt>Returns</dt><dd>Unmanaged Kokkos::View</dd></dl>
<p>Rank-1 specialization. </p>

</div>
</div>
<a id="a0532beb1d6581bb6cd9209ca66138d64" name="a0532beb1d6581bb6cd9209ca66138d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0532beb1d6581bb6cd9209ca66138d64">&#9670;&#160;</a></span>createView() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt; Scalar **, Params..., Kokkos::MemoryUnmanaged &gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space and a data pointer create an unmanaged view over the extent of that index space. </p>
<dl class="section return"><dt>Returns</dt><dd>Unmanaged Kokkos::View</dd></dl>
<p>Rank-2 specialization. </p>

</div>
</div>
<a id="a0161931a68a6885f9677065f1ae75061" name="a0161931a68a6885f9677065f1ae75061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0161931a68a6885f9677065f1ae75061">&#9670;&#160;</a></span>createView() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt; Scalar ***, Params..., Kokkos::MemoryUnmanaged &gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space and a data pointer create an unmanaged view over the extent of that index space. </p>
<dl class="section return"><dt>Returns</dt><dd>Unmanaged Kokkos::View</dd></dl>
<p>Rank-3 specialization. </p>

</div>
</div>
<a id="ac9573b857e2ae0d4dcc2935527017d16" name="ac9573b857e2ae0d4dcc2935527017d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9573b857e2ae0d4dcc2935527017d16">&#9670;&#160;</a></span>createView() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt; Scalar ****, Params..., Kokkos::MemoryUnmanaged &gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space and a data pointer create an unmanaged view over the extent of that index space. </p>
<dl class="section return"><dt>Returns</dt><dd>Unmanaged Kokkos::View</dd></dl>
<p>Rank-4 specialization. </p>

</div>
</div>
<a id="ab24fe00c83ebfa654cf17e1b37da1df4" name="ab24fe00c83ebfa654cf17e1b37da1df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24fe00c83ebfa654cf17e1b37da1df4">&#9670;&#160;</a></span>createView() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt; Scalar *, Params... &gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space create a view over the extent of that index space. </p>
<dl class="section return"><dt>Returns</dt><dd>Uninitialized Kokkos::View</dd></dl>
<p>Rank-1 specialization. </p>

</div>
</div>
<a id="a9158690c5131a1b161d9231bd8689b80" name="a9158690c5131a1b161d9231bd8689b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9158690c5131a1b161d9231bd8689b80">&#9670;&#160;</a></span>createView() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt; Scalar **, Params... &gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space create a view over the extent of that index space. </p>
<dl class="section return"><dt>Returns</dt><dd>Uninitialized Kokkos::View</dd></dl>
<p>Rank-2 specialization. </p>

</div>
</div>
<a id="ab3bf0e22ae8f2deab76e5fbd7b00af3e" name="ab3bf0e22ae8f2deab76e5fbd7b00af3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bf0e22ae8f2deab76e5fbd7b00af3e">&#9670;&#160;</a></span>createView() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt; Scalar ***, Params... &gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space create a view over the extent of that index space. </p>
<dl class="section return"><dt>Returns</dt><dd>Uninitialized Kokkos::View</dd></dl>
<p>Rank-3 specialization. </p>

</div>
</div>
<a id="a79b5c9fe52af6b7e411c68b9e59733ee" name="a79b5c9fe52af6b7e411c68b9e59733ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b5c9fe52af6b7e411c68b9e59733ee">&#9670;&#160;</a></span>createView() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt; Scalar ****, Params... &gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space create a view over the extent of that index space. </p>
<dl class="section return"><dt>Returns</dt><dd>Uninitialized Kokkos::View</dd></dl>
<p>Rank-4 specialization. </p>

</div>
</div>
<a id="a29734b06e0d3e134136763ccfe527119" name="a29734b06e0d3e134136763ccfe527119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29734b06e0d3e134136763ccfe527119">&#9670;&#160;</a></span>g2p() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointEvalFunctor , class PointCoordinates , class ArrayScalar , class MeshScalar , class EntityType , int SplineOrder, std::size_t NumSpaceDim, class MemorySpace , class... ArrayParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::g2p </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; ArrayScalar, EntityType, <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; MeshScalar, NumSpaceDim &gt;, ArrayParams... &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1Halo.html">Halo</a>&lt; MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointCoordinates &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCajita_1_1Spline.html">Spline</a>&lt; SplineOrder &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointEvalFunctor &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> Grid-to-Point interpolation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointEvalFunctor</td><td>Functor type used to evaluate the interpolated data for a given point at a given entity. </td></tr>
    <tr><td class="paramname">PointCoordinates</td><td>Container type with view traits containing the point coordinates. Will be indexed as (point,dim). </td></tr>
    <tr><td class="paramname">ArrayScalar</td><td>The scalar type used for the interpolated data. </td></tr>
    <tr><td class="paramname">MeshScalar</td><td>The scalar type used for the geometry/interpolation data. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>The spatial dimension of the mesh. </td></tr>
    <tr><td class="paramname">EntityType</td><td>The entitytype to which the points will interpolate. </td></tr>
    <tr><td class="paramname">SplineOrder</td><td>The order of spline interpolation to use. </td></tr>
    <tr><td class="paramname">MemorySpace</td><td>The memory space to use for interplation </td></tr>
    <tr><td class="paramname">ArrayParams</td><td>Parameters for the array type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The grid array from which the point data will be interpolated. </td></tr>
    <tr><td class="paramname">halo</td><td>The halo associated with the grid array. This hallo will be used to gather the array data before interpolation. </td></tr>
    <tr><td class="paramname">points</td><td>The points over which to perform the interpolation. Will be indexed as (point,dim). The subset of indices in each point's interpolation stencil must be contained within the local grid that will be used for the interpolation </td></tr>
    <tr><td class="paramname">num_point</td><td>The number of points. This is the size of the first dimension of points. </td></tr>
    <tr><td class="paramname">functor</td><td>A functor that interpolates from a given entity to a given point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> of SplineOrder passed for interpolation. </dd></dl>

</div>
</div>
<a id="ad9d19f2ef5451251a976755c2d564bd9" name="ad9d19f2ef5451251a976755c2d564bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d19f2ef5451251a976755c2d564bd9">&#9670;&#160;</a></span>g2p() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class PointEvalFunctor , class PointCoordinates , class ArrayScalar , class MeshScalar , class EntityType , int SplineOrder, std::size_t NumSpaceDim, class MemorySpace , class... ArrayParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::g2p </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; ArrayScalar, EntityType, <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; MeshScalar, NumSpaceDim &gt;, ArrayParams... &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1Halo.html">Halo</a>&lt; MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointCoordinates &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCajita_1_1Spline.html">Spline</a>&lt; SplineOrder &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointEvalFunctor &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> Grid-to-Point interpolation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecutionSpace</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">PointEvalFunctor</td><td>Functor type used to evaluate the interpolated data for a given point at a given entity. </td></tr>
    <tr><td class="paramname">PointCoordinates</td><td>Container type with view traits containing the point coordinates. Will be indexed as (point,dim). </td></tr>
    <tr><td class="paramname">ArrayScalar</td><td>The scalar type used for the interpolated data. </td></tr>
    <tr><td class="paramname">MeshScalar</td><td>The scalar type used for the geometry/interpolation data. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>The spatial dimension of the mesh. </td></tr>
    <tr><td class="paramname">EntityType</td><td>The entitytype to which the points will interpolate. </td></tr>
    <tr><td class="paramname">SplineOrder</td><td>The order of spline interpolation to use. </td></tr>
    <tr><td class="paramname">MemorySpace</td><td>The memory space to use for interplation </td></tr>
    <tr><td class="paramname">ArrayParams</td><td>Parameters for the array type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The grid array from which the point data will be interpolated. </td></tr>
    <tr><td class="paramname">halo</td><td>The halo associated with the grid array. This hallo will be used to gather the array data before interpolation. </td></tr>
    <tr><td class="paramname">points</td><td>The points over which to perform the interpolation. Will be indexed as (point,dim). The subset of indices in each point's interpolation stencil must be contained within the local grid that will be used for the interpolation </td></tr>
    <tr><td class="paramname">num_point</td><td>The number of points. This is the size of the first dimension of points. </td></tr>
    <tr><td class="paramname">functor</td><td>A functor that interpolates from a given entity to a given point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> of SplineOrder passed for interpolation. </dd></dl>

</div>
</div>
<a id="a7df563913201dda5b4483f9d076ea905" name="a7df563913201dda5b4483f9d076ea905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df563913201dda5b4483f9d076ea905">&#9670;&#160;</a></span>getTopology() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalGridType , std::size_t NSD = LocalGridType::num_space_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; 3==NSD, std::vector&lt; int &gt; &gt; Cajita::getTopology </td>
          <td>(</td>
          <td class="paramtype">const LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build neighbor topology of 27 nearest 3D neighbors. Some of the ranks in this list may be invalid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_grid</td><td><a class="el" href="structCajita_1_1Local.html" title="Local index tag.">Local</a> grid from which MPI neighbors will be extracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MPI neighbor ranks in k,j,i order. </dd></dl>

</div>
</div>
<a id="a65bd1a63701dab16670dbdcca017f607" name="a65bd1a63701dab16670dbdcca017f607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bd1a63701dab16670dbdcca017f607">&#9670;&#160;</a></span>getTopology() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalGridType , std::size_t NSD = LocalGridType::num_space_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; 2==NSD, std::vector&lt; int &gt; &gt; Cajita::getTopology </td>
          <td>(</td>
          <td class="paramtype">const LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build neighbor topology of 8 nearest 2D neighbors. Some of the ranks in this list may be invalid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_grid</td><td><a class="el" href="structCajita_1_1Local.html" title="Local index tag.">Local</a> grid from which MPI neighbors will be extracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MPI neighbor ranks in k,j,i order. </dd></dl>

</div>
</div>
<a id="a1c57f5f0f71a9195f375410205a2df20" name="a1c57f5f0f71a9195f375410205a2df20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c57f5f0f71a9195f375410205a2df20">&#9670;&#160;</a></span>grid_parallel_for() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class ExecutionSpace , long N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a functor in parallel with a multidimensional execution policy specified by the given index space. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">N</td><td>The dimension of the index space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">index_space</td><td>The index space over which to loop.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a644313d527fab5a1d9e59a138f51ec63" name="a644313d527fab5a1d9e59a138f51ec63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644313d527fab5a1d9e59a138f51ec63">&#9670;&#160;</a></span>grid_parallel_for() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class WorkTag , class ExecutionSpace , long N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorkTag &amp;&#160;</td>
          <td class="paramname"><em>work_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a functor with a work tag in parallel with a multidimensional execution policy specified by the given index space. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">WorkTag</td><td>The functor execution tag.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">N</td><td>The dimension of the index space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">index_space</td><td>The index space over which to loop.</td></tr>
    <tr><td class="paramname">work_tag</td><td>The functor execution tag.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45372f78f3e6880b22331ef24d113e6e" name="a45372f78f3e6880b22331ef24d113e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45372f78f3e6880b22331ef24d113e6e">&#9670;&#160;</a></span>grid_parallel_for() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class ExecutionSpace , std::size_t NumSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::Array&lt; <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt;, NumSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a functor in parallel with a linear execution policy specified by the set of given index spaces. 2D specialization. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">NumSpace</td><td>The number of index spaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">index_spaces</td><td>The set of index spaces over which to loop.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute. Signature is f(space_id,i,j) space_id is the index of the index space in index_spaces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7824cb8412bd64ae4056c428f36c1c9c" name="a7824cb8412bd64ae4056c428f36c1c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7824cb8412bd64ae4056c428f36c1c9c">&#9670;&#160;</a></span>grid_parallel_for() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class ExecutionSpace , std::size_t NumSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::Array&lt; <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt;, NumSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a functor in parallel with a linear execution policy specified by the set of given index spaces. 3D specialization. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">NumSpace</td><td>The number of index spaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">index_spaces</td><td>The set of index spaces over which to loop.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute. Signature is f(space_id,i,j,k) space_id is the index of the index space in index_spaces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afda357df1d146e578d38366e081b6624" name="afda357df1d146e578d38366e081b6624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda357df1d146e578d38366e081b6624">&#9670;&#160;</a></span>grid_parallel_for() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class ExecutionSpace , std::size_t NumSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::Array&lt; <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt;, NumSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a functor in parallel with a linear execution policy specified by the set of given index spaces. 4D specialization. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">NumSpace</td><td>The number of index spaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">index_spaces</td><td>The set of index spaces over which to loop.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute. Signature is f(space_id,i,j,k,l) space_id is the index of the index space in index_spaces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cc2c75279e73a954b280239e841b444" name="a0cc2c75279e73a954b280239e841b444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc2c75279e73a954b280239e841b444">&#9670;&#160;</a></span>grid_parallel_for() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DecompositionType &amp;&#160;</td>
          <td class="paramname"><em>decomposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EntityType &amp;&#160;</td>
          <td class="paramname"><em>entity_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a functor in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">MeshType</td><td>The mesh type of the local grid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">local_grid</td><td>The local grid to iterate over.</td></tr>
    <tr><td class="paramname">decomposition</td><td>The decomposition type of the entities (own,ghost).</td></tr>
    <tr><td class="paramname">entity_type</td><td>The entity type over which to loop.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2e1b082bbdd2df7693ce178f4d33749" name="ac2e1b082bbdd2df7693ce178f4d33749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e1b082bbdd2df7693ce178f4d33749">&#9670;&#160;</a></span>grid_parallel_for() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class WorkTag , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DecompositionType &amp;&#160;</td>
          <td class="paramname"><em>decomposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EntityType &amp;&#160;</td>
          <td class="paramname"><em>entity_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorkTag &amp;&#160;</td>
          <td class="paramname"><em>work_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a functor with a work tag in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">WorkTag</td><td>The functor work tag.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">MeshType</td><td>The mesh type of the local grid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">local_grid</td><td>The local grid to iterate over.</td></tr>
    <tr><td class="paramname">decomposition</td><td>The decomposition type of the entities (own,ghost).</td></tr>
    <tr><td class="paramname">entity_type</td><td>The entity type over which to loop.</td></tr>
    <tr><td class="paramname">work_tag</td><td>The functor execution tag.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2a58a3b10046140ae6a75b252dbade6" name="ac2a58a3b10046140ae6a75b252dbade6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a58a3b10046140ae6a75b252dbade6">&#9670;&#160;</a></span>grid_parallel_reduce() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class ExecutionSpace , long N, class ReduceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a reduction functor in parallel with a multidimensional execution policy specified by the given index space. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">N</td><td>The dimension of the index space.</td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">index_space</td><td>The index space over which to loop.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute.</td></tr>
    <tr><td class="paramname">reducer</td><td>The parallel reduce result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3578b89bdd7bd62f95ff985a77b8986" name="ae3578b89bdd7bd62f95ff985a77b8986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3578b89bdd7bd62f95ff985a77b8986">&#9670;&#160;</a></span>grid_parallel_reduce() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class WorkTag , class ExecutionSpace , long N, class ReduceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorkTag &amp;&#160;</td>
          <td class="paramname"><em>work_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a reduction functor with a work tag in parallel with a multidimensional execution policy specified by the given index space. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">WorkTag</td><td>The functor execution tag.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">N</td><td>The dimension of the index space.</td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">index_space</td><td>The index space over which to loop.</td></tr>
    <tr><td class="paramname">work_tag</td><td>The functor execution tag.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute.</td></tr>
    <tr><td class="paramname">reducer</td><td>The parallel reduce result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14f60204e3f1448420140403bc39d3ea" name="a14f60204e3f1448420140403bc39d3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f60204e3f1448420140403bc39d3ea">&#9670;&#160;</a></span>grid_parallel_reduce() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType , class ReduceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DecompositionType &amp;&#160;</td>
          <td class="paramname"><em>decomposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EntityType &amp;&#160;</td>
          <td class="paramname"><em>entity_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a reduction functor in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">MeshType</td><td>The mesh type of the local grid.</td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">local_grid</td><td>The local grid to iterate over.</td></tr>
    <tr><td class="paramname">decomposition</td><td>The decomposition type of the entities (own,ghost).</td></tr>
    <tr><td class="paramname">entity_type</td><td>The entity type over which to loop.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute.</td></tr>
    <tr><td class="paramname">reducer</td><td>The parallel reduce result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa10581196134700af84ad9a4b73f2ed4" name="aa10581196134700af84ad9a4b73f2ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10581196134700af84ad9a4b73f2ed4">&#9670;&#160;</a></span>grid_parallel_reduce() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class WorkTag , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType , class ReduceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DecompositionType &amp;&#160;</td>
          <td class="paramname"><em>decomposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EntityType &amp;&#160;</td>
          <td class="paramname"><em>entity_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorkTag &amp;&#160;</td>
          <td class="paramname"><em>work_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a reduction functor with a work tag in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">WorkTag</td><td>The functor work tag.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">MeshType</td><td>The mesh type of the local grid.</td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">decomposition</td><td>The decomposition type of the entities (own,ghost).</td></tr>
    <tr><td class="paramname">local_grid</td><td>The local grid to iterate over.</td></tr>
    <tr><td class="paramname">entity_type</td><td>The entity type over which to loop.</td></tr>
    <tr><td class="paramname">work_tag</td><td>The functor execution tag.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute.</td></tr>
    <tr><td class="paramname">reducer</td><td>The parallel reduce result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a583a9ee0c0e31310b730fa3ca3819721" name="a583a9ee0c0e31310b730fa3ca3819721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583a9ee0c0e31310b730fa3ca3819721">&#9670;&#160;</a></span>migrateCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalGridType , class PositionSliceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Cajita::migrateCount </td>
          <td>(</td>
          <td class="paramtype">const LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionSliceType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>minimum_halo_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for the number of particles that must be communicated. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LocalGridType</td><td><a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> type. </td></tr>
    <tr><td class="paramname">PositionSliceType</td><td>Particle position type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_grid</td><td>The local grid containing periodicity and system bound information. </td></tr>
    <tr><td class="paramname">positions</td><td>The particle position container, either Slice or View. </td></tr>
    <tr><td class="paramname">minimum_halo_width</td><td>Number of halo mesh widths to include for ghosting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e7718a376faa4470d8c6684946c8387" name="a8e7718a376faa4470d8c6684946c8387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7718a376faa4470d8c6684946c8387">&#9670;&#160;</a></span>p2g() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointEvalFunctor , class PointCoordinates , class ArrayScalar , class MeshScalar , std::size_t NumSpaceDim, class EntityType , int SplineOrder, class MemorySpace , class... ArrayParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::p2g </td>
          <td>(</td>
          <td class="paramtype">const PointEvalFunctor &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointCoordinates &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCajita_1_1Spline.html">Spline</a>&lt; SplineOrder &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1Halo.html">Halo</a>&lt; MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCajita_1_1Array.html">Array</a>&lt; ArrayScalar, EntityType, <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; MeshScalar, NumSpaceDim &gt;, ArrayParams... &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> Point-to-Grid interpolation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointEvalFunctor</td><td>Functor type used to evaluate the interpolated data for a given point at a given entity. </td></tr>
    <tr><td class="paramname">PointCoordinates</td><td>Container type with view traits containing the point coordinates. Will be indexed as (point,dim). </td></tr>
    <tr><td class="paramname">ArrayScalar</td><td>The scalar type used for the interpolated data. </td></tr>
    <tr><td class="paramname">MeshScalar</td><td>The scalar type used for the geometry/interpolation data. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>The spatial dimension of the mesh. </td></tr>
    <tr><td class="paramname">EntityType</td><td>The entitytype to which the points will interpolate. </td></tr>
    <tr><td class="paramname">SplineOrder</td><td>The order of spline interpolation to use. </td></tr>
    <tr><td class="paramname">MemorySpace</td><td>The memory space to use for interplation </td></tr>
    <tr><td class="paramname">ArrayParams</td><td>Parameters for the array type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>A functor that interpolates from a given point to a given entity. </td></tr>
    <tr><td class="paramname">points</td><td>The points over which to perform the interpolation. Will be indexed as (point,dim). The subset of indices in each point's interpolation stencil must be contained within the local grid that will be used for the interpolation </td></tr>
    <tr><td class="paramname">num_point</td><td>The number of points. This is the size of the first dimension of points. </td></tr>
    <tr><td class="paramname">halo</td><td>The halo associated with the grid array. This hallo will be used to scatter the interpolated data. </td></tr>
    <tr><td class="paramname">array</td><td>The grid array to which the point data will be interpolated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> of SplineOrder passed for interpolation. </dd></dl>

</div>
</div>
<a id="a463fdf70de28bb1d20f9c12944101692" name="a463fdf70de28bb1d20f9c12944101692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463fdf70de28bb1d20f9c12944101692">&#9670;&#160;</a></span>p2g() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class PointEvalFunctor , class PointCoordinates , class ArrayScalar , class MeshScalar , std::size_t NumSpaceDim, class EntityType , int SplineOrder, class MemorySpace , class... ArrayParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::p2g </td>
          <td>(</td>
          <td class="paramtype">ExecutionSpace&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointEvalFunctor &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointCoordinates &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCajita_1_1Spline.html">Spline</a>&lt; SplineOrder &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1Halo.html">Halo</a>&lt; MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCajita_1_1Array.html">Array</a>&lt; ArrayScalar, EntityType, <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; MeshScalar, NumSpaceDim &gt;, ArrayParams... &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> Point-to-Grid interpolation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecutionSpace</td><td>Kokkos execution space. </td></tr>
    <tr><td class="paramname">PointEvalFunctor</td><td>Functor type used to evaluate the interpolated data for a given point at a given entity. </td></tr>
    <tr><td class="paramname">PointCoordinates</td><td>Container type with view traits containing the point coordinates. Will be indexed as (point,dim). </td></tr>
    <tr><td class="paramname">ArrayScalar</td><td>The scalar type used for the interpolated data. </td></tr>
    <tr><td class="paramname">MeshScalar</td><td>The scalar type used for the geometry/interpolation data. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>The spatial dimension of the mesh. </td></tr>
    <tr><td class="paramname">EntityType</td><td>The entitytype to which the points will interpolate. </td></tr>
    <tr><td class="paramname">SplineOrder</td><td>The order of spline interpolation to use. </td></tr>
    <tr><td class="paramname">MemorySpace</td><td>The memory space to use for interplation </td></tr>
    <tr><td class="paramname">ArrayParams</td><td>Parameters for the array type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>A functor that interpolates from a given point to a given entity. </td></tr>
    <tr><td class="paramname">points</td><td>The points over which to perform the interpolation. Will be indexed as (point,dim). The subset of indices in each point's interpolation stencil must be contained within the local grid that will be used for the interpolation </td></tr>
    <tr><td class="paramname">num_point</td><td>The number of points. This is the size of the first dimension of points. </td></tr>
    <tr><td class="paramname">halo</td><td>The halo associated with the grid array. This hallo will be used to scatter the interpolated data. </td></tr>
    <tr><td class="paramname">array</td><td>The grid array to which the point data will be interpolated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> of SplineOrder passed for interpolation. </dd></dl>

</div>
</div>
<a id="adb928c073163bff90d4ca8a7d460fe18" name="adb928c073163bff90d4ca8a7d460fe18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb928c073163bff90d4ca8a7d460fe18">&#9670;&#160;</a></span>particleGridMigrate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalGridType , class ParticlePositions , class ParticleContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Cajita::particleGridMigrate </td>
          <td>(</td>
          <td class="paramtype">const LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParticlePositions &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParticleContainer &amp;&#160;</td>
          <td class="paramname"><em>src_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleContainer &amp;&#160;</td>
          <td class="paramname"><em>dst_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>min_halo_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>force_migrate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrate data from one uniquely-owned decomposition to another uniquely-owned decomposition, using the bounds and periodic boundaries of a <a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> grid to determine which particles should be moved. Separate AoSoA variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LocalGridType</td><td><a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> type. </td></tr>
    <tr><td class="paramname">ParticlePositions</td><td>Particle position type. </td></tr>
    <tr><td class="paramname">ParticleContainer</td><td>AoSoA type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_grid</td><td>The local grid containing periodicity and system bounds. </td></tr>
    <tr><td class="paramname">positions</td><td>Particle positions. </td></tr>
    <tr><td class="paramname">src_particles</td><td>The source particle AoSoA. </td></tr>
    <tr><td class="paramname">dst_particles</td><td>The destination particle AoSoA. </td></tr>
    <tr><td class="paramname">min_halo_width</td><td>Number of halo mesh widths to allow particles before migrating. </td></tr>
    <tr><td class="paramname">force_migrate</td><td>Migrate particles outside the local domain regardless of ghosted halo. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether any particle migration occured. </dd></dl>

</div>
</div>
<a id="af4371257b756699167df4544e4f2de13" name="af4371257b756699167df4544e4f2de13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4371257b756699167df4544e4f2de13">&#9670;&#160;</a></span>particleGridMigrate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalGridType , class ParticlePositions , class ParticleContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Cajita::particleGridMigrate </td>
          <td>(</td>
          <td class="paramtype">const LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParticlePositions &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleContainer &amp;&#160;</td>
          <td class="paramname"><em>particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>min_halo_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>force_migrate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrate data from one uniquely-owned decomposition to another uniquely-owned decomposition, using the bounds and periodic boundaries of a <a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> grid to determine which particles should be moved. In-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LocalGridType</td><td><a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> type. </td></tr>
    <tr><td class="paramname">ParticlePositions</td><td>Particle position type. </td></tr>
    <tr><td class="paramname">PositionContainer</td><td>AoSoA type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_grid</td><td>The local grid containing periodicity and system bounds. </td></tr>
    <tr><td class="paramname">positions</td><td>Particle positions. </td></tr>
    <tr><td class="paramname">particles</td><td>The particle AoSoA. </td></tr>
    <tr><td class="paramname">min_halo_width</td><td>Number of halo mesh widths to allow particles before migrating. </td></tr>
    <tr><td class="paramname">force_migrate</td><td>Migrate particles outside the local domain regardless of ghosted halo. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether any particle migration occured. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
