<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cabana: Cajita Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cabana
   &#160;<span id="projectnumber">1.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Cajita Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a>: grid and particle-grid data structures and algorithms.  
<a href="namespaceCajita.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity layout for array data on the local mesh.  <a href="classCajita_1_1ArrayLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1is__array__layout.html">is_array_layout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCajita_1_1Array.html" title="Array of field data on the local mesh.">Array</a> static type checker.  <a href="structCajita_1_1is__array__layout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1is__array__layout_3_01ArrayLayout_3_01EntityType_00_01MeshType_01_4_01_4.html">is_array_layout&lt; ArrayLayout&lt; EntityType, MeshType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCajita_1_1Array.html" title="Array of field data on the local mesh.">Array</a> static type checker.  <a href="structCajita_1_1is__array__layout_3_01ArrayLayout_3_01EntityType_00_01MeshType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1is__array__layout_3_01const_01ArrayLayout_3_01EntityType_00_01MeshType_01_4_01_4.html">is_array_layout&lt; const ArrayLayout&lt; EntityType, MeshType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCajita_1_1Array.html" title="Array of field data on the local mesh.">Array</a> static type checker.  <a href="structCajita_1_1is__array__layout_3_01const_01ArrayLayout_3_01EntityType_00_01MeshType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1Array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCajita_1_1Array.html" title="Array of field data on the local mesh.">Array</a> of field data on the local mesh.  <a href="classCajita_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1is__array.html">is_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1is__array_3_01Array_3_01Scalar_00_01EntityType_00_01MeshType_00_01Params_8_8_8_01_4_01_4.html">is_array&lt; Array&lt; Scalar, EntityType, MeshType, Params... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1is__array_3_01const_01Array_3_01Scalar_00_01EntityType_00_01MeshType_00_01Params_8_8_8_01_4_01_4.html">is_array&lt; const Array&lt; Scalar, EntityType, MeshType, Params... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> logical grid.  <a href="classCajita_1_1GlobalGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> mesh partial specialization for uniform mesh.  <a href="classCajita_1_1GlobalMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1GlobalMesh_3_01NonUniformMesh_3_01Scalar_00_013_01_4_01_4.html">GlobalMesh&lt; NonUniformMesh&lt; Scalar, 3 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> mesh partial specialization for 3D non-uniform mesh.  <a href="classCajita_1_1GlobalMesh_3_01NonUniformMesh_3_01Scalar_00_013_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1GlobalMesh_3_01NonUniformMesh_3_01Scalar_00_012_01_4_01_4.html">GlobalMesh&lt; NonUniformMesh&lt; Scalar, 2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> mesh partial specialization for 2D non-uniform mesh.  <a href="classCajita_1_1GlobalMesh_3_01NonUniformMesh_3_01Scalar_00_012_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HaloPattern.html">HaloPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base halo exchange pattern class.  <a href="classCajita_1_1HaloPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1NodeHaloPattern.html">NodeHaloPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1NodeHaloPattern_3_013_01_4.html">NodeHaloPattern&lt; 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1NodeHaloPattern_3_012_01_4.html">NodeHaloPattern&lt; 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1FaceHaloPattern.html">FaceHaloPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1FaceHaloPattern_3_013_01_4.html">FaceHaloPattern&lt; 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1FaceHaloPattern_3_012_01_4.html">FaceHaloPattern&lt; 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1FullHaloPattern.html">FullHaloPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full 3d halo with all 26 adjacent blocks. Backwards compatibility wrapper.  <a href="classCajita_1_1FullHaloPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1Halo.html">Halo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1ArrayPackMemorySpace.html">ArrayPackMemorySpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer array memory space.  <a href="structCajita_1_1ArrayPackMemorySpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1LayoutAdapter.html">LayoutAdapter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1HypreIsCompatibleWithMemorySpace.html">HypreIsCompatibleWithMemorySpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hypre device compatibility check.  <a href="structCajita_1_1HypreIsCompatibleWithMemorySpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1HypreIsCompatibleWithMemorySpace_3_01Kokkos_1_1HostSpace_01_4.html">HypreIsCompatibleWithMemorySpace&lt; Kokkos::HostSpace &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hypre device compatibility check - host memory.  <a href="structCajita_1_1HypreIsCompatibleWithMemorySpace_3_01Kokkos_1_1HostSpace_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructuredSolver.html">HypreStructuredSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hypre structured solver interface for scalar fields.  <a href="classCajita_1_1HypreStructuredSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructPCG.html">HypreStructPCG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PCG solver.  <a href="classCajita_1_1HypreStructPCG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructGMRES.html">HypreStructGMRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GMRES solver.  <a href="classCajita_1_1HypreStructGMRES.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructBiCGSTAB.html">HypreStructBiCGSTAB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">BiCGSTAB solver.  <a href="classCajita_1_1HypreStructBiCGSTAB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructPFMG.html">HypreStructPFMG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PFMG solver.  <a href="classCajita_1_1HypreStructPFMG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructSMG.html">HypreStructSMG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMG solver.  <a href="classCajita_1_1HypreStructSMG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructJacobi.html">HypreStructJacobi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi solver.  <a href="classCajita_1_1HypreStructJacobi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1HypreStructDiagonal.html">HypreStructDiagonal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonal preconditioner.  <a href="classCajita_1_1HypreStructDiagonal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structured index space.  <a href="classCajita_1_1IndexSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1ScalarValueG2P.html">ScalarValueG2P</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid-to-point scalar value functor.  <a href="structCajita_1_1ScalarValueG2P.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1VectorValueG2P.html">VectorValueG2P</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid-to-point vector value functor.  <a href="structCajita_1_1VectorValueG2P.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1ScalarGradientG2P.html">ScalarGradientG2P</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid-to-point scalar gradient functor.  <a href="structCajita_1_1ScalarGradientG2P.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1VectorGradientG2P.html">VectorGradientG2P</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid-to-point vector gradient functor.  <a href="structCajita_1_1VectorGradientG2P.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1VectorDivergenceG2P.html">VectorDivergenceG2P</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid-to-point vector value functor.  <a href="structCajita_1_1VectorDivergenceG2P.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1ScalarValueP2G.html">ScalarValueP2G</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point-to-grid scalar value functor.  <a href="structCajita_1_1ScalarValueP2G.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1VectorValueP2G.html">VectorValueP2G</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point-to-grid vector value functor.  <a href="structCajita_1_1VectorValueP2G.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1ScalarGradientP2G.html">ScalarGradientP2G</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point-to-grid scalar gradient functor.  <a href="structCajita_1_1ScalarGradientP2G.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1VectorDivergenceP2G.html">VectorDivergenceP2G</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point-to-grid vector divergence functor.  <a href="structCajita_1_1VectorDivergenceP2G.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1TensorDivergenceP2G.html">TensorDivergenceP2G</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point-to-grid tensor divergence functor.  <a href="structCajita_1_1TensorDivergenceP2G.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Local.html" title="Local index tag.">Local</a> logical grid.  <a href="classCajita_1_1LocalGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1LocalMesh.html">LocalMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1LocalMesh_3_01Device_00_01UniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">LocalMesh&lt; Device, UniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Local.html" title="Local index tag.">Local</a> mesh partial specialization for uniform mesh.  <a href="classCajita_1_1LocalMesh_3_01Device_00_01UniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1LocalMesh_3_01Device_00_01NonUniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">LocalMesh&lt; Device, NonUniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> mesh partial specialization for non-uniform mesh.  <a href="classCajita_1_1LocalMesh_3_01Device_00_01NonUniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1ManualPartitioner.html">ManualPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backwards compatibility wrapper for 3D <a class="el" href="classCajita_1_1ManualBlockPartitioner.html" title="Manual block partitioner.">ManualBlockPartitioner</a>.  <a href="classCajita_1_1ManualPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1MpiTraits.html">MpiTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1MpiTraits_3_01char_01_4.html">MpiTraits&lt; char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI type trait.  <a href="structCajita_1_1MpiTraits_3_01char_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1MpiTraits_3_01int_01_4.html">MpiTraits&lt; int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI type trait.  <a href="structCajita_1_1MpiTraits_3_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1MpiTraits_3_01long_01_4.html">MpiTraits&lt; long &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI type trait.  <a href="structCajita_1_1MpiTraits_3_01long_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1MpiTraits_3_01float_01_4.html">MpiTraits&lt; float &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI type trait.  <a href="structCajita_1_1MpiTraits_3_01float_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1MpiTraits_3_01double_01_4.html">MpiTraits&lt; double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI type trait.  <a href="structCajita_1_1MpiTraits_3_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1BlockPartitioner.html">BlockPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block partitioner base class.  <a href="classCajita_1_1BlockPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1ManualBlockPartitioner.html">ManualBlockPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manual block partitioner.  <a href="classCajita_1_1ManualBlockPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1DimBlockPartitioner.html">DimBlockPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension-only partitioner.  <a href="classCajita_1_1DimBlockPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1ReferenceStructuredSolver.html">ReferenceStructuredSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference preconditioned structured solver interface.  <a href="classCajita_1_1ReferenceStructuredSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1ReferenceConjugateGradient.html">ReferenceConjugateGradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference structured preconditioned block conjugate gradient implementation.  <a href="classCajita_1_1ReferenceConjugateGradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1SparseDimPartitioner.html">SparseDimPartitioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1TileID2HashKey.html">TileID2HashKey</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1HashKey2TileID.html">HashKey2TileID</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1TileID2HashKey_3_01Key_00_01HashTypes_1_1Naive_01_4.html">TileID2HashKey&lt; Key, HashTypes::Naive &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hash key from the 3D tile ijk.  <a href="structCajita_1_1TileID2HashKey_3_01Key_00_01HashTypes_1_1Naive_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1TileID2HashKey_3_01Key_00_01HashTypes_1_1Morton_01_4.html">TileID2HashKey&lt; Key, HashTypes::Morton &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hash key from the 3D tile ijk.  <a href="structCajita_1_1TileID2HashKey_3_01Key_00_01HashTypes_1_1Morton_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1HashKey2TileID_3_01Key_00_01HashTypes_1_1Naive_01_4.html">HashKey2TileID&lt; Key, HashTypes::Naive &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D tile ijk from the hash key.  <a href="structCajita_1_1HashKey2TileID_3_01Key_00_01HashTypes_1_1Naive_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1HashKey2TileID_3_01Key_00_01HashTypes_1_1Morton_01_4.html">HashKey2TileID&lt; Key, HashTypes::Morton &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D tile ijk from the hash key.  <a href="structCajita_1_1HashKey2TileID_3_01Key_00_01HashTypes_1_1Morton_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1BlockMap.html">BlockMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of <a class="el" href="classCajita_1_1BlockMap.html" title="Declaration of BlockMap.">BlockMap</a>.  <a href="classCajita_1_1BlockMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1TileMap.html">TileMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of <a class="el" href="classCajita_1_1TileMap.html" title="Declaration of TileMap.">TileMap</a>.  <a href="classCajita_1_1TileMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1SparseMap.html">SparseMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse index space, with a hierarchical structure (cell-&gt;tile-&gt;block)  <a href="classCajita_1_1SparseMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1TileIndexSpace.html">TileIndexSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index space with tile as unit; _min and _max forms the tile range. Note this is for sparse grid only, mainly used in sparse halo impl.  <a href="classCajita_1_1TileIndexSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Spline.html">Spline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">B-Spline interface for uniform grids.  <a href="structCajita_1_1Spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Spline_3_010_01_4.html">Spline&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-order (Nearest Grid Point Interpolation). Defined on the dual grid.  <a href="structCajita_1_1Spline_3_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Spline_3_011_01_4.html">Spline&lt; 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear. Defined on the primal grid.  <a href="structCajita_1_1Spline_3_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Spline_3_012_01_4.html">Spline&lt; 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quadratic. Defined on the dual grid.  <a href="structCajita_1_1Spline_3_012_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Spline_3_013_01_4.html">Spline&lt; 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cubic. Defined on the primal grid.  <a href="structCajita_1_1Spline_3_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplinePhysicalCellSize.html">SplinePhysicalCellSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data tag: physical cell size.  <a href="structCajita_1_1SplinePhysicalCellSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineLogicalPosition.html">SplineLogicalPosition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data tag: logical position.  <a href="structCajita_1_1SplineLogicalPosition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplinePhysicalDistance.html">SplinePhysicalDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data tag: physical distance.  <a href="structCajita_1_1SplinePhysicalDistance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineWeightValues.html">SplineWeightValues</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data tag: weight value.  <a href="structCajita_1_1SplineWeightValues.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineWeightPhysicalGradients.html">SplineWeightPhysicalGradients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data tag: physical gradient.  <a href="structCajita_1_1SplineWeightPhysicalGradients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineDataMemberTypes.html">SplineDataMemberTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data members holder.  <a href="structCajita_1_1SplineDataMemberTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1has__spline__tag.html">has_spline_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a given spline tag is present.  <a href="structCajita_1_1has__spline__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineDataMember.html">SplineDataMember</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data member.  <a href="structCajita_1_1SplineDataMember.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplinePhysicalCellSize_01_4.html">SplineDataMember&lt; Scalar, Order, NumSpaceDim, SplinePhysicalCellSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical cell size spline data member.  <a href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplinePhysicalCellSize_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplineLogicalPosition_01_4.html">SplineDataMember&lt; Scalar, Order, NumSpaceDim, SplineLogicalPosition &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical position spline data member.  <a href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplineLogicalPosition_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplinePhysicalDistance_01_4.html">SplineDataMember&lt; Scalar, Order, NumSpaceDim, SplinePhysicalDistance &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical distance spline data member.  <a href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplinePhysicalDistance_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplineWeightValues_01_4.html">SplineDataMember&lt; Scalar, Order, NumSpaceDim, SplineWeightValues &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weight values spline data member.  <a href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplineWeightValues_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplineWeightPhysicalGradients_01_4.html">SplineDataMember&lt; Scalar, Order, NumSpaceDim, SplineWeightPhysicalGradients &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weight physical gradients spline data member.  <a href="structCajita_1_1SplineDataMember_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01SplineWeightPhysicalGradients_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineData.html">SplineData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> data container.  <a href="structCajita_1_1SplineData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineData_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01EntityType_00_01void_01_4.html">SplineData&lt; Scalar, Order, NumSpaceDim, EntityType, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default of void has all data members.  <a href="structCajita_1_1SplineData_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01EntityType_00_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SplineData_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01EntityType_00_01SplineDatdd11f66e3f203bad116bc3594e5b35d6.html">SplineData&lt; Scalar, Order, NumSpaceDim, EntityType, SplineDataMemberTypes&lt; Tags... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify each data member individually through tags.  <a href="structCajita_1_1SplineData_3_01Scalar_00_01Order_00_01NumSpaceDim_00_01EntityType_00_01SplineDatdd11f66e3f203bad116bc3594e5b35d6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Dim.html">Dim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical dimension index.  <a href="structCajita_1_1Dim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Cell.html">Cell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh cell tag.  <a href="structCajita_1_1Cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh node tag.  <a href="structCajita_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Face.html">Face</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh face tag.  <a href="structCajita_1_1Face.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Face_3_01Dim_1_1I_01_4.html">Face&lt; Dim::I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I-face tag.  <a href="structCajita_1_1Face_3_01Dim_1_1I_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Face_3_01Dim_1_1J_01_4.html">Face&lt; Dim::J &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">J-face tag.  <a href="structCajita_1_1Face_3_01Dim_1_1J_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Face_3_01Dim_1_1K_01_4.html">Face&lt; Dim::K &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">K-face tag.  <a href="structCajita_1_1Face_3_01Dim_1_1K_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh edge tag.  <a href="structCajita_1_1Edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Edge_3_01Dim_1_1I_01_4.html">Edge&lt; Dim::I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I-edge tag.  <a href="structCajita_1_1Edge_3_01Dim_1_1I_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Edge_3_01Dim_1_1J_01_4.html">Edge&lt; Dim::J &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">J-edge tag.  <a href="structCajita_1_1Edge_3_01Dim_1_1J_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Edge_3_01Dim_1_1K_01_4.html">Edge&lt; Dim::K &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">K-edge tag.  <a href="structCajita_1_1Edge_3_01Dim_1_1K_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isCell.html">isCell</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isCell_3_01Cell_01_4.html">isCell&lt; Cell &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isCell_3_01const_01Cell_01_4.html">isCell&lt; const Cell &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isNode.html">isNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isNode_3_01Node_01_4.html">isNode&lt; Node &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isNode_3_01const_01Node_01_4.html">isNode&lt; const Node &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isFace.html">isFace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isFace_3_01Face_3_01Dir_01_4_01_4.html">isFace&lt; Face&lt; Dir &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isFace_3_01const_01Face_3_01Dir_01_4_01_4.html">isFace&lt; const Face&lt; Dir &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isEdge.html">isEdge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isEdge_3_01Edge_3_01Dir_01_4_01_4.html">isEdge&lt; Edge&lt; Dir &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isEdge_3_01const_01Edge_3_01Dir_01_4_01_4.html">isEdge&lt; const Edge&lt; Dir &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Own.html">Own</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owned decomposition tag.  <a href="structCajita_1_1Own.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Ghost.html">Ghost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ghosted decomposition tag.  <a href="structCajita_1_1Ghost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Local.html">Local</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Local.html" title="Local index tag.">Local</a> index tag.  <a href="structCajita_1_1Local.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1Global.html">Global</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> index tag.  <a href="structCajita_1_1Global.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform mesh tag.  <a href="structCajita_1_1UniformMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1NonUniformMesh.html">NonUniformMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-uniform mesh tag.  <a href="structCajita_1_1NonUniformMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse mesh tag.  <a href="structCajita_1_1SparseMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isMeshType.html">isMeshType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isMeshType_3_01UniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isMeshType&lt; UniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isMeshType_3_01const_01UniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isMeshType&lt; const UniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isMeshType_3_01NonUniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isMeshType&lt; NonUniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isMeshType_3_01const_01NonUniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isMeshType&lt; const NonUniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isMeshType_3_01SparseMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isMeshType&lt; SparseMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isMeshType_3_01const_01SparseMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isMeshType&lt; const SparseMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isUniformMesh.html">isUniformMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isUniformMesh_3_01UniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isUniformMesh&lt; UniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isUniformMesh_3_01const_01UniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isUniformMesh&lt; const UniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isNonUniformMesh.html">isNonUniformMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isNonUniformMesh_3_01NonUniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isNonUniformMesh&lt; NonUniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isNonUniformMesh_3_01const_01NonUniformMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isNonUniformMesh&lt; const NonUniformMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isSparseMesh.html">isSparseMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isSparseMesh_3_01SparseMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isSparseMesh&lt; SparseMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCajita_1_1isSparseMesh_3_01const_01SparseMesh_3_01Scalar_00_01NumSpaceDim_01_4_01_4.html">isSparseMesh&lt; const SparseMesh&lt; Scalar, NumSpaceDim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCajita_1_1UniformDimPartitioner.html">UniformDimPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backwards compatibility wrapper for 3D <a class="el" href="classCajita_1_1DimBlockPartitioner.html" title="Dimension-only partitioner.">DimBlockPartitioner</a>.  <a href="classCajita_1_1UniformDimPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2ec822f40e278e94dbe22325c2b4c824"><td class="memItemLeft" align="right" valign="top"><a id="a2ec822f40e278e94dbe22325c2b4c824"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a2ec822f40e278e94dbe22325c2b4c824">HashTypes</a> : unsigned char { <b>Naive</b> = 0
, <b>Morton</b> = 1
 }</td></tr>
<tr class="memdesc:a2ec822f40e278e94dbe22325c2b4c824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash table type tag. <br /></td></tr>
<tr class="separator:a2ec822f40e278e94dbe22325c2b4c824"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abdd3b143d333ec6a5d5018c2caa38598"><td class="memTemplParams" colspan="2">template&lt;class EntityType , class MeshType &gt; </td></tr>
<tr class="memitem:abdd3b143d333ec6a5d5018c2caa38598"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#abdd3b143d333ec6a5d5018c2caa38598">createArrayLayout</a> (const std::shared_ptr&lt; <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt;&gt; &amp;local_grid, const int dofs_per_entity, EntityType)</td></tr>
<tr class="memdesc:abdd3b143d333ec6a5d5018c2caa38598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array layout over the entities of a local grid.  <a href="namespaceCajita.html#abdd3b143d333ec6a5d5018c2caa38598">More...</a><br /></td></tr>
<tr class="separator:abdd3b143d333ec6a5d5018c2caa38598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4862d96b1f56f8b0fc0a1a7fb7aff52"><td class="memTemplParams" colspan="2">template&lt;class EntityType , class MeshType &gt; </td></tr>
<tr class="memitem:ae4862d96b1f56f8b0fc0a1a7fb7aff52"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ae4862d96b1f56f8b0fc0a1a7fb7aff52">createArrayLayout</a> (const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt; MeshType &gt;&gt; &amp;global_grid, const int halo_cell_width, const int dofs_per_entity, EntityType)</td></tr>
<tr class="memdesc:ae4862d96b1f56f8b0fc0a1a7fb7aff52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array layout over the entities of a grid given local grid parameters. An intermediate local grid will be created and assigned to the layout.  <a href="namespaceCajita.html#ae4862d96b1f56f8b0fc0a1a7fb7aff52">More...</a><br /></td></tr>
<tr class="separator:ae4862d96b1f56f8b0fc0a1a7fb7aff52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e3a9510cf15e741a56e55216dae684"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params, class EntityType , class MeshType &gt; </td></tr>
<tr class="memitem:aa5e3a9510cf15e741a56e55216dae684"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aa5e3a9510cf15e741a56e55216dae684">createArray</a> (const std::string &amp;label, const std::shared_ptr&lt; <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt;&gt; &amp;layout)</td></tr>
<tr class="memdesc:aa5e3a9510cf15e741a56e55216dae684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array with the given array layout. Views are constructed over the ghosted index space of the layout.  <a href="namespaceCajita.html#aa5e3a9510cf15e741a56e55216dae684">More...</a><br /></td></tr>
<tr class="separator:aa5e3a9510cf15e741a56e55216dae684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bb56f113356a47470331f61420fb17"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class EntityType , class MeshType , class... Params&gt; </td></tr>
<tr class="memitem:aa0bb56f113356a47470331f61420fb17"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, typename <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt;::subview_layout, typename <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt;::device_type, typename <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt;::subview_memory_traits &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aa0bb56f113356a47470331f61420fb17">createSubarray</a> (const <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt; &amp;array, const int dof_min, const int dof_max)</td></tr>
<tr class="memdesc:aa0bb56f113356a47470331f61420fb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a subarray of the given array over the given range of degrees of freedom.  <a href="namespaceCajita.html#aa0bb56f113356a47470331f61420fb17">More...</a><br /></td></tr>
<tr class="separator:aa0bb56f113356a47470331f61420fb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06dbf84ec637409b417a596ec6a6ca9"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:aa06dbf84ec637409b417a596ec6a6ca9"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt; MeshType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aa06dbf84ec637409b417a596ec6a6ca9">createGlobalGrid</a> (MPI_Comm comm, const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; MeshType &gt;&gt; &amp;global_mesh, const std::array&lt; bool, MeshType::num_space_dim &gt; &amp;periodic, const <a class="el" href="classCajita_1_1BlockPartitioner.html">BlockPartitioner</a>&lt; MeshType::num_space_dim &gt; &amp;partitioner)</td></tr>
<tr class="memdesc:aa06dbf84ec637409b417a596ec6a6ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global grid.  <a href="namespaceCajita.html#aa06dbf84ec637409b417a596ec6a6ca9">More...</a><br /></td></tr>
<tr class="separator:aa06dbf84ec637409b417a596ec6a6ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b25f6703877713696291543bb12b1b1"><td class="memTemplParams" colspan="2">template&lt;class Scalar , std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:a4b25f6703877713696291543bb12b1b1"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a4b25f6703877713696291543bb12b1b1">createGlobalGrid</a> (MPI_Comm comm, const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt;&gt;&gt; &amp;global_mesh, const std::array&lt; bool, <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt;::num_space_dim &gt; &amp;periodic, const <a class="el" href="classCajita_1_1BlockPartitioner.html">BlockPartitioner</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt;::num_space_dim &gt; &amp;partitioner)</td></tr>
<tr class="memdesc:a4b25f6703877713696291543bb12b1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sparse global grid.  <a href="namespaceCajita.html#a4b25f6703877713696291543bb12b1b1">More...</a><br /></td></tr>
<tr class="separator:a4b25f6703877713696291543bb12b1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f262a89b1f8f46287b3fdff3e4af246"><td class="memTemplParams" colspan="2">template&lt;class Scalar , std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:a6f262a89b1f8f46287b3fdff3e4af246"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a6f262a89b1f8f46287b3fdff3e4af246">createUniformGlobalMesh</a> (const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_low_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_high_corner, const Scalar cell_size)</td></tr>
<tr class="memdesc:a6f262a89b1f8f46287b3fdff3e4af246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create uniform mesh with uniform cell size.  <a href="namespaceCajita.html#a6f262a89b1f8f46287b3fdff3e4af246">More...</a><br /></td></tr>
<tr class="separator:a6f262a89b1f8f46287b3fdff3e4af246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fe9a0a1819d0b6066f0a562e9b77b1"><td class="memTemplParams" colspan="2">template&lt;class Scalar , std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:a21fe9a0a1819d0b6066f0a562e9b77b1"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a21fe9a0a1819d0b6066f0a562e9b77b1">createUniformGlobalMesh</a> (const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_low_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_high_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;cell_size)</td></tr>
<tr class="memdesc:a21fe9a0a1819d0b6066f0a562e9b77b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create uniform mesh with uniform cell size.  <a href="namespaceCajita.html#a21fe9a0a1819d0b6066f0a562e9b77b1">More...</a><br /></td></tr>
<tr class="separator:a21fe9a0a1819d0b6066f0a562e9b77b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6aa1db126fd8f20c06d5f67a92072c"><td class="memTemplParams" colspan="2">template&lt;class Scalar , std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:abf6aa1db126fd8f20c06d5f67a92072c"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#abf6aa1db126fd8f20c06d5f67a92072c">createUniformGlobalMesh</a> (const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_low_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_high_corner, const std::array&lt; int, NumSpaceDim &gt; &amp;global_num_cell)</td></tr>
<tr class="memdesc:abf6aa1db126fd8f20c06d5f67a92072c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create uniform mesh with total number of cells.  <a href="namespaceCajita.html#abf6aa1db126fd8f20c06d5f67a92072c">More...</a><br /></td></tr>
<tr class="separator:abf6aa1db126fd8f20c06d5f67a92072c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4da2b8bb6f203ccfff9697acf0608a5"><td class="memTemplParams" colspan="2">template&lt;class Scalar , std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:ab4da2b8bb6f203ccfff9697acf0608a5"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ab4da2b8bb6f203ccfff9697acf0608a5">createSparseGlobalMesh</a> (const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_low_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_high_corner, const Scalar cell_size)</td></tr>
<tr class="memdesc:ab4da2b8bb6f203ccfff9697acf0608a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create sparse mesh with uniform cell size.  <a href="namespaceCajita.html#ab4da2b8bb6f203ccfff9697acf0608a5">More...</a><br /></td></tr>
<tr class="separator:ab4da2b8bb6f203ccfff9697acf0608a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d0772abdde612f1f5967f6253f9a93"><td class="memTemplParams" colspan="2">template&lt;class Scalar , std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:a03d0772abdde612f1f5967f6253f9a93"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a03d0772abdde612f1f5967f6253f9a93">createSparseGlobalMesh</a> (const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_low_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_high_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;cell_size)</td></tr>
<tr class="memdesc:a03d0772abdde612f1f5967f6253f9a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create sparse mesh with uniform cell size.  <a href="namespaceCajita.html#a03d0772abdde612f1f5967f6253f9a93">More...</a><br /></td></tr>
<tr class="separator:a03d0772abdde612f1f5967f6253f9a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56eddf41d0e79c6542ab1fca024ddf84"><td class="memTemplParams" colspan="2">template&lt;class Scalar , std::size_t NumSpaceDim&gt; </td></tr>
<tr class="memitem:a56eddf41d0e79c6542ab1fca024ddf84"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a56eddf41d0e79c6542ab1fca024ddf84">createSparseGlobalMesh</a> (const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_low_corner, const std::array&lt; Scalar, NumSpaceDim &gt; &amp;global_high_corner, const std::array&lt; int, NumSpaceDim &gt; &amp;global_num_cell)</td></tr>
<tr class="memdesc:a56eddf41d0e79c6542ab1fca024ddf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create sparse mesh with total number of cells.  <a href="namespaceCajita.html#a56eddf41d0e79c6542ab1fca024ddf84">More...</a><br /></td></tr>
<tr class="separator:a56eddf41d0e79c6542ab1fca024ddf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f0dcbfa11d396fa8781e0889c9f198"><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:af3f0dcbfa11d396fa8781e0889c9f198"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1NonUniformMesh.html">NonUniformMesh</a>&lt; Scalar, 3 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#af3f0dcbfa11d396fa8781e0889c9f198">createNonUniformGlobalMesh</a> (const std::vector&lt; Scalar &gt; &amp;i_edges, const std::vector&lt; Scalar &gt; &amp;j_edges, const std::vector&lt; Scalar &gt; &amp;k_edges)</td></tr>
<tr class="memdesc:af3f0dcbfa11d396fa8781e0889c9f198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a non-uniform 3D mesh.  <a href="namespaceCajita.html#af3f0dcbfa11d396fa8781e0889c9f198">More...</a><br /></td></tr>
<tr class="separator:af3f0dcbfa11d396fa8781e0889c9f198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c460981e8fbe2e584407054167ede2"><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:ae0c460981e8fbe2e584407054167ede2"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1NonUniformMesh.html">NonUniformMesh</a>&lt; Scalar, 2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ae0c460981e8fbe2e584407054167ede2">createNonUniformGlobalMesh</a> (const std::vector&lt; Scalar &gt; &amp;i_edges, const std::vector&lt; Scalar &gt; &amp;j_edges)</td></tr>
<tr class="memdesc:ae0c460981e8fbe2e584407054167ede2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a non-uniform 2D mesh.  <a href="namespaceCajita.html#ae0c460981e8fbe2e584407054167ede2">More...</a><br /></td></tr>
<tr class="separator:ae0c460981e8fbe2e584407054167ede2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047ee0472b03e9ef8798fc34f110c28d"><td class="memTemplParams" colspan="2">template&lt;class Pattern , class... ArrayTypes&gt; </td></tr>
<tr class="memitem:a047ee0472b03e9ef8798fc34f110c28d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a047ee0472b03e9ef8798fc34f110c28d">createHalo</a> (const Pattern &amp;pattern, const int width, const ArrayTypes &amp;... arrays)</td></tr>
<tr class="memdesc:a047ee0472b03e9ef8798fc34f110c28d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCajita_1_1Array.html" title="Array of field data on the local mesh.">Array</a> creation function.  <a href="namespaceCajita.html#a047ee0472b03e9ef8798fc34f110c28d">More...</a><br /></td></tr>
<tr class="separator:a047ee0472b03e9ef8798fc34f110c28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8e3f33f12e80ce359f1d4840ee641c"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class Device , class EntityType , class MeshType , class Pattern &gt; </td></tr>
<tr class="memitem:abb8e3f33f12e80ce359f1d4840ee641c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#abb8e3f33f12e80ce359f1d4840ee641c">createHalo</a> (const <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &amp;layout, const Pattern &amp;pattern, const int width=-1)</td></tr>
<tr class="memdesc:abb8e3f33f12e80ce359f1d4840ee641c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a halo with a layout.  <a href="namespaceCajita.html#abb8e3f33f12e80ce359f1d4840ee641c">More...</a><br /></td></tr>
<tr class="separator:abb8e3f33f12e80ce359f1d4840ee641c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342119f5d5b011c689cc474e16cc70e5"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class EntityType , class MeshType , class Pattern , class... Params&gt; </td></tr>
<tr class="memitem:a342119f5d5b011c689cc474e16cc70e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a342119f5d5b011c689cc474e16cc70e5">createHalo</a> (const <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt; &amp;array, const Pattern &amp;pattern, const int width=-1)</td></tr>
<tr class="memdesc:a342119f5d5b011c689cc474e16cc70e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a halo.  <a href="namespaceCajita.html#a342119f5d5b011c689cc474e16cc70e5">More...</a><br /></td></tr>
<tr class="separator:a342119f5d5b011c689cc474e16cc70e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574cd0b7a3a3aa8c0d986e923318f1f7"><td class="memTemplParams" colspan="2"><a id="a574cd0b7a3a3aa8c0d986e923318f1f7"></a>
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a574cd0b7a3a3aa8c0d986e923318f1f7"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructPCG.html">HypreStructPCG</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a574cd0b7a3a3aa8c0d986e923318f1f7">createHypreStructPCG</a> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="memdesc:a574cd0b7a3a3aa8c0d986e923318f1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HYPRE PCG structured solver. <br /></td></tr>
<tr class="separator:a574cd0b7a3a3aa8c0d986e923318f1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221456b40b7ff148b23d9a02ff28a91c"><td class="memTemplParams" colspan="2"><a id="a221456b40b7ff148b23d9a02ff28a91c"></a>
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a221456b40b7ff148b23d9a02ff28a91c"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructGMRES.html">HypreStructGMRES</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a221456b40b7ff148b23d9a02ff28a91c">createHypreStructGMRES</a> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="memdesc:a221456b40b7ff148b23d9a02ff28a91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HYPRE GMRES structured solver. <br /></td></tr>
<tr class="separator:a221456b40b7ff148b23d9a02ff28a91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf857f7d6cc758205b43ded0b9898354"><td class="memTemplParams" colspan="2"><a id="acf857f7d6cc758205b43ded0b9898354"></a>
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:acf857f7d6cc758205b43ded0b9898354"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructBiCGSTAB.html">HypreStructBiCGSTAB</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#acf857f7d6cc758205b43ded0b9898354">createHypreStructBiCGSTAB</a> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="memdesc:acf857f7d6cc758205b43ded0b9898354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HYPRE BiCGSTAB structured solver. <br /></td></tr>
<tr class="separator:acf857f7d6cc758205b43ded0b9898354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2681950720576219f689631e6d3f6c27"><td class="memTemplParams" colspan="2"><a id="a2681950720576219f689631e6d3f6c27"></a>
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a2681950720576219f689631e6d3f6c27"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructPFMG.html">HypreStructPFMG</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a2681950720576219f689631e6d3f6c27">createHypreStructPFMG</a> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="memdesc:a2681950720576219f689631e6d3f6c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HYPRE PFMG structured solver. <br /></td></tr>
<tr class="separator:a2681950720576219f689631e6d3f6c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a3322645bb367b395fec9d2b86d1bb"><td class="memTemplParams" colspan="2"><a id="af9a3322645bb367b395fec9d2b86d1bb"></a>
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:af9a3322645bb367b395fec9d2b86d1bb"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructSMG.html">HypreStructSMG</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#af9a3322645bb367b395fec9d2b86d1bb">createHypreStructSMG</a> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="memdesc:af9a3322645bb367b395fec9d2b86d1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HYPRE SMG structured solver. <br /></td></tr>
<tr class="separator:af9a3322645bb367b395fec9d2b86d1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d1c8eba8a038b09b1f3a29d6b4295a"><td class="memTemplParams" colspan="2"><a id="a17d1c8eba8a038b09b1f3a29d6b4295a"></a>
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:a17d1c8eba8a038b09b1f3a29d6b4295a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructJacobi.html">HypreStructJacobi</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a17d1c8eba8a038b09b1f3a29d6b4295a">createHypreStructJacobi</a> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="memdesc:a17d1c8eba8a038b09b1f3a29d6b4295a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HYPRE Jacobi structured solver. <br /></td></tr>
<tr class="separator:a17d1c8eba8a038b09b1f3a29d6b4295a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75643856ff65086f505a912a5361130"><td class="memTemplParams" colspan="2"><a id="ad75643856ff65086f505a912a5361130"></a>
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:ad75643856ff65086f505a912a5361130"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructDiagonal.html">HypreStructDiagonal</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ad75643856ff65086f505a912a5361130">createHypreStructDiagonal</a> (const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="memdesc:ad75643856ff65086f505a912a5361130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HYPRE Diagonal structured solver. <br /></td></tr>
<tr class="separator:ad75643856ff65086f505a912a5361130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51f1159278d5b5023615af31744bcf0"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </td></tr>
<tr class="memitem:aa51f1159278d5b5023615af31744bcf0"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1HypreStructuredSolver.html">HypreStructuredSolver</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aa51f1159278d5b5023615af31744bcf0">createHypreStructuredSolver</a> (const std::string &amp;solver_type, const ArrayLayout_t &amp;layout, const bool is_preconditioner=false)</td></tr>
<tr class="memdesc:aa51f1159278d5b5023615af31744bcf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HYPRE structured solver.  <a href="namespaceCajita.html#aa51f1159278d5b5023615af31744bcf0">More...</a><br /></td></tr>
<tr class="separator:aa51f1159278d5b5023615af31744bcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d70326b11175c3b3111b3e544d002b3"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace &gt; </td></tr>
<tr class="memitem:a1d70326b11175c3b3111b3e544d002b3"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::RangePolicy&lt; ExecutionSpace &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a1d70326b11175c3b3111b3e544d002b3">createExecutionPolicy</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;index_space, const ExecutionSpace &amp;)</td></tr>
<tr class="memdesc:a1d70326b11175c3b3111b3e544d002b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a multi-dimensional execution policy over an index space.  <a href="namespaceCajita.html#a1d70326b11175c3b3111b3e544d002b3">More...</a><br /></td></tr>
<tr class="separator:a1d70326b11175c3b3111b3e544d002b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9a2b5e43eb54a1ddc81c0522ab25a4"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class WorkTag &gt; </td></tr>
<tr class="memitem:a3d9a2b5e43eb54a1ddc81c0522ab25a4"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::RangePolicy&lt; ExecutionSpace, WorkTag &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a3d9a2b5e43eb54a1ddc81c0522ab25a4">createExecutionPolicy</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;index_space, const ExecutionSpace &amp;, const WorkTag &amp;)</td></tr>
<tr class="memdesc:a3d9a2b5e43eb54a1ddc81c0522ab25a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a multi-dimensional execution policy over an index space.  <a href="namespaceCajita.html#a3d9a2b5e43eb54a1ddc81c0522ab25a4">More...</a><br /></td></tr>
<tr class="separator:a3d9a2b5e43eb54a1ddc81c0522ab25a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fe7af159514bec736fc22fcda68bff"><td class="memTemplParams" colspan="2"><a id="a69fe7af159514bec736fc22fcda68bff"></a>
template&lt;class IndexSpace_t , class ExecutionSpace &gt; </td></tr>
<tr class="memitem:a69fe7af159514bec736fc22fcda68bff"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::MDRangePolicy&lt; ExecutionSpace, Kokkos::Rank&lt; IndexSpace_t::Rank &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a69fe7af159514bec736fc22fcda68bff">createExecutionPolicy</a> (const IndexSpace_t &amp;index_space, const ExecutionSpace &amp;)</td></tr>
<tr class="memdesc:a69fe7af159514bec736fc22fcda68bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a multi-dimensional execution policy over an index space. <br /></td></tr>
<tr class="separator:a69fe7af159514bec736fc22fcda68bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b37484bec59309a24f0b7feeecfbaa8"><td class="memTemplParams" colspan="2"><a id="a6b37484bec59309a24f0b7feeecfbaa8"></a>
template&lt;class IndexSpace_t , class ExecutionSpace , class WorkTag &gt; </td></tr>
<tr class="memitem:a6b37484bec59309a24f0b7feeecfbaa8"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::MDRangePolicy&lt; ExecutionSpace, WorkTag, Kokkos::Rank&lt; IndexSpace_t::Rank &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a6b37484bec59309a24f0b7feeecfbaa8">createExecutionPolicy</a> (const IndexSpace_t &amp;index_space, const ExecutionSpace &amp;, const WorkTag &amp;)</td></tr>
<tr class="memdesc:a6b37484bec59309a24f0b7feeecfbaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a multi-dimensional execution policy over an index space with a work tag. <br /></td></tr>
<tr class="separator:a6b37484bec59309a24f0b7feeecfbaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d5b9427668544de95ae7e1754fbdf2"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:a99d5b9427668544de95ae7e1754fbdf2"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar *, Params... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a99d5b9427668544de95ae7e1754fbdf2">createView</a> (const std::string &amp;label, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;index_space)</td></tr>
<tr class="memdesc:a99d5b9427668544de95ae7e1754fbdf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space create a view over the extent of that index space.  <a href="namespaceCajita.html#a99d5b9427668544de95ae7e1754fbdf2">More...</a><br /></td></tr>
<tr class="separator:a99d5b9427668544de95ae7e1754fbdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9531df705fdc2660fb29dd3eb8714335"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:a9531df705fdc2660fb29dd3eb8714335"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar *, Params..., Kokkos::MemoryUnmanaged &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a9531df705fdc2660fb29dd3eb8714335">createView</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;index_space, Scalar *data)</td></tr>
<tr class="memdesc:a9531df705fdc2660fb29dd3eb8714335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space and a data pointer create an unmanaged view over the extent of that index space.  <a href="namespaceCajita.html#a9531df705fdc2660fb29dd3eb8714335">More...</a><br /></td></tr>
<tr class="separator:a9531df705fdc2660fb29dd3eb8714335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbf7e52233435ee3179f05461f4a38c"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:a9bbf7e52233435ee3179f05461f4a38c"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar **, Params... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a9bbf7e52233435ee3179f05461f4a38c">createView</a> (const std::string &amp;label, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &amp;index_space)</td></tr>
<tr class="memdesc:a9bbf7e52233435ee3179f05461f4a38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space create a view over the extent of that index space.  <a href="namespaceCajita.html#a9bbf7e52233435ee3179f05461f4a38c">More...</a><br /></td></tr>
<tr class="separator:a9bbf7e52233435ee3179f05461f4a38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8398eaf0e455595702b01831c98bce5d"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:a8398eaf0e455595702b01831c98bce5d"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar **, Params..., Kokkos::MemoryUnmanaged &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a8398eaf0e455595702b01831c98bce5d">createView</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &amp;index_space, Scalar *data)</td></tr>
<tr class="memdesc:a8398eaf0e455595702b01831c98bce5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space and a data pointer create an unmanaged view over the extent of that index space.  <a href="namespaceCajita.html#a8398eaf0e455595702b01831c98bce5d">More...</a><br /></td></tr>
<tr class="separator:a8398eaf0e455595702b01831c98bce5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0660da3fcb7e7de7f8ae6277f325542"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:ac0660da3fcb7e7de7f8ae6277f325542"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar ***, Params... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ac0660da3fcb7e7de7f8ae6277f325542">createView</a> (const std::string &amp;label, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &amp;index_space)</td></tr>
<tr class="memdesc:ac0660da3fcb7e7de7f8ae6277f325542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space create a view over the extent of that index space.  <a href="namespaceCajita.html#ac0660da3fcb7e7de7f8ae6277f325542">More...</a><br /></td></tr>
<tr class="separator:ac0660da3fcb7e7de7f8ae6277f325542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a42bef35610957e3f42e20cf99d308"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:a54a42bef35610957e3f42e20cf99d308"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar ***, Params..., Kokkos::MemoryUnmanaged &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a54a42bef35610957e3f42e20cf99d308">createView</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &amp;index_space, Scalar *data)</td></tr>
<tr class="memdesc:a54a42bef35610957e3f42e20cf99d308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space and a data pointer create an unmanaged view over the extent of that index space.  <a href="namespaceCajita.html#a54a42bef35610957e3f42e20cf99d308">More...</a><br /></td></tr>
<tr class="separator:a54a42bef35610957e3f42e20cf99d308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b7eb24eebb49037bcacf78dc726b3b"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:ab8b7eb24eebb49037bcacf78dc726b3b"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar ****, Params... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ab8b7eb24eebb49037bcacf78dc726b3b">createView</a> (const std::string &amp;label, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt; &amp;index_space)</td></tr>
<tr class="memdesc:ab8b7eb24eebb49037bcacf78dc726b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space create a view over the extent of that index space.  <a href="namespaceCajita.html#ab8b7eb24eebb49037bcacf78dc726b3b">More...</a><br /></td></tr>
<tr class="separator:ab8b7eb24eebb49037bcacf78dc726b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1300fe5c384cf540da45adcc844f5043"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class... Params&gt; </td></tr>
<tr class="memitem:a1300fe5c384cf540da45adcc844f5043"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; Scalar ****, Params..., Kokkos::MemoryUnmanaged &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a1300fe5c384cf540da45adcc844f5043">createView</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt; &amp;index_space, Scalar *data)</td></tr>
<tr class="memdesc:a1300fe5c384cf540da45adcc844f5043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index space and a data pointer create an unmanaged view over the extent of that index space.  <a href="namespaceCajita.html#a1300fe5c384cf540da45adcc844f5043">More...</a><br /></td></tr>
<tr class="separator:a1300fe5c384cf540da45adcc844f5043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffd9f583a762bf067ff0d583b5e3498"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:afffd9f583a762bf067ff0d583b5e3498"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#afffd9f583a762bf067ff0d583b5e3498">createSubview</a> (const ViewType &amp;view, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;index_space) -&gt; decltype(Kokkos::subview(view, index_space.range(0)))</td></tr>
<tr class="memdesc:afffd9f583a762bf067ff0d583b5e3498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a view create a subview over the given index space.  <a href="namespaceCajita.html#afffd9f583a762bf067ff0d583b5e3498">More...</a><br /></td></tr>
<tr class="separator:afffd9f583a762bf067ff0d583b5e3498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4594470daa8143fa9a8f65e5689c3ae7"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a4594470daa8143fa9a8f65e5689c3ae7"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a4594470daa8143fa9a8f65e5689c3ae7">createSubview</a> (const ViewType &amp;view, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &amp;index_space) -&gt; decltype(Kokkos::subview(view, index_space.range(0), index_space.range(1)))</td></tr>
<tr class="memdesc:a4594470daa8143fa9a8f65e5689c3ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a view create a subview over the given index space.  <a href="namespaceCajita.html#a4594470daa8143fa9a8f65e5689c3ae7">More...</a><br /></td></tr>
<tr class="separator:a4594470daa8143fa9a8f65e5689c3ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb002d4e9b61930c1478eaf4f00d610f"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:aeb002d4e9b61930c1478eaf4f00d610f"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aeb002d4e9b61930c1478eaf4f00d610f">createSubview</a> (const ViewType &amp;view, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &amp;index_space) -&gt; decltype(Kokkos::subview(view, index_space.range(0), index_space.range(1), index_space.range(2)))</td></tr>
<tr class="memdesc:aeb002d4e9b61930c1478eaf4f00d610f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a view create a subview over the given index space.  <a href="namespaceCajita.html#aeb002d4e9b61930c1478eaf4f00d610f">More...</a><br /></td></tr>
<tr class="separator:aeb002d4e9b61930c1478eaf4f00d610f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413c2645baa122d4cb8f079597e43fce"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a413c2645baa122d4cb8f079597e43fce"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a413c2645baa122d4cb8f079597e43fce">createSubview</a> (const ViewType &amp;view, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt; &amp;index_space) -&gt; decltype(Kokkos::subview(view, index_space.range(0), index_space.range(1), index_space.range(2), index_space.range(3)))</td></tr>
<tr class="memdesc:a413c2645baa122d4cb8f079597e43fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a view create a subview over the given index space.  <a href="namespaceCajita.html#a413c2645baa122d4cb8f079597e43fce">More...</a><br /></td></tr>
<tr class="separator:a413c2645baa122d4cb8f079597e43fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28abc7dff90a69ad9fb7d72d1b84bb3d"><td class="memTemplParams" colspan="2">template&lt;long N&gt; </td></tr>
<tr class="memitem:a28abc7dff90a69ad9fb7d72d1b84bb3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a28abc7dff90a69ad9fb7d72d1b84bb3d">appendDimension</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;index_space, const long size)</td></tr>
<tr class="separator:a28abc7dff90a69ad9fb7d72d1b84bb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc579f447afc9f267f9939f2e27fc80b"><td class="memTemplParams" colspan="2">template&lt;long N&gt; </td></tr>
<tr class="memitem:afc579f447afc9f267f9939f2e27fc80b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#afc579f447afc9f267f9939f2e27fc80b">appendDimension</a> (const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;index_space, const long min, const long max)</td></tr>
<tr class="separator:afc579f447afc9f267f9939f2e27fc80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46994b4aad6692cf5cdd9fff08c578d0"><td class="memTemplParams" colspan="2">template&lt;class PointEvalFunctor , class PointCoordinates , class ArrayScalar , class MeshScalar , class EntityType , int SplineOrder, std::size_t NumSpaceDim, class DeviceType , class... ArrayParams&gt; </td></tr>
<tr class="memitem:a46994b4aad6692cf5cdd9fff08c578d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a46994b4aad6692cf5cdd9fff08c578d0">g2p</a> (const <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; ArrayScalar, EntityType, <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; MeshScalar, NumSpaceDim &gt;, ArrayParams... &gt; &amp;array, const <a class="el" href="classCajita_1_1Halo.html">Halo</a>&lt; DeviceType &gt; &amp;halo, const PointCoordinates &amp;points, const std::size_t num_point, <a class="el" href="structCajita_1_1Spline.html">Spline</a>&lt; SplineOrder &gt;, const PointEvalFunctor &amp;functor)</td></tr>
<tr class="memdesc:a46994b4aad6692cf5cdd9fff08c578d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> Grid-to-Point interpolation.  <a href="namespaceCajita.html#a46994b4aad6692cf5cdd9fff08c578d0">More...</a><br /></td></tr>
<tr class="separator:a46994b4aad6692cf5cdd9fff08c578d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34151ac55b1a94763c5e253ea9783ba6"><td class="memTemplParams" colspan="2"><a id="a34151ac55b1a94763c5e253ea9783ba6"></a>
template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a34151ac55b1a94763c5e253ea9783ba6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1ScalarValueG2P.html">ScalarValueG2P</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a34151ac55b1a94763c5e253ea9783ba6">createScalarValueG2P</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:a34151ac55b1a94763c5e253ea9783ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for grid-to-point with scalar value. <br /></td></tr>
<tr class="separator:a34151ac55b1a94763c5e253ea9783ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69a9a325380fbd7defa5967085baf85"><td class="memTemplParams" colspan="2"><a id="ae69a9a325380fbd7defa5967085baf85"></a>
template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:ae69a9a325380fbd7defa5967085baf85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1VectorValueG2P.html">VectorValueG2P</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ae69a9a325380fbd7defa5967085baf85">createVectorValueG2P</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:ae69a9a325380fbd7defa5967085baf85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for grid-to-point with vector value. <br /></td></tr>
<tr class="separator:ae69a9a325380fbd7defa5967085baf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe820819a2538a1bdb1c08a4999a054"><td class="memTemplParams" colspan="2"><a id="a5fe820819a2538a1bdb1c08a4999a054"></a>
template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a5fe820819a2538a1bdb1c08a4999a054"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1ScalarGradientG2P.html">ScalarGradientG2P</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a5fe820819a2538a1bdb1c08a4999a054">createScalarGradientG2P</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:a5fe820819a2538a1bdb1c08a4999a054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for grid-to-point with scalar gradient. <br /></td></tr>
<tr class="separator:a5fe820819a2538a1bdb1c08a4999a054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3685e9a3e0a68bd3858d0f25e92f24d"><td class="memTemplParams" colspan="2"><a id="aa3685e9a3e0a68bd3858d0f25e92f24d"></a>
template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:aa3685e9a3e0a68bd3858d0f25e92f24d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1VectorGradientG2P.html">VectorGradientG2P</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aa3685e9a3e0a68bd3858d0f25e92f24d">createVectorGradientG2P</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:aa3685e9a3e0a68bd3858d0f25e92f24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for grid-to-point with vector gradient. <br /></td></tr>
<tr class="separator:aa3685e9a3e0a68bd3858d0f25e92f24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec1bc29c9be90b628e10a864c22c6ab"><td class="memTemplParams" colspan="2"><a id="aeec1bc29c9be90b628e10a864c22c6ab"></a>
template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:aeec1bc29c9be90b628e10a864c22c6ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1VectorDivergenceG2P.html">VectorDivergenceG2P</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aeec1bc29c9be90b628e10a864c22c6ab">createVectorDivergenceG2P</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:aeec1bc29c9be90b628e10a864c22c6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for grid-to-point with vector divergence. <br /></td></tr>
<tr class="separator:aeec1bc29c9be90b628e10a864c22c6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35c1fd6167a736a6a78cf742c2d6251"><td class="memTemplParams" colspan="2">template&lt;class PointEvalFunctor , class PointCoordinates , class ArrayScalar , class MeshScalar , std::size_t NumSpaceDim, class EntityType , int SplineOrder, class DeviceType , class... ArrayParams&gt; </td></tr>
<tr class="memitem:af35c1fd6167a736a6a78cf742c2d6251"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#af35c1fd6167a736a6a78cf742c2d6251">p2g</a> (const PointEvalFunctor &amp;functor, const PointCoordinates &amp;points, const std::size_t num_point, <a class="el" href="structCajita_1_1Spline.html">Spline</a>&lt; SplineOrder &gt;, const <a class="el" href="classCajita_1_1Halo.html">Halo</a>&lt; DeviceType &gt; &amp;halo, <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; ArrayScalar, EntityType, <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; MeshScalar, NumSpaceDim &gt;, ArrayParams... &gt; &amp;array)</td></tr>
<tr class="memdesc:af35c1fd6167a736a6a78cf742c2d6251"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> Point-to-Grid interpolation.  <a href="namespaceCajita.html#af35c1fd6167a736a6a78cf742c2d6251">More...</a><br /></td></tr>
<tr class="separator:af35c1fd6167a736a6a78cf742c2d6251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0dd73aaefd3f2d72752b2e1e282bd8"><td class="memTemplParams" colspan="2"><a id="a9f0dd73aaefd3f2d72752b2e1e282bd8"></a>
template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a9f0dd73aaefd3f2d72752b2e1e282bd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1ScalarValueP2G.html">ScalarValueP2G</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a9f0dd73aaefd3f2d72752b2e1e282bd8">createScalarValueP2G</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:a9f0dd73aaefd3f2d72752b2e1e282bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for point-to-grid with scalar value. <br /></td></tr>
<tr class="separator:a9f0dd73aaefd3f2d72752b2e1e282bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537bea7ee24171e099d262c32947beaa"><td class="memTemplParams" colspan="2"><a id="a537bea7ee24171e099d262c32947beaa"></a>
template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a537bea7ee24171e099d262c32947beaa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1VectorValueP2G.html">VectorValueP2G</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a537bea7ee24171e099d262c32947beaa">createVectorValueP2G</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:a537bea7ee24171e099d262c32947beaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for point-to-grid with vector value. <br /></td></tr>
<tr class="separator:a537bea7ee24171e099d262c32947beaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad239da72eb010f945c247a4110212d"><td class="memTemplParams" colspan="2"><a id="a2ad239da72eb010f945c247a4110212d"></a>
template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a2ad239da72eb010f945c247a4110212d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1ScalarGradientP2G.html">ScalarGradientP2G</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a2ad239da72eb010f945c247a4110212d">createScalarGradientP2G</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:a2ad239da72eb010f945c247a4110212d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for point-to-grid with scalar gradient. <br /></td></tr>
<tr class="separator:a2ad239da72eb010f945c247a4110212d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8daac55b67438613ddd3bc1839774cec"><td class="memTemplParams" colspan="2"><a id="a8daac55b67438613ddd3bc1839774cec"></a>
template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a8daac55b67438613ddd3bc1839774cec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1VectorDivergenceP2G.html">VectorDivergenceP2G</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a8daac55b67438613ddd3bc1839774cec">createVectorDivergenceP2G</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:a8daac55b67438613ddd3bc1839774cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for point-to-grid with vector divergence. <br /></td></tr>
<tr class="separator:a8daac55b67438613ddd3bc1839774cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe30ec129e89c3bd9e5a969f67d7a4f3"><td class="memTemplParams" colspan="2"><a id="afe30ec129e89c3bd9e5a969f67d7a4f3"></a>
template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:afe30ec129e89c3bd9e5a969f67d7a4f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structCajita_1_1TensorDivergenceP2G.html">TensorDivergenceP2G</a>&lt; ViewType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#afe30ec129e89c3bd9e5a969f67d7a4f3">createTensorDivergenceP2G</a> (const ViewType &amp;x, const typename ViewType::value_type &amp;multiplier)</td></tr>
<tr class="memdesc:afe30ec129e89c3bd9e5a969f67d7a4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for point-to-grid with tensor divergence. <br /></td></tr>
<tr class="separator:afe30ec129e89c3bd9e5a969f67d7a4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42afc02f709623b8bc57b598dfec0d7c"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a42afc02f709623b8bc57b598dfec0d7c"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a42afc02f709623b8bc57b598dfec0d7c">createLocalGrid</a> (const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt; MeshType &gt;&gt; &amp;global_grid, const int halo_cell_width)</td></tr>
<tr class="memdesc:a42afc02f709623b8bc57b598dfec0d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a local grid.  <a href="namespaceCajita.html#a42afc02f709623b8bc57b598dfec0d7c">More...</a><br /></td></tr>
<tr class="separator:a42afc02f709623b8bc57b598dfec0d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397c67cf6e558f2bdbb0b5ac7ed1d67a"><td class="memTemplParams" colspan="2"><a id="a397c67cf6e558f2bdbb0b5ac7ed1d67a"></a>
template&lt;class Device , class MeshType &gt; </td></tr>
<tr class="memitem:a397c67cf6e558f2bdbb0b5ac7ed1d67a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCajita_1_1LocalMesh.html">LocalMesh</a>&lt; Device, MeshType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a397c67cf6e558f2bdbb0b5ac7ed1d67a">createLocalMesh</a> (const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;local_grid)</td></tr>
<tr class="memdesc:a397c67cf6e558f2bdbb0b5ac7ed1d67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for local mesh. <br /></td></tr>
<tr class="separator:a397c67cf6e558f2bdbb0b5ac7ed1d67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c57f5f0f71a9195f375410205a2df20"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class ExecutionSpace , long N&gt; </td></tr>
<tr class="memitem:a1c57f5f0f71a9195f375410205a2df20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a1c57f5f0f71a9195f375410205a2df20">grid_parallel_for</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;index_space, const FunctorType &amp;functor)</td></tr>
<tr class="memdesc:a1c57f5f0f71a9195f375410205a2df20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a functor in parallel with a multidimensional execution policy specified by the given index space.  <a href="namespaceCajita.html#a1c57f5f0f71a9195f375410205a2df20">More...</a><br /></td></tr>
<tr class="separator:a1c57f5f0f71a9195f375410205a2df20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644313d527fab5a1d9e59a138f51ec63"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class WorkTag , class ExecutionSpace , long N&gt; </td></tr>
<tr class="memitem:a644313d527fab5a1d9e59a138f51ec63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a644313d527fab5a1d9e59a138f51ec63">grid_parallel_for</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;index_space, const WorkTag &amp;work_tag, const FunctorType &amp;functor)</td></tr>
<tr class="memdesc:a644313d527fab5a1d9e59a138f51ec63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a functor with a work tag in parallel with a multidimensional execution policy specified by the given index space.  <a href="namespaceCajita.html#a644313d527fab5a1d9e59a138f51ec63">More...</a><br /></td></tr>
<tr class="separator:a644313d527fab5a1d9e59a138f51ec63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc2c75279e73a954b280239e841b444"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType &gt; </td></tr>
<tr class="memitem:a0cc2c75279e73a954b280239e841b444"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a0cc2c75279e73a954b280239e841b444">grid_parallel_for</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;local_grid, const DecompositionType &amp;decomposition, const EntityType &amp;entity_type, const FunctorType &amp;functor)</td></tr>
<tr class="memdesc:a0cc2c75279e73a954b280239e841b444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a functor in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local.  <a href="namespaceCajita.html#a0cc2c75279e73a954b280239e841b444">More...</a><br /></td></tr>
<tr class="separator:a0cc2c75279e73a954b280239e841b444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e1b082bbdd2df7693ce178f4d33749"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class WorkTag , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType &gt; </td></tr>
<tr class="memitem:ac2e1b082bbdd2df7693ce178f4d33749"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ac2e1b082bbdd2df7693ce178f4d33749">grid_parallel_for</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;local_grid, const DecompositionType &amp;decomposition, const EntityType &amp;entity_type, const WorkTag &amp;work_tag, const FunctorType &amp;functor)</td></tr>
<tr class="memdesc:ac2e1b082bbdd2df7693ce178f4d33749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a functor with a work tag in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local.  <a href="namespaceCajita.html#ac2e1b082bbdd2df7693ce178f4d33749">More...</a><br /></td></tr>
<tr class="separator:ac2e1b082bbdd2df7693ce178f4d33749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda357df1d146e578d38366e081b6624"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class ExecutionSpace , std::size_t NumSpace&gt; </td></tr>
<tr class="memitem:afda357df1d146e578d38366e081b6624"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#afda357df1d146e578d38366e081b6624">grid_parallel_for</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const Kokkos::Array&lt; <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt;, NumSpace &gt; &amp;index_spaces, const FunctorType &amp;functor)</td></tr>
<tr class="memdesc:afda357df1d146e578d38366e081b6624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a functor in parallel with a linear execution policy specified by the set of given index spaces. 4D specialization.  <a href="namespaceCajita.html#afda357df1d146e578d38366e081b6624">More...</a><br /></td></tr>
<tr class="separator:afda357df1d146e578d38366e081b6624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7824cb8412bd64ae4056c428f36c1c9c"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class ExecutionSpace , std::size_t NumSpace&gt; </td></tr>
<tr class="memitem:a7824cb8412bd64ae4056c428f36c1c9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a7824cb8412bd64ae4056c428f36c1c9c">grid_parallel_for</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const Kokkos::Array&lt; <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt;, NumSpace &gt; &amp;index_spaces, const FunctorType &amp;functor)</td></tr>
<tr class="memdesc:a7824cb8412bd64ae4056c428f36c1c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a functor in parallel with a linear execution policy specified by the set of given index spaces. 3D specialization.  <a href="namespaceCajita.html#a7824cb8412bd64ae4056c428f36c1c9c">More...</a><br /></td></tr>
<tr class="separator:a7824cb8412bd64ae4056c428f36c1c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45372f78f3e6880b22331ef24d113e6e"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class ExecutionSpace , std::size_t NumSpace&gt; </td></tr>
<tr class="memitem:a45372f78f3e6880b22331ef24d113e6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a45372f78f3e6880b22331ef24d113e6e">grid_parallel_for</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const Kokkos::Array&lt; <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt;, NumSpace &gt; &amp;index_spaces, const FunctorType &amp;functor)</td></tr>
<tr class="memdesc:a45372f78f3e6880b22331ef24d113e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a functor in parallel with a linear execution policy specified by the set of given index spaces. 2D specialization.  <a href="namespaceCajita.html#a45372f78f3e6880b22331ef24d113e6e">More...</a><br /></td></tr>
<tr class="separator:a45372f78f3e6880b22331ef24d113e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a58a3b10046140ae6a75b252dbade6"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class ExecutionSpace , long N, class ReduceType &gt; </td></tr>
<tr class="memitem:ac2a58a3b10046140ae6a75b252dbade6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ac2a58a3b10046140ae6a75b252dbade6">grid_parallel_reduce</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;index_space, const FunctorType &amp;functor, ReduceType &amp;reducer)</td></tr>
<tr class="memdesc:ac2a58a3b10046140ae6a75b252dbade6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a reduction functor in parallel with a multidimensional execution policy specified by the given index space.  <a href="namespaceCajita.html#ac2a58a3b10046140ae6a75b252dbade6">More...</a><br /></td></tr>
<tr class="separator:ac2a58a3b10046140ae6a75b252dbade6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3578b89bdd7bd62f95ff985a77b8986"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class WorkTag , class ExecutionSpace , long N, class ReduceType &gt; </td></tr>
<tr class="memitem:ae3578b89bdd7bd62f95ff985a77b8986"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ae3578b89bdd7bd62f95ff985a77b8986">grid_parallel_reduce</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;index_space, const WorkTag &amp;work_tag, const FunctorType &amp;functor, ReduceType &amp;reducer)</td></tr>
<tr class="memdesc:ae3578b89bdd7bd62f95ff985a77b8986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a reduction functor with a work tag in parallel with a multidimensional execution policy specified by the given index space.  <a href="namespaceCajita.html#ae3578b89bdd7bd62f95ff985a77b8986">More...</a><br /></td></tr>
<tr class="separator:ae3578b89bdd7bd62f95ff985a77b8986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f60204e3f1448420140403bc39d3ea"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType , class ReduceType &gt; </td></tr>
<tr class="memitem:a14f60204e3f1448420140403bc39d3ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a14f60204e3f1448420140403bc39d3ea">grid_parallel_reduce</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;local_grid, const DecompositionType &amp;decomposition, const EntityType &amp;entity_type, const FunctorType &amp;functor, ReduceType &amp;reducer)</td></tr>
<tr class="memdesc:a14f60204e3f1448420140403bc39d3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a reduction functor in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local.  <a href="namespaceCajita.html#a14f60204e3f1448420140403bc39d3ea">More...</a><br /></td></tr>
<tr class="separator:a14f60204e3f1448420140403bc39d3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10581196134700af84ad9a4b73f2ed4"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class WorkTag , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType , class ReduceType &gt; </td></tr>
<tr class="memitem:aa10581196134700af84ad9a4b73f2ed4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#aa10581196134700af84ad9a4b73f2ed4">grid_parallel_reduce</a> (const std::string &amp;label, const ExecutionSpace &amp;exec_space, const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;local_grid, const DecompositionType &amp;decomposition, const EntityType &amp;entity_type, const WorkTag &amp;work_tag, const FunctorType &amp;functor, ReduceType &amp;reducer)</td></tr>
<tr class="memdesc:aa10581196134700af84ad9a4b73f2ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a reduction functor with a work tag in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local.  <a href="namespaceCajita.html#aa10581196134700af84ad9a4b73f2ed4">More...</a><br /></td></tr>
<tr class="separator:aa10581196134700af84ad9a4b73f2ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583a9ee0c0e31310b730fa3ca3819721"><td class="memTemplParams" colspan="2">template&lt;class LocalGridType , class PositionSliceType &gt; </td></tr>
<tr class="memitem:a583a9ee0c0e31310b730fa3ca3819721"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a583a9ee0c0e31310b730fa3ca3819721">migrateCount</a> (const LocalGridType &amp;local_grid, const PositionSliceType &amp;positions, const int minimum_halo_width)</td></tr>
<tr class="memdesc:a583a9ee0c0e31310b730fa3ca3819721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for the number of particles that must be communicated.  <a href="namespaceCajita.html#a583a9ee0c0e31310b730fa3ca3819721">More...</a><br /></td></tr>
<tr class="separator:a583a9ee0c0e31310b730fa3ca3819721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20560d001972f0dd70ba665e9dcbef1d"><td class="memTemplParams" colspan="2">template&lt;class LocalGridType , class PositionSliceType &gt; </td></tr>
<tr class="memitem:a20560d001972f0dd70ba665e9dcbef1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1Distributor.html">Cabana::Distributor</a>&lt; typename PositionSliceType::device_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a20560d001972f0dd70ba665e9dcbef1d">createParticleGridDistributor</a> (const LocalGridType &amp;local_grid, PositionSliceType &amp;positions)</td></tr>
<tr class="memdesc:a20560d001972f0dd70ba665e9dcbef1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which data should be migrated from one uniquely-owned decomposition to another uniquely-owned decomposition, using bounds of a <a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> grid and taking periodic boundaries into account.  <a href="namespaceCajita.html#a20560d001972f0dd70ba665e9dcbef1d">More...</a><br /></td></tr>
<tr class="separator:a20560d001972f0dd70ba665e9dcbef1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4371257b756699167df4544e4f2de13"><td class="memTemplParams" colspan="2">template&lt;class LocalGridType , class ParticlePositions , class ParticleContainer &gt; </td></tr>
<tr class="memitem:af4371257b756699167df4544e4f2de13"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#af4371257b756699167df4544e4f2de13">particleGridMigrate</a> (const LocalGridType &amp;local_grid, const ParticlePositions &amp;positions, ParticleContainer &amp;particles, const int min_halo_width, const bool force_migrate=false)</td></tr>
<tr class="memdesc:af4371257b756699167df4544e4f2de13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrate data from one uniquely-owned decomposition to another uniquely-owned decomposition, using the bounds and periodic boundaries of a <a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> grid to determine which particles should be moved. In-place variant.  <a href="namespaceCajita.html#af4371257b756699167df4544e4f2de13">More...</a><br /></td></tr>
<tr class="separator:af4371257b756699167df4544e4f2de13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb928c073163bff90d4ca8a7d460fe18"><td class="memTemplParams" colspan="2">template&lt;class LocalGridType , class ParticlePositions , class ParticleContainer &gt; </td></tr>
<tr class="memitem:adb928c073163bff90d4ca8a7d460fe18"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#adb928c073163bff90d4ca8a7d460fe18">particleGridMigrate</a> (const LocalGridType &amp;local_grid, const ParticlePositions &amp;positions, const ParticleContainer &amp;src_particles, ParticleContainer &amp;dst_particles, const int min_halo_width, const bool force_migrate=false)</td></tr>
<tr class="memdesc:adb928c073163bff90d4ca8a7d460fe18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrate data from one uniquely-owned decomposition to another uniquely-owned decomposition, using the bounds and periodic boundaries of a <a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> grid to determine which particles should be moved. Separate AoSoA variant.  <a href="namespaceCajita.html#adb928c073163bff90d4ca8a7d460fe18">More...</a><br /></td></tr>
<tr class="separator:adb928c073163bff90d4ca8a7d460fe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9272dda2ab56f41f9dc931948fc24c5d"><td class="memTemplParams" colspan="2">template&lt;class Scalar , class DeviceType , class EntityType , class MeshType &gt; </td></tr>
<tr class="memitem:a9272dda2ab56f41f9dc931948fc24c5d"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCajita_1_1ReferenceConjugateGradient.html">ReferenceConjugateGradient</a>&lt; Scalar, EntityType, MeshType, DeviceType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a9272dda2ab56f41f9dc931948fc24c5d">createReferenceConjugateGradient</a> (const <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &amp;layout)</td></tr>
<tr class="separator:a9272dda2ab56f41f9dc931948fc24c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0810e82d4659a7c75a4f1f330dec515c"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:a0810e82d4659a7c75a4f1f330dec515c"><td class="memTemplItemLeft" align="right" valign="top">constexpr KOKKOS_INLINE_FUNCTION Integer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a0810e82d4659a7c75a4f1f330dec515c">bitLength</a> (Integer input_int) noexcept</td></tr>
<tr class="memdesc:a0810e82d4659a7c75a4f1f330dec515c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Host/Device) Compute the least bit number/length needed to represent the given input integer  <a href="namespaceCajita.html#a0810e82d4659a7c75a4f1f330dec515c">More...</a><br /></td></tr>
<tr class="separator:a0810e82d4659a7c75a4f1f330dec515c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bb6915655919bf33f6128dc0cf62e8"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:ae9bb6915655919bf33f6128dc0cf62e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr KOKKOS_INLINE_FUNCTION Integer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ae9bb6915655919bf33f6128dc0cf62e8">bitCount</a> (Integer input_int) noexcept</td></tr>
<tr class="memdesc:ae9bb6915655919bf33f6128dc0cf62e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Host/Device) Compute the lease bit number needed to index input integer  <a href="namespaceCajita.html#ae9bb6915655919bf33f6128dc0cf62e8">More...</a><br /></td></tr>
<tr class="separator:ae9bb6915655919bf33f6128dc0cf62e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ae41ffce8bbd5b7a97e0429127ce85"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:a65ae41ffce8bbd5b7a97e0429127ce85"><td class="memTemplItemLeft" align="right" valign="top">constexpr KOKKOS_INLINE_FUNCTION Integer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a65ae41ffce8bbd5b7a97e0429127ce85">binaryReverse</a> (Integer input_int, char loc=sizeof(Integer) *8 - 1)</td></tr>
<tr class="memdesc:a65ae41ffce8bbd5b7a97e0429127ce85"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Host/Device) Given a integer, reverse the corresponding binary string, return the resulting integer.  <a href="namespaceCajita.html#a65ae41ffce8bbd5b7a97e0429127ce85">More...</a><br /></td></tr>
<tr class="separator:a65ae41ffce8bbd5b7a97e0429127ce85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0dd52b17ed51045837a3ee2c30aacb"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:ada0dd52b17ed51045837a3ee2c30aacb"><td class="memTemplItemLeft" align="right" valign="top">constexpr KOKKOS_INLINE_FUNCTION unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ada0dd52b17ed51045837a3ee2c30aacb">countLeadingZeros</a> (Integer input_int)</td></tr>
<tr class="memdesc:ada0dd52b17ed51045837a3ee2c30aacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Host/Device) Count the leading zeros in the corresponding binary string of the input integer  <a href="namespaceCajita.html#ada0dd52b17ed51045837a3ee2c30aacb">More...</a><br /></td></tr>
<tr class="separator:ada0dd52b17ed51045837a3ee2c30aacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b1d024dced75333d69f6f15951c8c6"><td class="memItemLeft" align="right" valign="top">constexpr KOKKOS_INLINE_FUNCTION int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ad1b1d024dced75333d69f6f15951c8c6">bitPack</a> (const uint64_t mask, const uint64_t data)</td></tr>
<tr class="memdesc:ad1b1d024dced75333d69f6f15951c8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Host/Device) Pack up the data bits where the corresponding bit of the mask is 1  <a href="namespaceCajita.html#ad1b1d024dced75333d69f6f15951c8c6">More...</a><br /></td></tr>
<tr class="separator:ad1b1d024dced75333d69f6f15951c8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223f1bb14421ca2d41a547438d0d8f14"><td class="memItemLeft" align="right" valign="top">constexpr KOKKOS_INLINE_FUNCTION uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a223f1bb14421ca2d41a547438d0d8f14">bitSpread</a> (const uint64_t mask, const int data)</td></tr>
<tr class="memdesc:a223f1bb14421ca2d41a547438d0d8f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Host/Device) Spread out the data bits where the corresponding bit of the mask is 1  <a href="namespaceCajita.html#a223f1bb14421ca2d41a547438d0d8f14">More...</a><br /></td></tr>
<tr class="separator:a223f1bb14421ca2d41a547438d0d8f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5461f76f97a83086286d3d5e21a4133f"><td class="memTemplParams" colspan="2"><a id="a5461f76f97a83086286d3d5e21a4133f"></a>
template&lt;typename MemorySpace , class Scalar , unsigned long long CellPerTileDim = 4, HashTypes Hash = HashTypes::Naive, typename Key  = uint64_t, typename Value  = uint64_t&gt; </td></tr>
<tr class="memitem:a5461f76f97a83086286d3d5e21a4133f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCajita_1_1SparseMap.html">SparseMap</a>&lt; MemorySpace, CellPerTileDim, Hash, Key, Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a5461f76f97a83086286d3d5e21a4133f">createSparseMap</a> (const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar &gt;&gt;&gt; &amp;global_mesh, int pre_alloc_size)</td></tr>
<tr class="memdesc:a5461f76f97a83086286d3d5e21a4133f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation function for <a class="el" href="classCajita_1_1SparseMap.html" title="Sparse index space, with a hierarchical structure (cell-&gt;tile-&gt;block)">SparseMap</a> from GlobalMesh&lt;SparseMesh&gt; <br /></td></tr>
<tr class="separator:a5461f76f97a83086286d3d5e21a4133f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb21edb66de3bf0bcdb1b9186d95119"><td class="memTemplParams" colspan="2"><a id="addb21edb66de3bf0bcdb1b9186d95119"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:addb21edb66de3bf0bcdb1b9186d95119"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt; <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_physical_cell_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#addb21edb66de3bf0bcdb1b9186d95119">setSplineData</a> (<a class="el" href="structCajita_1_1SplinePhysicalCellSize.html">SplinePhysicalCellSize</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;data, const int d, const Scalar dx)</td></tr>
<tr class="memdesc:addb21edb66de3bf0bcdb1b9186d95119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign physical cell size to the spline data. <br /></td></tr>
<tr class="separator:addb21edb66de3bf0bcdb1b9186d95119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe89a8cdb7c20860ed4c25b8e751c5d9"><td class="memTemplParams" colspan="2"><a id="afe89a8cdb7c20860ed4c25b8e751c5d9"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:afe89a8cdb7c20860ed4c25b8e751c5d9"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt;!<a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_physical_cell_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#afe89a8cdb7c20860ed4c25b8e751c5d9">setSplineData</a> (<a class="el" href="structCajita_1_1SplinePhysicalCellSize.html">SplinePhysicalCellSize</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;, const int, const Scalar)</td></tr>
<tr class="memdesc:afe89a8cdb7c20860ed4c25b8e751c5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical cell size spline data template helper. <br /></td></tr>
<tr class="separator:afe89a8cdb7c20860ed4c25b8e751c5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0399717203661e44eacc81594e97fa11"><td class="memTemplParams" colspan="2"><a id="a0399717203661e44eacc81594e97fa11"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:a0399717203661e44eacc81594e97fa11"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt; <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_logical_position &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a0399717203661e44eacc81594e97fa11">setSplineData</a> (<a class="el" href="structCajita_1_1SplineLogicalPosition.html">SplineLogicalPosition</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;data, const int d, const Scalar x)</td></tr>
<tr class="memdesc:a0399717203661e44eacc81594e97fa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign logical position to the spline data. <br /></td></tr>
<tr class="separator:a0399717203661e44eacc81594e97fa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7b3baa3ee43e14433464e2af2eba73"><td class="memTemplParams" colspan="2"><a id="afc7b3baa3ee43e14433464e2af2eba73"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:afc7b3baa3ee43e14433464e2af2eba73"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt;!<a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_logical_position &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#afc7b3baa3ee43e14433464e2af2eba73">setSplineData</a> (<a class="el" href="structCajita_1_1SplineLogicalPosition.html">SplineLogicalPosition</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;, const int, const Scalar)</td></tr>
<tr class="memdesc:afc7b3baa3ee43e14433464e2af2eba73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical position spline data template helper. <br /></td></tr>
<tr class="separator:afc7b3baa3ee43e14433464e2af2eba73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc8626f0bb503e6b5812a047d3f7ef6"><td class="memTemplParams" colspan="2"><a id="a0fc8626f0bb503e6b5812a047d3f7ef6"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:a0fc8626f0bb503e6b5812a047d3f7ef6"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt; <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_weight_values &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a0fc8626f0bb503e6b5812a047d3f7ef6">setSplineData</a> (<a class="el" href="structCajita_1_1SplineWeightValues.html">SplineWeightValues</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;data, const Scalar x[NumSpaceDim])</td></tr>
<tr class="memdesc:a0fc8626f0bb503e6b5812a047d3f7ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign weight values to the spline data. <br /></td></tr>
<tr class="separator:a0fc8626f0bb503e6b5812a047d3f7ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0458dd80f2cf239cfb9233623f879bed"><td class="memTemplParams" colspan="2"><a id="a0458dd80f2cf239cfb9233623f879bed"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:a0458dd80f2cf239cfb9233623f879bed"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt;!<a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_weight_values &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a0458dd80f2cf239cfb9233623f879bed">setSplineData</a> (<a class="el" href="structCajita_1_1SplineWeightValues.html">SplineWeightValues</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;, const Scalar[NumSpaceDim])</td></tr>
<tr class="memdesc:a0458dd80f2cf239cfb9233623f879bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weight value spline data template helper. <br /></td></tr>
<tr class="separator:a0458dd80f2cf239cfb9233623f879bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c309e9d38f3529ca5e8f0ac02d22e8"><td class="memTemplParams" colspan="2"><a id="ac7c309e9d38f3529ca5e8f0ac02d22e8"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:ac7c309e9d38f3529ca5e8f0ac02d22e8"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt; <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_weight_physical_gradients &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ac7c309e9d38f3529ca5e8f0ac02d22e8">setSplineData</a> (<a class="el" href="structCajita_1_1SplineWeightPhysicalGradients.html">SplineWeightPhysicalGradients</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;data, const Scalar x[NumSpaceDim], const Scalar rdx[NumSpaceDim])</td></tr>
<tr class="memdesc:ac7c309e9d38f3529ca5e8f0ac02d22e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign weight physical gradients to the spline data. <br /></td></tr>
<tr class="separator:ac7c309e9d38f3529ca5e8f0ac02d22e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01f42108fc61eb8a4807891a3904361"><td class="memTemplParams" colspan="2"><a id="ab01f42108fc61eb8a4807891a3904361"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:ab01f42108fc61eb8a4807891a3904361"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt;!<a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_weight_physical_gradients &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ab01f42108fc61eb8a4807891a3904361">setSplineData</a> (<a class="el" href="structCajita_1_1SplineWeightPhysicalGradients.html">SplineWeightPhysicalGradients</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;, const Scalar[NumSpaceDim], const Scalar[NumSpaceDim])</td></tr>
<tr class="memdesc:ab01f42108fc61eb8a4807891a3904361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weight physical gradients spline data template helper. <br /></td></tr>
<tr class="separator:ab01f42108fc61eb8a4807891a3904361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e50bcba3b8b7c6562eaacb700526e5"><td class="memTemplParams" colspan="2"><a id="ae6e50bcba3b8b7c6562eaacb700526e5"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:ae6e50bcba3b8b7c6562eaacb700526e5"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt; <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_physical_distance &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#ae6e50bcba3b8b7c6562eaacb700526e5">setSplineData</a> (<a class="el" href="structCajita_1_1SplinePhysicalDistance.html">SplinePhysicalDistance</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;data, const Scalar low_x[NumSpaceDim], const Scalar p[NumSpaceDim], const Scalar dx[NumSpaceDim])</td></tr>
<tr class="memdesc:ae6e50bcba3b8b7c6562eaacb700526e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign physical distance to the spline data. <br /></td></tr>
<tr class="separator:ae6e50bcba3b8b7c6562eaacb700526e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a44eef7ee05d05c86e351dbc111ba0f"><td class="memTemplParams" colspan="2"><a id="a3a44eef7ee05d05c86e351dbc111ba0f"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:a3a44eef7ee05d05c86e351dbc111ba0f"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION std::enable_if_t&lt;!<a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt;::has_physical_distance &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a3a44eef7ee05d05c86e351dbc111ba0f">setSplineData</a> (<a class="el" href="structCajita_1_1SplinePhysicalDistance.html">SplinePhysicalDistance</a>, <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;, const Scalar[NumSpaceDim], const Scalar[NumSpaceDim], const Scalar[NumSpaceDim])</td></tr>
<tr class="memdesc:a3a44eef7ee05d05c86e351dbc111ba0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical distance spline data template helper. <br /></td></tr>
<tr class="separator:a3a44eef7ee05d05c86e351dbc111ba0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6de972b67dea67aad9d4573dd1449b"><td class="memTemplParams" colspan="2"><a id="a5b6de972b67dea67aad9d4573dd1449b"></a>
template&lt;typename Scalar , int Order, std::size_t NumSpaceDim, class Device , class EntityType , class DataTags &gt; </td></tr>
<tr class="memitem:a5b6de972b67dea67aad9d4573dd1449b"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCajita.html#a5b6de972b67dea67aad9d4573dd1449b">evaluateSpline</a> (const <a class="el" href="classCajita_1_1LocalMesh.html">LocalMesh</a>&lt; Device, <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; Scalar, NumSpaceDim &gt;&gt; &amp;local_mesh, const Scalar p[NumSpaceDim], <a class="el" href="structCajita_1_1SplineData.html">SplineData</a>&lt; Scalar, Order, NumSpaceDim, EntityType, DataTags &gt; &amp;data)</td></tr>
<tr class="memdesc:a5b6de972b67dea67aad9d4573dd1449b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate spline data at a point in a uniform mesh. <br /></td></tr>
<tr class="separator:a5b6de972b67dea67aad9d4573dd1449b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a>: grid and particle-grid data structures and algorithms. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="afc579f447afc9f267f9939f2e27fc80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc579f447afc9f267f9939f2e27fc80b">&#9670;&nbsp;</a></span>appendDimension() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt;N + 1&gt; Cajita::appendDimension </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an N-dimensional index space append an additional dimension with the given range. </p>

</div>
</div>
<a id="a28abc7dff90a69ad9fb7d72d1b84bb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28abc7dff90a69ad9fb7d72d1b84bb3d">&#9670;&nbsp;</a></span>appendDimension() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt;N + 1&gt; Cajita::appendDimension </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an N-dimensional index space append an additional dimension with the given size. </p>

</div>
</div>
<a id="a65ae41ffce8bbd5b7a97e0429127ce85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ae41ffce8bbd5b7a97e0429127ce85">&#9670;&nbsp;</a></span>binaryReverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr KOKKOS_INLINE_FUNCTION Integer Cajita::binaryReverse </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>input_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>loc</em> = <code>sizeof(&#160;Integer&#160;)&#160;*&#160;8&#160;-&#160;1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Host/Device) Given a integer, reverse the corresponding binary string, return the resulting integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_int</td><td>integer that is going to be evaluated </td></tr>
    <tr><td class="paramname">loc</td><td>location for next round reverse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9bb6915655919bf33f6128dc0cf62e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bb6915655919bf33f6128dc0cf62e8">&#9670;&nbsp;</a></span>bitCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr KOKKOS_INLINE_FUNCTION Integer Cajita::bitCount </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>input_int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Host/Device) Compute the lease bit number needed to index input integer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_int</td><td>integer that is going to be evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0810e82d4659a7c75a4f1f330dec515c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0810e82d4659a7c75a4f1f330dec515c">&#9670;&nbsp;</a></span>bitLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr KOKKOS_INLINE_FUNCTION Integer Cajita::bitLength </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>input_int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Host/Device) Compute the least bit number/length needed to represent the given input integer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_int</td><td>integer that is going to be evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1b1d024dced75333d69f6f15951c8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b1d024dced75333d69f6f15951c8c6">&#9670;&nbsp;</a></span>bitPack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr KOKKOS_INLINE_FUNCTION int Cajita::bitPack </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Host/Device) Pack up the data bits where the corresponding bit of the mask is 1 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>mask value </td></tr>
    <tr><td class="paramname">data</td><td>integer to be packed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a223f1bb14421ca2d41a547438d0d8f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223f1bb14421ca2d41a547438d0d8f14">&#9670;&nbsp;</a></span>bitSpread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr KOKKOS_INLINE_FUNCTION uint64_t Cajita::bitSpread </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Host/Device) Spread out the data bits where the corresponding bit of the mask is 1 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>mask value </td></tr>
    <tr><td class="paramname">data</td><td>integer to be spreaded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada0dd52b17ed51045837a3ee2c30aacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0dd52b17ed51045837a3ee2c30aacb">&#9670;&nbsp;</a></span>countLeadingZeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr KOKKOS_INLINE_FUNCTION unsigned Cajita::countLeadingZeros </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>input_int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Host/Device) Count the leading zeros in the corresponding binary string of the input integer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_int</td><td>integer that is going to be evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5e3a9510cf15e741a56e55216dae684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e3a9510cf15e741a56e55216dae684">&#9670;&nbsp;</a></span>createArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params, class EntityType , class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1Array.html">Array</a>&lt;Scalar, EntityType, MeshType, Params...&gt; &gt; Cajita::createArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an array with the given array layout. Views are constructed over the ghosted index space of the layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>A label for the view. </td></tr>
    <tr><td class="paramname">layout</td><td>The array layout over which to construct the view. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4862d96b1f56f8b0fc0a1a7fb7aff52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4862d96b1f56f8b0fc0a1a7fb7aff52">&#9670;&nbsp;</a></span>createArrayLayout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EntityType , class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt;EntityType, MeshType&gt; &gt; Cajita::createArrayLayout </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt; MeshType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>global_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>halo_cell_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dofs_per_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EntityType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an array layout over the entities of a grid given local grid parameters. An intermediate local grid will be created and assigned to the layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_grid</td><td>The local grid over which to create the layout. </td></tr>
    <tr><td class="paramname">halo_cell_width</td><td>The number of halo cells surrounding the locally owned cells. </td></tr>
    <tr><td class="paramname">dofs_per_entity</td><td>The number of degrees-of-freedom per grid entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>EntityType The entity: <a class="el" href="structCajita_1_1Cell.html" title="Mesh cell tag.">Cell</a>, <a class="el" href="structCajita_1_1Node.html" title="Mesh node tag.">Node</a>, <a class="el" href="structCajita_1_1Face.html" title="Mesh face tag.">Face</a>, or <a class="el" href="structCajita_1_1Edge.html" title="Mesh edge tag.">Edge</a> </dd></dl>

</div>
</div>
<a id="abdd3b143d333ec6a5d5018c2caa38598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd3b143d333ec6a5d5018c2caa38598">&#9670;&nbsp;</a></span>createArrayLayout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EntityType , class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt;EntityType, MeshType&gt; &gt; Cajita::createArrayLayout </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dofs_per_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EntityType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an array layout over the entities of a local grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_grid</td><td>The local grid over which to create the layout. </td></tr>
    <tr><td class="paramname">dofs_per_entity</td><td>The number of degrees-of-freedom per grid entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>EntityType The entity: <a class="el" href="structCajita_1_1Cell.html" title="Mesh cell tag.">Cell</a>, <a class="el" href="structCajita_1_1Node.html" title="Mesh node tag.">Node</a>, <a class="el" href="structCajita_1_1Face.html" title="Mesh face tag.">Face</a>, or <a class="el" href="structCajita_1_1Edge.html" title="Mesh edge tag.">Edge</a> </dd></dl>

</div>
</div>
<a id="a1d70326b11175c3b3111b3e544d002b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d70326b11175c3b3111b3e544d002b3">&#9670;&nbsp;</a></span>createExecutionPolicy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::RangePolicy&lt;ExecutionSpace&gt; Cajita::createExecutionPolicy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a multi-dimensional execution policy over an index space. </p>
<p>Rank-1 specialization. </p>

</div>
</div>
<a id="a3d9a2b5e43eb54a1ddc81c0522ab25a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9a2b5e43eb54a1ddc81c0522ab25a4">&#9670;&nbsp;</a></span>createExecutionPolicy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutionSpace , class WorkTag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::RangePolicy&lt;ExecutionSpace, WorkTag&gt; Cajita::createExecutionPolicy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorkTag &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a multi-dimensional execution policy over an index space. </p>
<p>Rank-1 specialization with a work tag. </p>

</div>
</div>
<a id="aa06dbf84ec637409b417a596ec6a6ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06dbf84ec637409b417a596ec6a6ca9">&#9670;&nbsp;</a></span>createGlobalGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt;MeshType&gt; &gt; Cajita::createGlobalGrid </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; MeshType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>global_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; bool, MeshType::num_space_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>periodic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1BlockPartitioner.html">BlockPartitioner</a>&lt; MeshType::num_space_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The communicator over which to define the grid. </td></tr>
    <tr><td class="paramname">global_mesh</td><td>The global mesh data. </td></tr>
    <tr><td class="paramname">periodic</td><td>Whether each logical dimension is periodic. </td></tr>
    <tr><td class="paramname">partitioner</td><td>The grid partitioner. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b25f6703877713696291543bb12b1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b25f6703877713696291543bb12b1b1">&#9670;&nbsp;</a></span>createGlobalGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt;<a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt;Scalar, NumSpaceDim&gt; &gt; &gt; Cajita::createGlobalGrid </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>global_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; bool, <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt;::num_space_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>periodic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1BlockPartitioner.html">BlockPartitioner</a>&lt; <a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt; Scalar, NumSpaceDim &gt;::num_space_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sparse global grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The communicator over which to define the grid. </td></tr>
    <tr><td class="paramname">global_mesh</td><td>The global mesh data. </td></tr>
    <tr><td class="paramname">periodic</td><td>Whether each logical dimension is periodic. </td></tr>
    <tr><td class="paramname">partitioner</td><td>The grid partitioner. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a342119f5d5b011c689cc474e16cc70e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342119f5d5b011c689cc474e16cc70e5">&#9670;&nbsp;</a></span>createHalo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class Pattern , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cajita::createHalo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pattern &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a halo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to build the halo for. </td></tr>
    <tr><td class="paramname">pattern</td><td>The pattern to build the halo from. </td></tr>
    <tr><td class="paramname">width</td><td>Must be less than or equal to the width of the array halo. Defaults to the width of the array halo. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The scalar type and device type are specified via the input arrays so the proper buffers may be allocated. This means a halo constructed via this method is only compatible with arrays that have the same scalar and device type as the input array. </dd></dl>

</div>
</div>
<a id="abb8e3f33f12e80ce359f1d4840ee641c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8e3f33f12e80ce359f1d4840ee641c">&#9670;&nbsp;</a></span>createHalo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class Device , class EntityType , class MeshType , class Pattern &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cajita::createHalo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pattern &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a halo with a layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layout</td><td>The array layout to build the halo for. </td></tr>
    <tr><td class="paramname">pattern</td><td>The pattern to build the halo from. </td></tr>
    <tr><td class="paramname">width</td><td>Must be less than or equal to the width of the array halo. Defaults to the width of the array halo. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The scalar type and device type must be specified so the proper buffers may be allocated. This means a halo constructed via this method is only compatible with arrays that have the same scalar and device type. </dd></dl>

</div>
</div>
<a id="a047ee0472b03e9ef8798fc34f110c28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047ee0472b03e9ef8798fc34f110c28d">&#9670;&nbsp;</a></span>createHalo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pattern , class... ArrayTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Cajita::createHalo </td>
          <td>(</td>
          <td class="paramtype">const Pattern &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayTypes &amp;...&#160;</td>
          <td class="paramname"><em>arrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCajita_1_1Array.html" title="Array of field data on the local mesh.">Array</a> creation function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern to build the halo from. </td></tr>
    <tr><td class="paramname">width</td><td>Must be less than or equal to the width of the array halo. </td></tr>
    <tr><td class="paramname">arrays</td><td>The arrays over which to build the halo. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa51f1159278d5b5023615af31744bcf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51f1159278d5b5023615af31744bcf0">&#9670;&nbsp;</a></span>createHypreStructuredSolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class MemorySpace , class ArrayLayout_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1HypreStructuredSolver.html">HypreStructuredSolver</a>&lt; Scalar, typename ArrayLayout_t::entity_type, MemorySpace&gt; &gt; Cajita::createHypreStructuredSolver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayLayout_t &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_preconditioner</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a HYPRE structured solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver_type</td><td>Solver name. </td></tr>
    <tr><td class="paramname">layout</td><td>The <a class="el" href="classCajita_1_1ArrayLayout.html" title="Entity layout for array data on the local mesh.">ArrayLayout</a> defining the vector space of the solver. </td></tr>
    <tr><td class="paramname">is_preconditioner</td><td>Use as a preconditioner. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42afc02f709623b8bc57b598dfec0d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42afc02f709623b8bc57b598dfec0d7c">&#9670;&nbsp;</a></span>createLocalGrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt;MeshType&gt; &gt; Cajita::createLocalGrid </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCajita_1_1GlobalGrid.html">GlobalGrid</a>&lt; MeshType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>global_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>halo_cell_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a local grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_grid</td><td>The global grid from which the local grid will be constructed. </td></tr>
    <tr><td class="paramname">halo_cell_width</td><td>The number of halo cells surrounding the locally owned cells. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0c460981e8fbe2e584407054167ede2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c460981e8fbe2e584407054167ede2">&#9670;&nbsp;</a></span>createNonUniformGlobalMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt;<a class="el" href="structCajita_1_1NonUniformMesh.html">NonUniformMesh</a>&lt;Scalar, 2&gt; &gt; &gt; Cajita::createNonUniformGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>j_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a non-uniform 2D mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Mesh scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_edges,j_edges</td><td>List of edges defining the mesh in each dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3f0dcbfa11d396fa8781e0889c9f198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f0dcbfa11d396fa8781e0889c9f198">&#9670;&nbsp;</a></span>createNonUniformGlobalMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt;<a class="el" href="structCajita_1_1NonUniformMesh.html">NonUniformMesh</a>&lt;Scalar, 3&gt; &gt; &gt; Cajita::createNonUniformGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>j_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>k_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a non-uniform 3D mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_edges,j_edges,k_edges</td><td>List of edges defining the mesh in each dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20560d001972f0dd70ba665e9dcbef1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20560d001972f0dd70ba665e9dcbef1d">&#9670;&nbsp;</a></span>createParticleGridDistributor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalGridType , class PositionSliceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Distributor.html">Cabana::Distributor</a>&lt;typename PositionSliceType::device_type&gt; Cajita::createParticleGridDistributor </td>
          <td>(</td>
          <td class="paramtype">const LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionSliceType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine which data should be migrated from one uniquely-owned decomposition to another uniquely-owned decomposition, using bounds of a <a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> grid and taking periodic boundaries into account. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LocalGridType</td><td><a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> type.</td></tr>
    <tr><td class="paramname">PositionSliceType</td><td>Position type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_grid</td><td>The local grid containing periodicity and system bound information.</td></tr>
    <tr><td class="paramname">positions</td><td>The particle positions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Distributor for later migration. </dd></dl>

</div>
</div>
<a id="a9272dda2ab56f41f9dc931948fc24c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9272dda2ab56f41f9dc931948fc24c5d">&#9670;&nbsp;</a></span>createReferenceConjugateGradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class DeviceType , class EntityType , class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCajita_1_1ReferenceConjugateGradient.html">ReferenceConjugateGradient</a>&lt;Scalar, EntityType, MeshType, DeviceType&gt; &gt; Cajita::createReferenceConjugateGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creation function for reference structured preconditioned block conjugate gradient. </p>

</div>
</div>
<a id="ab4da2b8bb6f203ccfff9697acf0608a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4da2b8bb6f203ccfff9697acf0608a5">&#9670;&nbsp;</a></span>createSparseGlobalMesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt;<a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt;Scalar, NumSpaceDim&gt; &gt; &gt; Cajita::createSparseGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_low_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_high_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>cell_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create sparse mesh with uniform cell size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Mesh floating point type. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>Spatial dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_low_corner,global_high_corner</td><td>Location of the mesh corner. </td></tr>
    <tr><td class="paramname">cell_size</td><td>Uniform cell size for every dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56eddf41d0e79c6542ab1fca024ddf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56eddf41d0e79c6542ab1fca024ddf84">&#9670;&nbsp;</a></span>createSparseGlobalMesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt;<a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt;Scalar, NumSpaceDim&gt; &gt; &gt; Cajita::createSparseGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_low_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_high_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_num_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create sparse mesh with total number of cells. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Mesh floating point type. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>Spatial dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_low_corner,global_high_corner</td><td>Location of the mesh corner. </td></tr>
    <tr><td class="paramname">global_num_cell</td><td>Array ofnumber of cells per dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03d0772abdde612f1f5967f6253f9a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d0772abdde612f1f5967f6253f9a93">&#9670;&nbsp;</a></span>createSparseGlobalMesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt;<a class="el" href="structCajita_1_1SparseMesh.html">SparseMesh</a>&lt;Scalar, NumSpaceDim&gt; &gt; &gt; Cajita::createSparseGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_low_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_high_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create sparse mesh with uniform cell size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Mesh floating point type. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>Spatial dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_low_corner,global_high_corner</td><td>Location of the mesh corner. </td></tr>
    <tr><td class="paramname">cell_size</td><td>Array ofuniform cell size per dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0bb56f113356a47470331f61420fb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bb56f113356a47470331f61420fb17">&#9670;&nbsp;</a></span>createSubarray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, typename <a class="el" href="classCajita_1_1Array.html">Array</a>&lt;Scalar, EntityType, MeshType, Params...&gt;::subview_layout, typename <a class="el" href="classCajita_1_1Array.html">Array</a>&lt;Scalar, EntityType, MeshType, Params...&gt;::device_type, typename <a class="el" href="classCajita_1_1Array.html">Array</a>&lt;Scalar, EntityType, MeshType, Params...&gt;::subview_memory_traits&gt; &gt; Cajita::createSubarray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; Scalar, EntityType, MeshType, Params... &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dof_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dof_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a subarray of the given array over the given range of degrees of freedom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array from which to create a subarray </td></tr>
    <tr><td class="paramname">dof_min</td><td>The minimum degree-of-freedom index of the subarray. </td></tr>
    <tr><td class="paramname">dof_max</td><td>The maximum degree-of-freedom index of the subarray. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afffd9f583a762bf067ff0d583b5e3498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffd9f583a762bf067ff0d583b5e3498">&#9670;&nbsp;</a></span>createSubview() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION auto Cajita::createSubview </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( Kokkos::subview( view, index_space.range( 0 ) ) )
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a view create a subview over the given index space. </p>
<p>Rank-1 specialization. </p>

</div>
</div>
<a id="a4594470daa8143fa9a8f65e5689c3ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4594470daa8143fa9a8f65e5689c3ae7">&#9670;&nbsp;</a></span>createSubview() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION auto Cajita::createSubview </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( Kokkos::subview( view, index_space.range( 0 ),
                                  index_space.range( 1 ) ) )
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a view create a subview over the given index space. </p>
<p>Rank-2 specialization. </p>

</div>
</div>
<a id="aeb002d4e9b61930c1478eaf4f00d610f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb002d4e9b61930c1478eaf4f00d610f">&#9670;&nbsp;</a></span>createSubview() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION auto Cajita::createSubview </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( Kokkos::subview( view, index_space.range( 0 ),
                                  index_space.range( 1 ),
                                  index_space.range( 2 ) ) )
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a view create a subview over the given index space. </p>
<p>Rank-3 specialization. </p>

</div>
</div>
<a id="a413c2645baa122d4cb8f079597e43fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413c2645baa122d4cb8f079597e43fce">&#9670;&nbsp;</a></span>createSubview() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION auto Cajita::createSubview </td>
          <td>(</td>
          <td class="paramtype">const ViewType &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( Kokkos::subview( view, index_space.range( 0 ),
                                  index_space.range( 1 ),
                                  index_space.range( 2 ),
                                  index_space.range( 3 ) ) )
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a view create a subview over the given index space. </p>
<p>Rank-4 specialization. </p>

</div>
</div>
<a id="a6f262a89b1f8f46287b3fdff3e4af246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f262a89b1f8f46287b3fdff3e4af246">&#9670;&nbsp;</a></span>createUniformGlobalMesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt;<a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt;Scalar, NumSpaceDim&gt; &gt; &gt; Cajita::createUniformGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_low_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_high_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>cell_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create uniform mesh with uniform cell size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Mesh floating point type. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>Spatial dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_low_corner,global_high_corner</td><td>Location of the mesh corner. </td></tr>
    <tr><td class="paramname">cell_size</td><td>Uniform cell size for every dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf6aa1db126fd8f20c06d5f67a92072c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6aa1db126fd8f20c06d5f67a92072c">&#9670;&nbsp;</a></span>createUniformGlobalMesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt;<a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt;Scalar, NumSpaceDim&gt; &gt; &gt; Cajita::createUniformGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_low_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_high_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_num_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create uniform mesh with total number of cells. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Mesh floating point type. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>Spatial dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_low_corner,global_high_corner</td><td>Location of the mesh corner. </td></tr>
    <tr><td class="paramname">global_num_cell</td><td>Array ofnumber of cells per dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21fe9a0a1819d0b6066f0a562e9b77b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fe9a0a1819d0b6066f0a562e9b77b1">&#9670;&nbsp;</a></span>createUniformGlobalMesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , std::size_t NumSpaceDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCajita_1_1GlobalMesh.html">GlobalMesh</a>&lt;<a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt;Scalar, NumSpaceDim&gt; &gt; &gt; Cajita::createUniformGlobalMesh </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_low_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_high_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Scalar, NumSpaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create uniform mesh with uniform cell size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Mesh floating point type. </td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>Spatial dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_low_corner,global_high_corner</td><td>Location of the mesh corner. </td></tr>
    <tr><td class="paramname">cell_size</td><td>Array ofuniform cell size per dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9531df705fdc2660fb29dd3eb8714335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9531df705fdc2660fb29dd3eb8714335">&#9670;&nbsp;</a></span>createView() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt;Scalar*, Params..., Kokkos::MemoryUnmanaged&gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space and a data pointer create an unmanaged view over the extent of that index space. </p>
<p>Rank-1 specialization. </p>

</div>
</div>
<a id="a8398eaf0e455595702b01831c98bce5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8398eaf0e455595702b01831c98bce5d">&#9670;&nbsp;</a></span>createView() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt;Scalar**, Params..., Kokkos::MemoryUnmanaged&gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space and a data pointer create an unmanaged view over the extent of that index space. </p>
<p>Rank-2 specialization. </p>

</div>
</div>
<a id="a54a42bef35610957e3f42e20cf99d308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a42bef35610957e3f42e20cf99d308">&#9670;&nbsp;</a></span>createView() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt;Scalar***, Params..., Kokkos::MemoryUnmanaged&gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space and a data pointer create an unmanaged view over the extent of that index space. </p>
<p>Rank-3 specialization. </p>

</div>
</div>
<a id="a1300fe5c384cf540da45adcc844f5043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1300fe5c384cf540da45adcc844f5043">&#9670;&nbsp;</a></span>createView() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt;Scalar****, Params..., Kokkos::MemoryUnmanaged&gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space and a data pointer create an unmanaged view over the extent of that index space. </p>
<p>Rank-4 specialization. </p>

</div>
</div>
<a id="a99d5b9427668544de95ae7e1754fbdf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d5b9427668544de95ae7e1754fbdf2">&#9670;&nbsp;</a></span>createView() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt;Scalar*, Params...&gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space create a view over the extent of that index space. </p>
<p>Rank-1 specialization. </p>

</div>
</div>
<a id="a9bbf7e52233435ee3179f05461f4a38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbf7e52233435ee3179f05461f4a38c">&#9670;&nbsp;</a></span>createView() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt;Scalar**, Params...&gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space create a view over the extent of that index space. </p>
<p>Rank-2 specialization. </p>

</div>
</div>
<a id="ac0660da3fcb7e7de7f8ae6277f325542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0660da3fcb7e7de7f8ae6277f325542">&#9670;&nbsp;</a></span>createView() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt;Scalar***, Params...&gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space create a view over the extent of that index space. </p>
<p>Rank-3 specialization. </p>

</div>
</div>
<a id="ab8b7eb24eebb49037bcacf78dc726b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b7eb24eebb49037bcacf78dc726b3b">&#9670;&nbsp;</a></span>createView() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Kokkos::View&lt;Scalar****, Params...&gt; Cajita::createView </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an index space create a view over the extent of that index space. </p>
<p>Rank-4 specialization. </p>

</div>
</div>
<a id="a46994b4aad6692cf5cdd9fff08c578d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46994b4aad6692cf5cdd9fff08c578d0">&#9670;&nbsp;</a></span>g2p()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointEvalFunctor , class PointCoordinates , class ArrayScalar , class MeshScalar , class EntityType , int SplineOrder, std::size_t NumSpaceDim, class DeviceType , class... ArrayParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::g2p </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1Array.html">Array</a>&lt; ArrayScalar, EntityType, <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; MeshScalar, NumSpaceDim &gt;, ArrayParams... &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1Halo.html">Halo</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointCoordinates &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCajita_1_1Spline.html">Spline</a>&lt; SplineOrder &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointEvalFunctor &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> Grid-to-Point interpolation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointEvalFunctor</td><td>Functor type used to evaluate the interpolated data for a given point at a given entity.</td></tr>
    <tr><td class="paramname">PointCoordinates</td><td>Container type with view traits containing the point coordinates. Will be indexed as (point,dim).</td></tr>
    <tr><td class="paramname">ArrayScalar</td><td>The scalar type used for the interpolated data.</td></tr>
    <tr><td class="paramname">MeshScalar</td><td>The scalar type used for the geometry/interpolation data.</td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>The spatial dimension of the mesh.</td></tr>
    <tr><td class="paramname">EntityType</td><td>The entitytype to which the points will interpolate.</td></tr>
    <tr><td class="paramname">SplineOrder</td><td>The order of spline interpolation to use.</td></tr>
    <tr><td class="paramname">DeviceType</td><td>The device type to use for interplation</td></tr>
    <tr><td class="paramname">ArrayParams</td><td>Parameters for the array type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The grid array from which the point data will be interpolated.</td></tr>
    <tr><td class="paramname">halo</td><td>The halo associated with the grid array. This hallo will be used to gather the array data before interpolation.</td></tr>
    <tr><td class="paramname">points</td><td>The points over which to perform the interpolation. Will be indexed as (point,dim). The subset of indices in each point's interpolation stencil must be contained within the local grid that will be used for the interpolation</td></tr>
    <tr><td class="paramname">num_point</td><td>The number of points. This is the size of the first dimension of points.</td></tr>
    <tr><td class="paramname">functor</td><td>A functor that interpolates from a given entity to a given point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> of SplineOrder passed for interpolation. </dd></dl>

</div>
</div>
<a id="a1c57f5f0f71a9195f375410205a2df20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c57f5f0f71a9195f375410205a2df20">&#9670;&nbsp;</a></span>grid_parallel_for() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class ExecutionSpace , long N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a functor in parallel with a multidimensional execution policy specified by the given index space. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">N</td><td>The dimension of the index space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">index_space</td><td>The index space over which to loop.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a644313d527fab5a1d9e59a138f51ec63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644313d527fab5a1d9e59a138f51ec63">&#9670;&nbsp;</a></span>grid_parallel_for() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class WorkTag , class ExecutionSpace , long N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorkTag &amp;&#160;</td>
          <td class="paramname"><em>work_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a functor with a work tag in parallel with a multidimensional execution policy specified by the given index space. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">WorkTag</td><td>The functor execution tag.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">N</td><td>The dimension of the index space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">index_space</td><td>The index space over which to loop.</td></tr>
    <tr><td class="paramname">work_tag</td><td>The functor execution tag.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45372f78f3e6880b22331ef24d113e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45372f78f3e6880b22331ef24d113e6e">&#9670;&nbsp;</a></span>grid_parallel_for() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class ExecutionSpace , std::size_t NumSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::Array&lt; <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 2 &gt;, NumSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a functor in parallel with a linear execution policy specified by the set of given index spaces. 2D specialization. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">NumSpace</td><td>The number of index spaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">index_spaces</td><td>The set of index spaces over which to loop.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute. Signature is f(space_id,i,j) space_id is the index of the index space in index_spaces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7824cb8412bd64ae4056c428f36c1c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7824cb8412bd64ae4056c428f36c1c9c">&#9670;&nbsp;</a></span>grid_parallel_for() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class ExecutionSpace , std::size_t NumSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::Array&lt; <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 3 &gt;, NumSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a functor in parallel with a linear execution policy specified by the set of given index spaces. 3D specialization. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">NumSpace</td><td>The number of index spaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">index_spaces</td><td>The set of index spaces over which to loop.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute. Signature is f(space_id,i,j,k) space_id is the index of the index space in index_spaces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afda357df1d146e578d38366e081b6624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda357df1d146e578d38366e081b6624">&#9670;&nbsp;</a></span>grid_parallel_for() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class ExecutionSpace , std::size_t NumSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::Array&lt; <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; 4 &gt;, NumSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a functor in parallel with a linear execution policy specified by the set of given index spaces. 4D specialization. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">NumSpace</td><td>The number of index spaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">index_spaces</td><td>The set of index spaces over which to loop.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute. Signature is f(space_id,i,j,k,l) space_id is the index of the index space in index_spaces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cc2c75279e73a954b280239e841b444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc2c75279e73a954b280239e841b444">&#9670;&nbsp;</a></span>grid_parallel_for() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DecompositionType &amp;&#160;</td>
          <td class="paramname"><em>decomposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EntityType &amp;&#160;</td>
          <td class="paramname"><em>entity_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a functor in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">MeshType</td><td>The mesh type of the local grid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">local_grid</td><td>The local grid to iterate over.</td></tr>
    <tr><td class="paramname">decomposition</td><td>The decomposition type of the entities (own,ghost).</td></tr>
    <tr><td class="paramname">entity_type</td><td>The entity type over which to loop.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2e1b082bbdd2df7693ce178f4d33749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e1b082bbdd2df7693ce178f4d33749">&#9670;&nbsp;</a></span>grid_parallel_for() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class WorkTag , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_for </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DecompositionType &amp;&#160;</td>
          <td class="paramname"><em>decomposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EntityType &amp;&#160;</td>
          <td class="paramname"><em>entity_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorkTag &amp;&#160;</td>
          <td class="paramname"><em>work_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a functor with a work tag in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">WorkTag</td><td>The functor work tag.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">MeshType</td><td>The mesh type of the local grid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">local_grid</td><td>The local grid to iterate over.</td></tr>
    <tr><td class="paramname">decomposition</td><td>The decomposition type of the entities (own,ghost).</td></tr>
    <tr><td class="paramname">entity_type</td><td>The entity type over which to loop.</td></tr>
    <tr><td class="paramname">work_tag</td><td>The functor execution tag.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2a58a3b10046140ae6a75b252dbade6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a58a3b10046140ae6a75b252dbade6">&#9670;&nbsp;</a></span>grid_parallel_reduce() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class ExecutionSpace , long N, class ReduceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a reduction functor in parallel with a multidimensional execution policy specified by the given index space. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">N</td><td>The dimension of the index space.</td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">index_space</td><td>The index space over which to loop.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute.</td></tr>
    <tr><td class="paramname">reducer</td><td>The parallel reduce result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3578b89bdd7bd62f95ff985a77b8986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3578b89bdd7bd62f95ff985a77b8986">&#9670;&nbsp;</a></span>grid_parallel_reduce() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class WorkTag , class ExecutionSpace , long N, class ReduceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1IndexSpace.html">IndexSpace</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorkTag &amp;&#160;</td>
          <td class="paramname"><em>work_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a reduction functor with a work tag in parallel with a multidimensional execution policy specified by the given index space. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">WorkTag</td><td>The functor execution tag.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">N</td><td>The dimension of the index space.</td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">index_space</td><td>The index space over which to loop.</td></tr>
    <tr><td class="paramname">work_tag</td><td>The functor execution tag.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute.</td></tr>
    <tr><td class="paramname">reducer</td><td>The parallel reduce result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14f60204e3f1448420140403bc39d3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f60204e3f1448420140403bc39d3ea">&#9670;&nbsp;</a></span>grid_parallel_reduce() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType , class ReduceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DecompositionType &amp;&#160;</td>
          <td class="paramname"><em>decomposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EntityType &amp;&#160;</td>
          <td class="paramname"><em>entity_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a reduction functor in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">MeshType</td><td>The mesh type of the local grid.</td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">local_grid</td><td>The local grid to iterate over.</td></tr>
    <tr><td class="paramname">decomposition</td><td>The decomposition type of the entities (own,ghost).</td></tr>
    <tr><td class="paramname">entity_type</td><td>The entity type over which to loop.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute.</td></tr>
    <tr><td class="paramname">reducer</td><td>The parallel reduce result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa10581196134700af84ad9a4b73f2ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10581196134700af84ad9a4b73f2ed4">&#9670;&nbsp;</a></span>grid_parallel_reduce() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class WorkTag , class ExecutionSpace , class MeshType , class DecompositionType , class EntityType , class ReduceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::grid_parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExecutionSpace &amp;&#160;</td>
          <td class="paramname"><em>exec_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1LocalGrid.html">LocalGrid</a>&lt; MeshType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DecompositionType &amp;&#160;</td>
          <td class="paramname"><em>decomposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EntityType &amp;&#160;</td>
          <td class="paramname"><em>entity_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorkTag &amp;&#160;</td>
          <td class="paramname"><em>work_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctorType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceType &amp;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a reduction functor with a work tag in parallel with a multidimensional execution policy specified by the given local grid, decomposition, and entity type. The loop indices are local. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>The functor type to execute.</td></tr>
    <tr><td class="paramname">WorkTag</td><td>The functor work tag.</td></tr>
    <tr><td class="paramname">ExecutionSpace</td><td>The execution space type.</td></tr>
    <tr><td class="paramname">MeshType</td><td>The mesh type of the local grid.</td></tr>
    <tr><td class="paramname">ReduceType</td><td>The reduction type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Parallel region label.</td></tr>
    <tr><td class="paramname">exec_space</td><td>An execution space instance.</td></tr>
    <tr><td class="paramname">decomposition</td><td>The decomposition type of the entities (own,ghost).</td></tr>
    <tr><td class="paramname">local_grid</td><td>The local grid to iterate over.</td></tr>
    <tr><td class="paramname">entity_type</td><td>The entity type over which to loop.</td></tr>
    <tr><td class="paramname">work_tag</td><td>The functor execution tag.</td></tr>
    <tr><td class="paramname">functor</td><td>The functor to execute.</td></tr>
    <tr><td class="paramname">reducer</td><td>The parallel reduce result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a583a9ee0c0e31310b730fa3ca3819721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583a9ee0c0e31310b730fa3ca3819721">&#9670;&nbsp;</a></span>migrateCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalGridType , class PositionSliceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Cajita::migrateCount </td>
          <td>(</td>
          <td class="paramtype">const LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionSliceType &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>minimum_halo_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for the number of particles that must be communicated. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LocalGridType</td><td><a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> type.</td></tr>
    <tr><td class="paramname">PositionSliceType</td><td>Particle position type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_grid</td><td>The local grid containing periodicity and system bound information.</td></tr>
    <tr><td class="paramname">positions</td><td>The particle position container, either Slice or View.</td></tr>
    <tr><td class="paramname">minimum_halo_width</td><td>Number of halo mesh widths to include for ghosting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af35c1fd6167a736a6a78cf742c2d6251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35c1fd6167a736a6a78cf742c2d6251">&#9670;&nbsp;</a></span>p2g()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointEvalFunctor , class PointCoordinates , class ArrayScalar , class MeshScalar , std::size_t NumSpaceDim, class EntityType , int SplineOrder, class DeviceType , class... ArrayParams&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cajita::p2g </td>
          <td>(</td>
          <td class="paramtype">const PointEvalFunctor &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointCoordinates &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCajita_1_1Spline.html">Spline</a>&lt; SplineOrder &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCajita_1_1Halo.html">Halo</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>halo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCajita_1_1Array.html">Array</a>&lt; ArrayScalar, EntityType, <a class="el" href="structCajita_1_1UniformMesh.html">UniformMesh</a>&lt; MeshScalar, NumSpaceDim &gt;, ArrayParams... &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structCajita_1_1Global.html" title="Global index tag.">Global</a> Point-to-Grid interpolation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointEvalFunctor</td><td>Functor type used to evaluate the interpolated data for a given point at a given entity.</td></tr>
    <tr><td class="paramname">PointCoordinates</td><td>Container type with view traits containing the point coordinates. Will be indexed as (point,dim).</td></tr>
    <tr><td class="paramname">ArrayScalar</td><td>The scalar type used for the interpolated data.</td></tr>
    <tr><td class="paramname">MeshScalar</td><td>The scalar type used for the geometry/interpolation data.</td></tr>
    <tr><td class="paramname">NumSpaceDim</td><td>The spatial dimension of the mesh.</td></tr>
    <tr><td class="paramname">EntityType</td><td>The entitytype to which the points will interpolate.</td></tr>
    <tr><td class="paramname">SplineOrder</td><td>The order of spline interpolation to use.</td></tr>
    <tr><td class="paramname">DeviceType</td><td>The device type to use for interplation</td></tr>
    <tr><td class="paramname">ArrayParams</td><td>Parameters for the array type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>A functor that interpolates from a given point to a given entity.</td></tr>
    <tr><td class="paramname">points</td><td>The points over which to perform the interpolation. Will be indexed as (point,dim). The subset of indices in each point's interpolation stencil must be contained within the local grid that will be used for the interpolation</td></tr>
    <tr><td class="paramname">num_point</td><td>The number of points. This is the size of the first dimension of points.</td></tr>
    <tr><td class="paramname">halo</td><td>The halo associated with the grid array. This hallo will be used to scatter the interpolated data.</td></tr>
    <tr><td class="paramname">array</td><td>The grid array to which the point data will be interpolated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structCajita_1_1Spline.html" title="B-Spline interface for uniform grids.">Spline</a> of SplineOrder passed for interpolation. </dd></dl>

</div>
</div>
<a id="adb928c073163bff90d4ca8a7d460fe18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb928c073163bff90d4ca8a7d460fe18">&#9670;&nbsp;</a></span>particleGridMigrate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalGridType , class ParticlePositions , class ParticleContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Cajita::particleGridMigrate </td>
          <td>(</td>
          <td class="paramtype">const LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParticlePositions &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParticleContainer &amp;&#160;</td>
          <td class="paramname"><em>src_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleContainer &amp;&#160;</td>
          <td class="paramname"><em>dst_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>min_halo_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>force_migrate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrate data from one uniquely-owned decomposition to another uniquely-owned decomposition, using the bounds and periodic boundaries of a <a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> grid to determine which particles should be moved. Separate AoSoA variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LocalGridType</td><td><a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> type.</td></tr>
    <tr><td class="paramname">ParticlePositions</td><td>Particle position type.</td></tr>
    <tr><td class="paramname">ParticleContainer</td><td>AoSoA type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_grid</td><td>The local grid containing periodicity and system bounds.</td></tr>
    <tr><td class="paramname">positions</td><td>Particle positions.</td></tr>
    <tr><td class="paramname">src_particles</td><td>The source particle AoSoA.</td></tr>
    <tr><td class="paramname">dst_particles</td><td>The destination particle AoSoA.</td></tr>
    <tr><td class="paramname">min_halo_width</td><td>Number of halo mesh widths to allow particles before migrating.</td></tr>
    <tr><td class="paramname">force_migrate</td><td>Migrate particles outside the local domain regardless of ghosted halo. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4371257b756699167df4544e4f2de13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4371257b756699167df4544e4f2de13">&#9670;&nbsp;</a></span>particleGridMigrate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalGridType , class ParticlePositions , class ParticleContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Cajita::particleGridMigrate </td>
          <td>(</td>
          <td class="paramtype">const LocalGridType &amp;&#160;</td>
          <td class="paramname"><em>local_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParticlePositions &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleContainer &amp;&#160;</td>
          <td class="paramname"><em>particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>min_halo_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>force_migrate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrate data from one uniquely-owned decomposition to another uniquely-owned decomposition, using the bounds and periodic boundaries of a <a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> grid to determine which particles should be moved. In-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LocalGridType</td><td><a class="el" href="namespaceCajita.html" title="Cajita: grid and particle-grid data structures and algorithms.">Cajita</a> <a class="el" href="classCajita_1_1LocalGrid.html" title="Local logical grid.">LocalGrid</a> type.</td></tr>
    <tr><td class="paramname">ParticlePositions</td><td>Particle position type.</td></tr>
    <tr><td class="paramname">PositionContainer</td><td>AoSoA type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_grid</td><td>The local grid containing periodicity and system bounds.</td></tr>
    <tr><td class="paramname">positions</td><td>Particle positions.</td></tr>
    <tr><td class="paramname">particles</td><td>The particle AoSoA.</td></tr>
    <tr><td class="paramname">min_halo_width</td><td>Number of halo mesh widths to allow particles before migrating.</td></tr>
    <tr><td class="paramname">force_migrate</td><td>Migrate particles outside the local domain regardless of ghosted halo. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
