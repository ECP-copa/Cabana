<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cabana: Cabana::Grid::ReferenceConjugateGradient&lt; Scalar, EntityType, MeshType, MemorySpace &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cabana<span id="projectnumber">&#160;0.7.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceCabana.html">Cabana</a></li><li class="navelem"><b>Grid</b></li><li class="navelem"><a class="el" href="classCabana_1_1Grid_1_1ReferenceConjugateGradient.html">ReferenceConjugateGradient</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classCabana_1_1Grid_1_1ReferenceConjugateGradient-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Cabana::Grid::ReferenceConjugateGradient&lt; Scalar, EntityType, MeshType, MemorySpace &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Reference structured preconditioned block conjugate gradient implementation.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Cabana__Grid__ReferenceStructuredSolver_8hpp_source.html">Cabana_Grid_ReferenceStructuredSolver.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Cabana::Grid::ReferenceConjugateGradient&lt; Scalar, EntityType, MeshType, MemorySpace &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classCabana_1_1Grid_1_1ReferenceConjugateGradient__inherit__graph.png" border="0" usemap="#aCabana_1_1Grid_1_1ReferenceConjugateGradient_3_01Scalar_00_01EntityType_00_01MeshType_00_01MemorySpace_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aCabana_1_1Grid_1_1ReferenceConjugateGradient_3_01Scalar_00_01EntityType_00_01MeshType_00_01MemorySpace_01_4_inherit__map" id="aCabana_1_1Grid_1_1ReferenceConjugateGradient_3_01Scalar_00_01EntityType_00_01MeshType_00_01MemorySpace_01_4_inherit__map">
<area shape="rect" title="Reference structured preconditioned block conjugate gradient implementation." alt="" coords="293,5,529,73"/>
<area shape="rect" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html" title="Reference preconditioned structured solver interface." alt="" coords="5,5,245,73"/>
<area shape="poly" title=" " alt="" coords="260,37,292,37,292,42,260,42"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Cabana::Grid::ReferenceConjugateGradient&lt; Scalar, EntityType, MeshType, MemorySpace &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classCabana_1_1Grid_1_1ReferenceConjugateGradient__coll__graph.png" border="0" usemap="#aCabana_1_1Grid_1_1ReferenceConjugateGradient_3_01Scalar_00_01EntityType_00_01MeshType_00_01MemorySpace_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aCabana_1_1Grid_1_1ReferenceConjugateGradient_3_01Scalar_00_01EntityType_00_01MeshType_00_01MemorySpace_01_4_coll__map" id="aCabana_1_1Grid_1_1ReferenceConjugateGradient_3_01Scalar_00_01EntityType_00_01MeshType_00_01MemorySpace_01_4_coll__map">
<area shape="rect" title="Reference structured preconditioned block conjugate gradient implementation." alt="" coords="293,5,529,73"/>
<area shape="rect" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html" title="Reference preconditioned structured solver interface." alt="" coords="5,5,245,73"/>
<area shape="poly" title=" " alt="" coords="260,37,292,37,292,42,260,42"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCabana_1_1Grid_1_1ReferenceConjugateGradient_1_1LayoutContainer.html">LayoutContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array-like container to hold layout and data information.  <a href="structCabana_1_1Grid_1_1ReferenceConjugateGradient_1_1LayoutContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac7f3d3c36a7d9d24da1b2c8a03860cdd" id="r_ac7f3d3c36a7d9d24da1b2c8a03860cdd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7f3d3c36a7d9d24da1b2c8a03860cdd">base_type</a></td></tr>
<tr class="memdesc:ac7f3d3c36a7d9d24da1b2c8a03860cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type.  <br /></td></tr>
<tr class="separator:ac7f3d3c36a7d9d24da1b2c8a03860cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69a0507282c275cc2d57d7568f2a12f" id="r_ae69a0507282c275cc2d57d7568f2a12f"><td class="memItemLeft" align="right" valign="top"><a id="ae69a0507282c275cc2d57d7568f2a12f" name="ae69a0507282c275cc2d57d7568f2a12f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>memory_space</b> = typename <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#a6955023f860e0d7424462b79f1791069">base_type::memory_space</a></td></tr>
<tr class="memdesc:ae69a0507282c275cc2d57d7568f2a12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory space. <br /></td></tr>
<tr class="separator:ae69a0507282c275cc2d57d7568f2a12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e39fc1ea286af8fbbd5bb461d264819" id="r_a2e39fc1ea286af8fbbd5bb461d264819"><td class="memItemLeft" align="right" valign="top"><a id="a2e39fc1ea286af8fbbd5bb461d264819" name="a2e39fc1ea286af8fbbd5bb461d264819"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>execution_space</b> = typename <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#a6757092c68fb2661a726e5eb54c944ff">base_type::execution_space</a></td></tr>
<tr class="memdesc:a2e39fc1ea286af8fbbd5bb461d264819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default execution space. <br /></td></tr>
<tr class="separator:a2e39fc1ea286af8fbbd5bb461d264819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29e5752276b3309f447d7b994f1f916" id="r_ab29e5752276b3309f447d7b994f1f916"><td class="memItemLeft" align="right" valign="top"><a id="ab29e5752276b3309f447d7b994f1f916" name="ab29e5752276b3309f447d7b994f1f916"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>entity_type</b> = typename <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#acbe2d1fe9a68cbc87fb1e156393c977f">base_type::entity_type</a></td></tr>
<tr class="memdesc:ab29e5752276b3309f447d7b994f1f916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity type. <br /></td></tr>
<tr class="separator:ab29e5752276b3309f447d7b994f1f916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cf0dc95ff712751cb2b42d2ffc98e7" id="r_ad5cf0dc95ff712751cb2b42d2ffc98e7"><td class="memItemLeft" align="right" valign="top"><a id="ad5cf0dc95ff712751cb2b42d2ffc98e7" name="ad5cf0dc95ff712751cb2b42d2ffc98e7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = typename <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#aed0b1d80cc3280f43570e0f0029cc00a">base_type::value_type</a></td></tr>
<tr class="memdesc:ad5cf0dc95ff712751cb2b42d2ffc98e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar value type. <br /></td></tr>
<tr class="separator:ad5cf0dc95ff712751cb2b42d2ffc98e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45709e608e68e61c856c16f3b8b9995a" id="r_a45709e608e68e61c856c16f3b8b9995a"><td class="memItemLeft" align="right" valign="top"><a id="a45709e608e68e61c856c16f3b8b9995a" name="a45709e608e68e61c856c16f3b8b9995a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Array_t</b> = typename <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#af0b0cfd2ab47490fd2693945bd5f255f">base_type::Array_t</a></td></tr>
<tr class="memdesc:a45709e608e68e61c856c16f3b8b9995a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1Grid_1_1Array.html" title="Array of field data on the local mesh.">Array</a> type. <br /></td></tr>
<tr class="separator:a45709e608e68e61c856c16f3b8b9995a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9379045db1c90394ddc1d1399e16a907" id="r_a9379045db1c90394ddc1d1399e16a907"><td class="memItemLeft" align="right" valign="top"><a id="a9379045db1c90394ddc1d1399e16a907" name="a9379045db1c90394ddc1d1399e16a907"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>subarray_type</b> = typename <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#a4283f64c8ff45e352eccd3bbdab673a5">base_type::subarray_type</a></td></tr>
<tr class="memdesc:a9379045db1c90394ddc1d1399e16a907"><td class="mdescLeft">&#160;</td><td class="mdescRight">SubArray type. <br /></td></tr>
<tr class="separator:a9379045db1c90394ddc1d1399e16a907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html">Cabana::Grid::ReferenceStructuredSolver&lt; Scalar, EntityType, MeshType, MemorySpace &gt;</a></td></tr>
<tr class="memitem:acbe2d1fe9a68cbc87fb1e156393c977f inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver" id="r_acbe2d1fe9a68cbc87fb1e156393c977f"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>entity_type</b> = EntityType</td></tr>
<tr class="memdesc:acbe2d1fe9a68cbc87fb1e156393c977f inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity type. <br /></td></tr>
<tr class="separator:acbe2d1fe9a68cbc87fb1e156393c977f inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0b1d80cc3280f43570e0f0029cc00a inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver" id="r_aed0b1d80cc3280f43570e0f0029cc00a"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = Scalar</td></tr>
<tr class="memdesc:aed0b1d80cc3280f43570e0f0029cc00a inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar value type. <br /></td></tr>
<tr class="separator:aed0b1d80cc3280f43570e0f0029cc00a inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6955023f860e0d7424462b79f1791069 inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver" id="r_a6955023f860e0d7424462b79f1791069"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>memory_space</b> = typename MemorySpace::memory_space</td></tr>
<tr class="memdesc:a6955023f860e0d7424462b79f1791069 inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory space. <br /></td></tr>
<tr class="separator:a6955023f860e0d7424462b79f1791069 inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6757092c68fb2661a726e5eb54c944ff inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver" id="r_a6757092c68fb2661a726e5eb54c944ff"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>execution_space</b> = typename memory_space::execution_space</td></tr>
<tr class="memdesc:a6757092c68fb2661a726e5eb54c944ff inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default execution space. <br /></td></tr>
<tr class="separator:a6757092c68fb2661a726e5eb54c944ff inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b0cfd2ab47490fd2693945bd5f255f inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver" id="r_af0b0cfd2ab47490fd2693945bd5f255f"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>Array_t</b> = <a class="el" href="classCabana_1_1Grid_1_1Array.html">Array</a>&lt;Scalar, EntityType, MeshType, MemorySpace&gt;</td></tr>
<tr class="memdesc:af0b0cfd2ab47490fd2693945bd5f255f inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCabana_1_1Grid_1_1Array.html" title="Array of field data on the local mesh.">Array</a> type. <br /></td></tr>
<tr class="separator:af0b0cfd2ab47490fd2693945bd5f255f inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4283f64c8ff45e352eccd3bbdab673a5 inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver" id="r_a4283f64c8ff45e352eccd3bbdab673a5"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>subarray_type</b> = typename <a class="el" href="classCabana_1_1Grid_1_1Array.html#afcb8994675007a56e9dc4229c687e9c3">Array_t::subarray_type</a></td></tr>
<tr class="memdesc:a4283f64c8ff45e352eccd3bbdab673a5 inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">SubArray type. <br /></td></tr>
<tr class="separator:a4283f64c8ff45e352eccd3bbdab673a5 inherit pub_types_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a21aa9cf6fcb57c86b7d65f1160b40946" id="r_a21aa9cf6fcb57c86b7d65f1160b40946"><td class="memItemLeft" align="right" valign="top"><a id="a21aa9cf6fcb57c86b7d65f1160b40946" name="a21aa9cf6fcb57c86b7d65f1160b40946"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ReferenceConjugateGradient</b> (const <a class="el" href="classCabana_1_1Grid_1_1ArrayLayout.html">ArrayLayout</a>&lt; EntityType, MeshType &gt; &amp;layout)</td></tr>
<tr class="memdesc:a21aa9cf6fcb57c86b7d65f1160b40946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a21aa9cf6fcb57c86b7d65f1160b40946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e95f11e97a561ce89e087dc0624c6f6" id="r_a1e95f11e97a561ce89e087dc0624c6f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e95f11e97a561ce89e087dc0624c6f6">setMatrixStencil</a> (const std::vector&lt; std::array&lt; int, <a class="el" href="#a0ec23475997d91a174c0c7451208cf2b">num_space_dim</a> &gt; &gt; &amp;stencil, const bool is_symmetric=false) override</td></tr>
<tr class="memdesc:a1e95f11e97a561ce89e087dc0624c6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the matrix stencil.  <br /></td></tr>
<tr class="separator:a1e95f11e97a561ce89e087dc0624c6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb008243084bfa87b33c5b190676ffb1" id="r_abb008243084bfa87b33c5b190676ffb1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a45709e608e68e61c856c16f3b8b9995a">Array_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb008243084bfa87b33c5b190676ffb1">getMatrixValues</a> () override</td></tr>
<tr class="memdesc:abb008243084bfa87b33c5b190676ffb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the matrix values.  <br /></td></tr>
<tr class="separator:abb008243084bfa87b33c5b190676ffb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a31f4636749b135b83796b5beac2aa" id="r_a80a31f4636749b135b83796b5beac2aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80a31f4636749b135b83796b5beac2aa">setPreconditionerStencil</a> (const std::vector&lt; std::array&lt; int, <a class="el" href="#a0ec23475997d91a174c0c7451208cf2b">num_space_dim</a> &gt; &gt; &amp;stencil, const bool is_symmetric=false) override</td></tr>
<tr class="memdesc:a80a31f4636749b135b83796b5beac2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the preconditioner stencil.  <br /></td></tr>
<tr class="separator:a80a31f4636749b135b83796b5beac2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490cfbb5d3d2f2561d72fbe619ad50c2" id="r_a490cfbb5d3d2f2561d72fbe619ad50c2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a45709e608e68e61c856c16f3b8b9995a">Array_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a490cfbb5d3d2f2561d72fbe619ad50c2">getPreconditionerValues</a> () override</td></tr>
<tr class="memdesc:a490cfbb5d3d2f2561d72fbe619ad50c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the preconditioner values.  <br /></td></tr>
<tr class="separator:a490cfbb5d3d2f2561d72fbe619ad50c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83901d876357683a1e93e7501eeb8619" id="r_a83901d876357683a1e93e7501eeb8619"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83901d876357683a1e93e7501eeb8619">setTolerance</a> (const double tol) override</td></tr>
<tr class="memdesc:a83901d876357683a1e93e7501eeb8619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set convergence tolerance implementation.  <br /></td></tr>
<tr class="separator:a83901d876357683a1e93e7501eeb8619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e90ba9cf937fdc4e463e77bdaefb15" id="r_a49e90ba9cf937fdc4e463e77bdaefb15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49e90ba9cf937fdc4e463e77bdaefb15">setMaxIter</a> (const int max_iter) override</td></tr>
<tr class="memdesc:a49e90ba9cf937fdc4e463e77bdaefb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum iteration implementation.  <br /></td></tr>
<tr class="separator:a49e90ba9cf937fdc4e463e77bdaefb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe96264cbb7d9d132fc8fdcd85cfdcc" id="r_abfe96264cbb7d9d132fc8fdcd85cfdcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfe96264cbb7d9d132fc8fdcd85cfdcc">setPrintLevel</a> (const int print_level) override</td></tr>
<tr class="memdesc:abfe96264cbb7d9d132fc8fdcd85cfdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output level.  <br /></td></tr>
<tr class="separator:abfe96264cbb7d9d132fc8fdcd85cfdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068cfb76c89de17d1d78df8c09e1b713" id="r_a068cfb76c89de17d1d78df8c09e1b713"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a068cfb76c89de17d1d78df8c09e1b713">setup</a> () override</td></tr>
<tr class="memdesc:a068cfb76c89de17d1d78df8c09e1b713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the problem.  <br /></td></tr>
<tr class="separator:a068cfb76c89de17d1d78df8c09e1b713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160eddb43931fec3838d9024e2bdf573" id="r_a160eddb43931fec3838d9024e2bdf573"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a160eddb43931fec3838d9024e2bdf573">solve</a> (const <a class="el" href="#a45709e608e68e61c856c16f3b8b9995a">Array_t</a> &amp;b, <a class="el" href="#a45709e608e68e61c856c16f3b8b9995a">Array_t</a> &amp;x) override</td></tr>
<tr class="memdesc:a160eddb43931fec3838d9024e2bdf573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the problem Ax = b for x.  <br /></td></tr>
<tr class="separator:a160eddb43931fec3838d9024e2bdf573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab749f9fced17b478691e7f11e14507da" id="r_ab749f9fced17b478691e7f11e14507da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab749f9fced17b478691e7f11e14507da">getNumIter</a> () override</td></tr>
<tr class="memdesc:ab749f9fced17b478691e7f11e14507da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of iterations taken on the last solve.  <br /></td></tr>
<tr class="separator:ab749f9fced17b478691e7f11e14507da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb2a63fa8a4b50028b99d2e6a92d0f6" id="r_abbb2a63fa8a4b50028b99d2e6a92d0f6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbb2a63fa8a4b50028b99d2e6a92d0f6">getFinalRelativeResidualNorm</a> () override</td></tr>
<tr class="memdesc:abbb2a63fa8a4b50028b99d2e6a92d0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the relative residual norm achieved on the last solve.  <br /></td></tr>
<tr class="separator:abbb2a63fa8a4b50028b99d2e6a92d0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0ec23475997d91a174c0c7451208cf2b" id="r_a0ec23475997d91a174c0c7451208cf2b"><td class="memItemLeft" align="right" valign="top"><a id="a0ec23475997d91a174c0c7451208cf2b" name="a0ec23475997d91a174c0c7451208cf2b"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_space_dim</b> = MeshType::num_space_dim</td></tr>
<tr class="memdesc:a0ec23475997d91a174c0c7451208cf2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial dimension. <br /></td></tr>
<tr class="separator:a0ec23475997d91a174c0c7451208cf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_attribs_classCabana_1_1Grid_1_1ReferenceStructuredSolver')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html">Cabana::Grid::ReferenceStructuredSolver&lt; Scalar, EntityType, MeshType, MemorySpace &gt;</a></td></tr>
<tr class="memitem:a968b22b4383f0aecdc0fb7ec6fdd7545 inherit pub_static_attribs_classCabana_1_1Grid_1_1ReferenceStructuredSolver" id="r_a968b22b4383f0aecdc0fb7ec6fdd7545"><td class="memItemLeft" align="right" valign="top">
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_space_dim</b> = MeshType::num_space_dim</td></tr>
<tr class="memdesc:a968b22b4383f0aecdc0fb7ec6fdd7545 inherit pub_static_attribs_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial dimension. <br /></td></tr>
<tr class="separator:a968b22b4383f0aecdc0fb7ec6fdd7545 inherit pub_static_attribs_classCabana_1_1Grid_1_1ReferenceStructuredSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Scalar, class EntityType, class MeshType, class MemorySpace&gt;<br />
class Cabana::Grid::ReferenceConjugateGradient&lt; Scalar, EntityType, MeshType, MemorySpace &gt;</div><p>Reference structured preconditioned block conjugate gradient implementation. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac7f3d3c36a7d9d24da1b2c8a03860cdd" name="ac7f3d3c36a7d9d24da1b2c8a03860cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f3d3c36a7d9d24da1b2c8a03860cdd">&#9670;&#160;</a></span>base_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class MemorySpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classCabana_1_1Grid_1_1ReferenceConjugateGradient.html">Cabana::Grid::ReferenceConjugateGradient</a>&lt; Scalar, EntityType, MeshType, MemorySpace &gt;::base_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">        ReferenceStructuredSolver&lt;Scalar, EntityType, MeshType, MemorySpace&gt;</div>
</div><!-- fragment -->
<p>Base type. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abbb2a63fa8a4b50028b99d2e6a92d0f6" name="abbb2a63fa8a4b50028b99d2e6a92d0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb2a63fa8a4b50028b99d2e6a92d0f6">&#9670;&#160;</a></span>getFinalRelativeResidualNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class MemorySpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classCabana_1_1Grid_1_1ReferenceConjugateGradient.html">Cabana::Grid::ReferenceConjugateGradient</a>&lt; Scalar, EntityType, MeshType, MemorySpace &gt;::getFinalRelativeResidualNorm </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the relative residual norm achieved on the last solve. </p>

<p>Implements <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#a13869c815e98be70846d04c5b423ec6d">Cabana::Grid::ReferenceStructuredSolver&lt; Scalar, EntityType, MeshType, MemorySpace &gt;</a>.</p>

</div>
</div>
<a id="abb008243084bfa87b33c5b190676ffb1" name="abb008243084bfa87b33c5b190676ffb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb008243084bfa87b33c5b190676ffb1">&#9670;&#160;</a></span>getMatrixValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class MemorySpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a45709e608e68e61c856c16f3b8b9995a">Array_t</a> &amp; <a class="el" href="classCabana_1_1Grid_1_1ReferenceConjugateGradient.html">Cabana::Grid::ReferenceConjugateGradient</a>&lt; Scalar, EntityType, MeshType, MemorySpace &gt;::getMatrixValues </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the matrix values. </p>
<dl class="section return"><dt>Returns</dt><dd>The matrix entry values. For each entity over which the vector space is defined an entry for each stencil element is required. The order of the stencil elements is that same as that in the stencil definition. Note that values corresponding to stencil entries outside of the domain should be set to zero. </dd></dl>

<p>Implements <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#a7d28618ffdeeb8a50336c6c6c74c8c7c">Cabana::Grid::ReferenceStructuredSolver&lt; Scalar, EntityType, MeshType, MemorySpace &gt;</a>.</p>

</div>
</div>
<a id="ab749f9fced17b478691e7f11e14507da" name="ab749f9fced17b478691e7f11e14507da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab749f9fced17b478691e7f11e14507da">&#9670;&#160;</a></span>getNumIter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class MemorySpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCabana_1_1Grid_1_1ReferenceConjugateGradient.html">Cabana::Grid::ReferenceConjugateGradient</a>&lt; Scalar, EntityType, MeshType, MemorySpace &gt;::getNumIter </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of iterations taken on the last solve. </p>

<p>Implements <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#afbdccf88c891d3bc898d6911fa8b5434">Cabana::Grid::ReferenceStructuredSolver&lt; Scalar, EntityType, MeshType, MemorySpace &gt;</a>.</p>

</div>
</div>
<a id="a490cfbb5d3d2f2561d72fbe619ad50c2" name="a490cfbb5d3d2f2561d72fbe619ad50c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490cfbb5d3d2f2561d72fbe619ad50c2">&#9670;&#160;</a></span>getPreconditionerValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class MemorySpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a45709e608e68e61c856c16f3b8b9995a">Array_t</a> &amp; <a class="el" href="classCabana_1_1Grid_1_1ReferenceConjugateGradient.html">Cabana::Grid::ReferenceConjugateGradient</a>&lt; Scalar, EntityType, MeshType, MemorySpace &gt;::getPreconditionerValues </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the preconditioner values. </p>
<dl class="section return"><dt>Returns</dt><dd>The preconditioner entry values. For each entity over which the vector space is defined an entry for each stencil element is required. The order of the stencil elements is that same as that in the stencil definition. Note that values corresponding to stencil entries outside of the domain should be set to zero. </dd></dl>

<p>Implements <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#af0a03ecf8884e1b506ff7ff8630ea715">Cabana::Grid::ReferenceStructuredSolver&lt; Scalar, EntityType, MeshType, MemorySpace &gt;</a>.</p>

</div>
</div>
<a id="a1e95f11e97a561ce89e087dc0624c6f6" name="a1e95f11e97a561ce89e087dc0624c6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e95f11e97a561ce89e087dc0624c6f6">&#9670;&#160;</a></span>setMatrixStencil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class MemorySpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1ReferenceConjugateGradient.html">Cabana::Grid::ReferenceConjugateGradient</a>&lt; Scalar, EntityType, MeshType, MemorySpace &gt;::setMatrixStencil </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::array&lt; int, <a class="el" href="#a0ec23475997d91a174c0c7451208cf2b">num_space_dim</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>stencil</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>is_symmetric</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the matrix stencil. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stencil</td><td>The (i,j,k) offsets describing the structured matrix entries at each grid point. Offsets are defined relative to an index. </td></tr>
    <tr><td class="paramname">is_symmetric</td><td>If true the matrix is designated as symmetric. The stencil entries should only contain one entry from each symmetric component if this is true. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#ac70baaf4871c4262b9c0c3ad475f863b">Cabana::Grid::ReferenceStructuredSolver&lt; Scalar, EntityType, MeshType, MemorySpace &gt;</a>.</p>

</div>
</div>
<a id="a49e90ba9cf937fdc4e463e77bdaefb15" name="a49e90ba9cf937fdc4e463e77bdaefb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e90ba9cf937fdc4e463e77bdaefb15">&#9670;&#160;</a></span>setMaxIter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class MemorySpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1ReferenceConjugateGradient.html">Cabana::Grid::ReferenceConjugateGradient</a>&lt; Scalar, EntityType, MeshType, MemorySpace &gt;::setMaxIter </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>max_iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum iteration implementation. </p>

<p>Implements <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#a0307338800128c256685536257cdcd5b">Cabana::Grid::ReferenceStructuredSolver&lt; Scalar, EntityType, MeshType, MemorySpace &gt;</a>.</p>

</div>
</div>
<a id="a80a31f4636749b135b83796b5beac2aa" name="a80a31f4636749b135b83796b5beac2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a31f4636749b135b83796b5beac2aa">&#9670;&#160;</a></span>setPreconditionerStencil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class MemorySpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1ReferenceConjugateGradient.html">Cabana::Grid::ReferenceConjugateGradient</a>&lt; Scalar, EntityType, MeshType, MemorySpace &gt;::setPreconditionerStencil </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::array&lt; int, <a class="el" href="#a0ec23475997d91a174c0c7451208cf2b">num_space_dim</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>stencil</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>is_symmetric</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the preconditioner stencil. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stencil</td><td>The (i,j,k) offsets describing the structured preconditioner entries at each grid point. Offsets are defined relative to an index.</td></tr>
    <tr><td class="paramname">is_symmetric</td><td>If true the preconditioner is designated as symmetric. The stencil entries should only contain one entry from each symmetric component if this is true. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#a6af50da848b557a36da24ff2d8f4a09a">Cabana::Grid::ReferenceStructuredSolver&lt; Scalar, EntityType, MeshType, MemorySpace &gt;</a>.</p>

</div>
</div>
<a id="abfe96264cbb7d9d132fc8fdcd85cfdcc" name="abfe96264cbb7d9d132fc8fdcd85cfdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe96264cbb7d9d132fc8fdcd85cfdcc">&#9670;&#160;</a></span>setPrintLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class MemorySpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1ReferenceConjugateGradient.html">Cabana::Grid::ReferenceConjugateGradient</a>&lt; Scalar, EntityType, MeshType, MemorySpace &gt;::setPrintLevel </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>print_level</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the output level. </p>

<p>Implements <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#af90d4e0fbc8bb569e415b39709cacf59">Cabana::Grid::ReferenceStructuredSolver&lt; Scalar, EntityType, MeshType, MemorySpace &gt;</a>.</p>

</div>
</div>
<a id="a83901d876357683a1e93e7501eeb8619" name="a83901d876357683a1e93e7501eeb8619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83901d876357683a1e93e7501eeb8619">&#9670;&#160;</a></span>setTolerance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class MemorySpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1ReferenceConjugateGradient.html">Cabana::Grid::ReferenceConjugateGradient</a>&lt; Scalar, EntityType, MeshType, MemorySpace &gt;::setTolerance </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>tol</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set convergence tolerance implementation. </p>

<p>Implements <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#acf6b630433030e6891034f2d0a3a7005">Cabana::Grid::ReferenceStructuredSolver&lt; Scalar, EntityType, MeshType, MemorySpace &gt;</a>.</p>

</div>
</div>
<a id="a068cfb76c89de17d1d78df8c09e1b713" name="a068cfb76c89de17d1d78df8c09e1b713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068cfb76c89de17d1d78df8c09e1b713">&#9670;&#160;</a></span>setup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class MemorySpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1ReferenceConjugateGradient.html">Cabana::Grid::ReferenceConjugateGradient</a>&lt; Scalar, EntityType, MeshType, MemorySpace &gt;::setup </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setup the problem. </p>

<p>Implements <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#ad4835388eca22af43e9d5f7208a26f54">Cabana::Grid::ReferenceStructuredSolver&lt; Scalar, EntityType, MeshType, MemorySpace &gt;</a>.</p>

</div>
</div>
<a id="a160eddb43931fec3838d9024e2bdf573" name="a160eddb43931fec3838d9024e2bdf573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160eddb43931fec3838d9024e2bdf573">&#9670;&#160;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class EntityType , class MeshType , class MemorySpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1Grid_1_1ReferenceConjugateGradient.html">Cabana::Grid::ReferenceConjugateGradient</a>&lt; Scalar, EntityType, MeshType, MemorySpace &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a45709e608e68e61c856c16f3b8b9995a">Array_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a45709e608e68e61c856c16f3b8b9995a">Array_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve the problem Ax = b for x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The forcing term. </td></tr>
    <tr><td class="paramname">x</td><td>The solution. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classCabana_1_1Grid_1_1ReferenceStructuredSolver.html#aa6777daacf67b51134dd18c8ac2bb70a">Cabana::Grid::ReferenceStructuredSolver&lt; Scalar, EntityType, MeshType, MemorySpace &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>grid/src/<a class="el" href="Cabana__Grid__ReferenceStructuredSolver_8hpp_source.html">Cabana_Grid_ReferenceStructuredSolver.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
