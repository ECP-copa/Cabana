<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cabana: Cabana::Distributor&lt; MemorySpace &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cabana<span id="projectnumber">&#160;0.7.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceCabana.html">Cabana</a></li><li class="navelem"><a class="el" href="classCabana_1_1Distributor.html">Distributor</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCabana_1_1Distributor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Cabana::Distributor&lt; MemorySpace &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A communication plan for migrating data from one uniquely-owned decomposition to another uniquely owned decomposition.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Cabana__Distributor_8hpp_source.html">Cabana_Distributor.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Cabana::Distributor&lt; MemorySpace &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classCabana_1_1Distributor__inherit__graph.png" border="0" usemap="#aCabana_1_1Distributor_3_01MemorySpace_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aCabana_1_1Distributor_3_01MemorySpace_01_4_inherit__map" id="aCabana_1_1Distributor_3_01MemorySpace_01_4_inherit__map">
<area shape="rect" title="A communication plan for migrating data from one uniquely&#45;owned decomposition to another uniquely own..." alt="" coords="32,102,175,151"/>
<area shape="rect" href="classCabana_1_1CommunicationPlan.html" title="Communication plan base class." alt="" coords="5,5,202,54"/>
<area shape="poly" title=" " alt="" coords="106,69,106,101,101,101,101,69"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Cabana::Distributor&lt; MemorySpace &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classCabana_1_1Distributor__coll__graph.png" border="0" usemap="#aCabana_1_1Distributor_3_01MemorySpace_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aCabana_1_1Distributor_3_01MemorySpace_01_4_coll__map" id="aCabana_1_1Distributor_3_01MemorySpace_01_4_coll__map">
<area shape="rect" title="A communication plan for migrating data from one uniquely&#45;owned decomposition to another uniquely own..." alt="" coords="32,102,175,151"/>
<area shape="rect" href="classCabana_1_1CommunicationPlan.html" title="Communication plan base class." alt="" coords="5,5,202,54"/>
<area shape="poly" title=" " alt="" coords="106,69,106,101,101,101,101,69"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af85de3dfebb2263f1f1abef9b60e96d2" id="r_af85de3dfebb2263f1f1abef9b60e96d2"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:af85de3dfebb2263f1f1abef9b60e96d2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af85de3dfebb2263f1f1abef9b60e96d2">Distributor</a> (MPI_Comm <a class="el" href="classCabana_1_1CommunicationPlan.html#a614a7eb904961fd1c301accd4f8b9848">comm</a>, const ViewType &amp;element_export_ranks, const std::vector&lt; int &gt; &amp;neighbor_ranks)</td></tr>
<tr class="memdesc:af85de3dfebb2263f1f1abef9b60e96d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topology and export rank constructor. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors.  <br /></td></tr>
<tr class="separator:af85de3dfebb2263f1f1abef9b60e96d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94de45f8c866b6de3de465b17754f1c" id="r_ad94de45f8c866b6de3de465b17754f1c"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:ad94de45f8c866b6de3de465b17754f1c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad94de45f8c866b6de3de465b17754f1c">Distributor</a> (MPI_Comm <a class="el" href="classCabana_1_1CommunicationPlan.html#a614a7eb904961fd1c301accd4f8b9848">comm</a>, const ViewType &amp;element_export_ranks)</td></tr>
<tr class="memdesc:ad94de45f8c866b6de3de465b17754f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export rank constructor. Use this when you don't know who you will be receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first.  <br /></td></tr>
<tr class="separator:ad94de45f8c866b6de3de465b17754f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classCabana_1_1CommunicationPlan"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classCabana_1_1CommunicationPlan')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan&lt; MemorySpace &gt;</a></td></tr>
<tr class="memitem:ad37cb95149bc904f4da45e193dc59cd3 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_ad37cb95149bc904f4da45e193dc59cd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#ad37cb95149bc904f4da45e193dc59cd3">CommunicationPlan</a> (MPI_Comm <a class="el" href="classCabana_1_1CommunicationPlan.html#a614a7eb904961fd1c301accd4f8b9848">comm</a>)</td></tr>
<tr class="memdesc:ad37cb95149bc904f4da45e193dc59cd3 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:ad37cb95149bc904f4da45e193dc59cd3 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614a7eb904961fd1c301accd4f8b9848 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a614a7eb904961fd1c301accd4f8b9848"><td class="memItemLeft" align="right" valign="top">
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><b>comm</b> () const</td></tr>
<tr class="memdesc:a614a7eb904961fd1c301accd4f8b9848 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MPI communicator. <br /></td></tr>
<tr class="separator:a614a7eb904961fd1c301accd4f8b9848 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45792fbc446d3289cb3028a730bcd959 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a45792fbc446d3289cb3028a730bcd959"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a45792fbc446d3289cb3028a730bcd959">numNeighbor</a> () const</td></tr>
<tr class="memdesc:a45792fbc446d3289cb3028a730bcd959 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of neighbor ranks that this rank will communicate with.  <br /></td></tr>
<tr class="separator:a45792fbc446d3289cb3028a730bcd959 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d67b24c7e983fc6adafd04f5887dfb inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a97d67b24c7e983fc6adafd04f5887dfb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a97d67b24c7e983fc6adafd04f5887dfb">neighborRank</a> (const int neighbor) const</td></tr>
<tr class="memdesc:a97d67b24c7e983fc6adafd04f5887dfb inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a local neighbor id get its rank in the MPI communicator.  <br /></td></tr>
<tr class="separator:a97d67b24c7e983fc6adafd04f5887dfb inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e22d0dd1f9fd7ac52de395f2a74d9bd inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a8e22d0dd1f9fd7ac52de395f2a74d9bd"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a8e22d0dd1f9fd7ac52de395f2a74d9bd">numExport</a> (const int neighbor) const</td></tr>
<tr class="memdesc:a8e22d0dd1f9fd7ac52de395f2a74d9bd inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements this rank will export to a given neighbor.  <br /></td></tr>
<tr class="separator:a8e22d0dd1f9fd7ac52de395f2a74d9bd inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c004e3614b1d62fd95f55bdcf3ce5d inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a57c004e3614b1d62fd95f55bdcf3ce5d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a57c004e3614b1d62fd95f55bdcf3ce5d">totalNumExport</a> () const</td></tr>
<tr class="memdesc:a57c004e3614b1d62fd95f55bdcf3ce5d inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of exports this rank will do.  <br /></td></tr>
<tr class="separator:a57c004e3614b1d62fd95f55bdcf3ce5d inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905dbd5d80fc34f0299ecf24e30274c5 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a905dbd5d80fc34f0299ecf24e30274c5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a905dbd5d80fc34f0299ecf24e30274c5">numImport</a> (const int neighbor) const</td></tr>
<tr class="memdesc:a905dbd5d80fc34f0299ecf24e30274c5 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements this rank will import from a given neighbor.  <br /></td></tr>
<tr class="separator:a905dbd5d80fc34f0299ecf24e30274c5 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b8a67e50990c64f8e8923982d7f306 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a93b8a67e50990c64f8e8923982d7f306"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a93b8a67e50990c64f8e8923982d7f306">totalNumImport</a> () const</td></tr>
<tr class="memdesc:a93b8a67e50990c64f8e8923982d7f306 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of imports this rank will do.  <br /></td></tr>
<tr class="separator:a93b8a67e50990c64f8e8923982d7f306 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe2c790ef56d1d027ae6d29b63b1198 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a1fe2c790ef56d1d027ae6d29b63b1198"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a1fe2c790ef56d1d027ae6d29b63b1198">exportSize</a> () const</td></tr>
<tr class="memdesc:a1fe2c790ef56d1d027ae6d29b63b1198 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of export elements.  <br /></td></tr>
<tr class="separator:a1fe2c790ef56d1d027ae6d29b63b1198 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0864132bc0c1a26c7fb33d8e9ed059c0 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a0864132bc0c1a26c7fb33d8e9ed059c0"><td class="memItemLeft" align="right" valign="top">Kokkos::View&lt; std::size_t *, <a class="el" href="classCabana_1_1CommunicationPlan.html#a31b59b320cff95e400db68ca831be873">memory_space</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a0864132bc0c1a26c7fb33d8e9ed059c0">getExportSteering</a> () const</td></tr>
<tr class="memdesc:a0864132bc0c1a26c7fb33d8e9ed059c0 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the steering vector for the exports.  <br /></td></tr>
<tr class="separator:a0864132bc0c1a26c7fb33d8e9ed059c0 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2dbf0339be679f5737c9e061a886f9 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a9e2dbf0339be679f5737c9e061a886f9"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class ViewType &gt; </td></tr>
<tr class="memitem:a9e2dbf0339be679f5737c9e061a886f9 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlan.html#a2888c5686762460a20d0cc78aea4e9d4">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlan.html#a31b59b320cff95e400db68ca831be873">memory_space</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a9e2dbf0339be679f5737c9e061a886f9">createFromExportsAndTopology</a> (ExecutionSpace exec_space, const ViewType &amp;element_export_ranks, const std::vector&lt; int &gt; &amp;neighbor_ranks)</td></tr>
<tr class="memdesc:a9e2dbf0339be679f5737c9e061a886f9 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor and export rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors.  <br /></td></tr>
<tr class="separator:a9e2dbf0339be679f5737c9e061a886f9 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4153e3a036fd1fcfb7a835348730f88d inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a4153e3a036fd1fcfb7a835348730f88d"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a4153e3a036fd1fcfb7a835348730f88d inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlan.html#a2888c5686762460a20d0cc78aea4e9d4">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlan.html#a31b59b320cff95e400db68ca831be873">memory_space</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a4153e3a036fd1fcfb7a835348730f88d">createFromExportsAndTopology</a> (const ViewType &amp;element_export_ranks, const std::vector&lt; int &gt; &amp;neighbor_ranks)</td></tr>
<tr class="memdesc:a4153e3a036fd1fcfb7a835348730f88d inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor and export rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors.  <br /></td></tr>
<tr class="separator:a4153e3a036fd1fcfb7a835348730f88d inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001fabc406e4c8a5265579dd0e35e92a inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a001fabc406e4c8a5265579dd0e35e92a"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace , class ViewType &gt; </td></tr>
<tr class="memitem:a001fabc406e4c8a5265579dd0e35e92a inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlan.html#a2888c5686762460a20d0cc78aea4e9d4">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlan.html#a31b59b320cff95e400db68ca831be873">memory_space</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a001fabc406e4c8a5265579dd0e35e92a">createFromExportsOnly</a> (ExecutionSpace exec_space, const ViewType &amp;element_export_ranks)</td></tr>
<tr class="memdesc:a001fabc406e4c8a5265579dd0e35e92a inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export rank creator. Use this when you don't know who you will receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first.  <br /></td></tr>
<tr class="separator:a001fabc406e4c8a5265579dd0e35e92a inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3d9609c181f2056820d98e0d0a2639 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a3a3d9609c181f2056820d98e0d0a2639"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a3a3d9609c181f2056820d98e0d0a2639 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlan.html#a2888c5686762460a20d0cc78aea4e9d4">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlan.html#a31b59b320cff95e400db68ca831be873">memory_space</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a3a3d9609c181f2056820d98e0d0a2639">createFromExportsOnly</a> (const ViewType &amp;element_export_ranks)</td></tr>
<tr class="memdesc:a3a3d9609c181f2056820d98e0d0a2639 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export rank creator. Use this when you don't know who you will receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first.  <br /></td></tr>
<tr class="separator:a3a3d9609c181f2056820d98e0d0a2639 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d09203fe92d9a63f2852bdfd317c72a inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a4d09203fe92d9a63f2852bdfd317c72a"><td class="memTemplParams" colspan="2">template&lt;class PackViewType , class RankViewType &gt; </td></tr>
<tr class="memitem:a4d09203fe92d9a63f2852bdfd317c72a inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a4d09203fe92d9a63f2852bdfd317c72a">createExportSteering</a> (const PackViewType &amp;neighbor_ids, const RankViewType &amp;element_export_ranks)</td></tr>
<tr class="memdesc:a4d09203fe92d9a63f2852bdfd317c72a inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the export steering vector.  <br /></td></tr>
<tr class="separator:a4d09203fe92d9a63f2852bdfd317c72a inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9b8b82a49acbca33d63164320d44f5 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a9e9b8b82a49acbca33d63164320d44f5"><td class="memTemplParams" colspan="2">template&lt;class PackViewType , class RankViewType , class IdViewType &gt; </td></tr>
<tr class="memitem:a9e9b8b82a49acbca33d63164320d44f5 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a9e9b8b82a49acbca33d63164320d44f5">createExportSteering</a> (const PackViewType &amp;neighbor_ids, const RankViewType &amp;element_export_ranks, const IdViewType &amp;element_export_ids)</td></tr>
<tr class="memdesc:a9e9b8b82a49acbca33d63164320d44f5 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the export steering vector.  <br /></td></tr>
<tr class="separator:a9e9b8b82a49acbca33d63164320d44f5 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classCabana_1_1CommunicationPlan"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classCabana_1_1CommunicationPlan')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan&lt; MemorySpace &gt;</a></td></tr>
<tr class="memitem:a31b59b320cff95e400db68ca831be873 inherit pub_types_classCabana_1_1CommunicationPlan" id="r_a31b59b320cff95e400db68ca831be873"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>memory_space</b> = typename MemorySpace::memory_space</td></tr>
<tr class="memdesc:a31b59b320cff95e400db68ca831be873 inherit pub_types_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory space. <br /></td></tr>
<tr class="separator:a31b59b320cff95e400db68ca831be873 inherit pub_types_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae846372aa7018c5da4d017502a0803e2 inherit pub_types_classCabana_1_1CommunicationPlan" id="r_ae846372aa7018c5da4d017502a0803e2"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>execution_space</b> = typename memory_space::execution_space</td></tr>
<tr class="memdesc:ae846372aa7018c5da4d017502a0803e2 inherit pub_types_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default execution space. <br /></td></tr>
<tr class="separator:ae846372aa7018c5da4d017502a0803e2 inherit pub_types_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2888c5686762460a20d0cc78aea4e9d4 inherit pub_types_classCabana_1_1CommunicationPlan" id="r_a2888c5686762460a20d0cc78aea4e9d4"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename memory_space::memory_space::size_type</td></tr>
<tr class="memdesc:a2888c5686762460a20d0cc78aea4e9d4 inherit pub_types_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type. <br /></td></tr>
<tr class="separator:a2888c5686762460a20d0cc78aea4e9d4 inherit pub_types_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class MemorySpace&gt;<br />
class Cabana::Distributor&lt; MemorySpace &gt;</div><p>A communication plan for migrating data from one uniquely-owned decomposition to another uniquely owned decomposition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MemorySpace</td><td>Kokkos memory space in which data for this class will be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="classCabana_1_1Distributor.html" title="A communication plan for migrating data from one uniquely-owned decomposition to another uniquely own...">Distributor</a> allows data to be migrated to an entirely new decomposition. Only uniquely-owned decompositions are handled (i.e. each local element in the source rank has a single unique destination rank).</p>
<p>Some nomenclature:</p>
<p>Export - the data we uniquely own that we will be sending to other ranks.</p>
<p>Import - the data we uniquely own that we will be receiving from other ranks.</p>
<dl class="section note"><dt>Note</dt><dd>We can migrate data to the same rank. In this case a copy will occur instead of communication.</dd>
<dd>
To get the number of elements this rank will be receiving from migration in the forward communication plan, call <a class="el" href="classCabana_1_1CommunicationPlan.html#a93b8a67e50990c64f8e8923982d7f306" title="Get the total number of imports this rank will do.">totalNumImport()</a> on the distributor. This will be needed when in-place migration is not used and a user must allocate their own destination data structure. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af85de3dfebb2263f1f1abef9b60e96d2" name="af85de3dfebb2263f1f1abef9b60e96d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85de3dfebb2263f1f1abef9b60e96d2">&#9670;&#160;</a></span>Distributor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace &gt; </div>
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Distributor.html">Cabana::Distributor</a>&lt; MemorySpace &gt;::Distributor </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_export_ranks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>neighbor_ranks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Topology and export rank constructor. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ViewType</td><td>The container type for the export element ranks. This container type can be either a Kokkos View or a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The MPI communicator over which the distributor is defined.</td></tr>
    <tr><td class="paramname">element_export_ranks</td><td>The destination rank in the target decomposition of each locally owned element in the source decomposition. Each element will have one unique destination to which it will be exported. This export rank may be any one of the listed neighbor ranks which can include the calling rank. An export rank of -1 will signal that this element is <em>not</em> to be exported and will be ignored in the data migration. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the distributor.</td></tr>
    <tr><td class="paramname">neighbor_ranks</td><td>List of ranks this rank will send to and receive from. This list can include the calling rank. This is effectively a description of the topology of the point-to-point communication plan. The elements in this list must be unique.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For elements that you do not wish to export, use an export rank of -1 to signal that this element is <em>not</em> to be exported and will be ignored in the data migration. In other words, this element will be completely* removed in the new decomposition. If the data is staying on this rank, just use this rank as the export destination and the data will be efficiently migrated. </dd></dl>

</div>
</div>
<a id="ad94de45f8c866b6de3de465b17754f1c" name="ad94de45f8c866b6de3de465b17754f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94de45f8c866b6de3de465b17754f1c">&#9670;&#160;</a></span>Distributor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace &gt; </div>
<div class="memtemplate">
template&lt;class ViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Distributor.html">Cabana::Distributor</a>&lt; MemorySpace &gt;::Distributor </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_export_ranks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export rank constructor. Use this when you don't know who you will be receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ViewType</td><td>The container type for the export element ranks. This container type can be either a Kokkos View or a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The MPI communicator over which the distributor is defined.</td></tr>
    <tr><td class="paramname">element_export_ranks</td><td>The destination rank in the target decomposition of each locally owned element in the source decomposition. Each element will have one unique destination to which it will be exported. This export rank may any one of the listed neighbor ranks which can include the calling rank. An export rank of -1 will signal that this element is <em>not</em> to be exported and will be ignored in the data migration. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the distributor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For elements that you do not wish to export, use an export rank of -1 to signal that this element is <em>not</em> to be exported and will be ignored in the data migration. In other words, this element will be completely* removed in the new decomposition. If the data is staying on this rank, just use this rank as the export destination and the data will be efficiently migrated. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/src/<a class="el" href="Cabana__Distributor_8hpp_source.html">Cabana_Distributor.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
