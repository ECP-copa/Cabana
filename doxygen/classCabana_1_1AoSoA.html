<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Cabana: Cabana::AoSoA&lt; DataTypes, MemorySpace, VectorLength, type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cabana
   &#160;<span id="projectnumber">0.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Cabana</b></li><li class="navelem"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classCabana_1_1AoSoA-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Cabana::AoSoA&lt; DataTypes, MemorySpace, VectorLength, type &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Array-of-Struct-of-Arrays.  
 <a href="classCabana_1_1AoSoA.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Cabana__AoSoA_8hpp_source.html">Cabana_AoSoA.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abcef6bab3498b3036feb4a77a554f26b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcef6bab3498b3036feb4a77a554f26b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>aosoa_type</b> = <a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; DataTypes, <a class="el" href="structCabana_1_1HostSpace.html">MemorySpace</a>, VectorLength &gt;</td></tr>
<tr class="separator:abcef6bab3498b3036feb4a77a554f26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538eba813f920a415947727ae8496215"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a538eba813f920a415947727ae8496215"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>member_types</b> = DataTypes</td></tr>
<tr class="separator:a538eba813f920a415947727ae8496215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cfd11564fbf9ae3a01135d917b8f4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25cfd11564fbf9ae3a01135d917b8f4a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>memory_space</b> = <a class="el" href="structCabana_1_1HostSpace.html">MemorySpace</a></td></tr>
<tr class="separator:a25cfd11564fbf9ae3a01135d917b8f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a44a5e7518701409150e179164c009"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8a44a5e7518701409150e179164c009"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>soa_type</b> = <a class="el" href="structCabana_1_1SoA.html">SoA</a>&lt; vector_length, member_types &gt;</td></tr>
<tr class="separator:ae8a44a5e7518701409150e179164c009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312b36a424c8f55e5023652be488bf64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a312b36a424c8f55e5023652be488bf64"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>soa_view</b> = Kokkos::View&lt; <a class="el" href="structCabana_1_1SoA.html">soa_type</a> *, typename memory_space::kokkos_memory_space &gt;</td></tr>
<tr class="separator:a312b36a424c8f55e5023652be488bf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705eade73187bfe164e15f59b20206d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a705eade73187bfe164e15f59b20206d7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>index_type</b> = <a class="el" href="classCabana_1_1Impl_1_1Index.html">Impl::Index</a>&lt; vector_length &gt;</td></tr>
<tr class="separator:a705eade73187bfe164e15f59b20206d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273bcbaed1bb713164cf185738d5017e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a273bcbaed1bb713164cf185738d5017e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>tuple_type</b> = <a class="el" href="structCabana_1_1Tuple.html">Tuple</a>&lt; member_types &gt;</td></tr>
<tr class="separator:a273bcbaed1bb713164cf185738d5017e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad611ef827ff18082eb7a465249eeb8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ad611ef827ff18082eb7a465249eeb8"></a>
template&lt;std::size_t M&gt; </td></tr>
<tr class="memitem:a2ad611ef827ff18082eb7a465249eeb8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>member_data_type</b> = typename <a class="el" href="structCabana_1_1MemberTypeAtIndex.html">MemberTypeAtIndex</a>&lt; M, member_types &gt;::type</td></tr>
<tr class="separator:a2ad611ef827ff18082eb7a465249eeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c91f12d31e66aaf9340c5b8b9fcd47b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1c91f12d31e66aaf9340c5b8b9fcd47b"></a>
template&lt;std::size_t M&gt; </td></tr>
<tr class="memitem:a1c91f12d31e66aaf9340c5b8b9fcd47b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>member_value_type</b> = typename std::remove_all_extents&lt; member_data_type&lt; M &gt; &gt;::type</td></tr>
<tr class="separator:a1c91f12d31e66aaf9340c5b8b9fcd47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19bbf8d908e289a35af47494f004553"><td class="memTemplParams" colspan="2"><a class="anchor" id="af19bbf8d908e289a35af47494f004553"></a>
template&lt;std::size_t M&gt; </td></tr>
<tr class="memitem:af19bbf8d908e289a35af47494f004553"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>member_pointer_type</b> = typename std::add_pointer&lt; member_value_type&lt; M &gt; &gt;::type</td></tr>
<tr class="separator:af19bbf8d908e289a35af47494f004553"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaf8315a02aafaa6b7af0b7fe8b5a3080"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#aaf8315a02aafaa6b7af0b7fe8b5a3080">AoSoA</a> ()</td></tr>
<tr class="memdesc:aaf8315a02aafaa6b7af0b7fe8b5a3080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#aaf8315a02aafaa6b7af0b7fe8b5a3080">More...</a><br/></td></tr>
<tr class="separator:aaf8315a02aafaa6b7af0b7fe8b5a3080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8403af8e3f14ad140c1a27689a8f98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#afe8403af8e3f14ad140c1a27689a8f98">AoSoA</a> (const int n)</td></tr>
<tr class="memdesc:afe8403af8e3f14ad140c1a27689a8f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a container with n tuples.  <a href="#afe8403af8e3f14ad140c1a27689a8f98">More...</a><br/></td></tr>
<tr class="separator:afe8403af8e3f14ad140c1a27689a8f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59035815fbcbcd40ab512429f2e92945"><td class="memItemLeft" align="right" valign="top">CABANA_FUNCTION std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a59035815fbcbcd40ab512429f2e92945">size</a> () const </td></tr>
<tr class="memdesc:a59035815fbcbcd40ab512429f2e92945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of tuples in the container.  <a href="#a59035815fbcbcd40ab512429f2e92945">More...</a><br/></td></tr>
<tr class="separator:a59035815fbcbcd40ab512429f2e92945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af482e2ec3ad6d123d6e6399ca6ee1938"><td class="memItemLeft" align="right" valign="top">CABANA_FUNCTION std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#af482e2ec3ad6d123d6e6399ca6ee1938">capacity</a> () const </td></tr>
<tr class="memdesc:af482e2ec3ad6d123d6e6399ca6ee1938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the storage space currently allocated for the container, expressed in terms of tuples.  <a href="#af482e2ec3ad6d123d6e6399ca6ee1938">More...</a><br/></td></tr>
<tr class="separator:af482e2ec3ad6d123d6e6399ca6ee1938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ca9c95fa26269e84c44ecf0a52794a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a90ca9c95fa26269e84c44ecf0a52794a">resize</a> (const std::size_t n)</td></tr>
<tr class="memdesc:a90ca9c95fa26269e84c44ecf0a52794a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container so that it contains n tuples.  <a href="#a90ca9c95fa26269e84c44ecf0a52794a">More...</a><br/></td></tr>
<tr class="separator:a90ca9c95fa26269e84c44ecf0a52794a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82123aff64317235fcd54cba710573fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a82123aff64317235fcd54cba710573fc">reserve</a> (const std::size_t n)</td></tr>
<tr class="memdesc:a82123aff64317235fcd54cba710573fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the container capacity be at least enough to contain n tuples.  <a href="#a82123aff64317235fcd54cba710573fc">More...</a><br/></td></tr>
<tr class="separator:a82123aff64317235fcd54cba710573fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff806dc06cdf1ab8435431458324a32a"><td class="memItemLeft" align="right" valign="top">CABANA_INLINE_FUNCTION std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#aff806dc06cdf1ab8435431458324a32a">numSoA</a> () const </td></tr>
<tr class="memdesc:aff806dc06cdf1ab8435431458324a32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of structs-of-arrays in the container.  <a href="#aff806dc06cdf1ab8435431458324a32a">More...</a><br/></td></tr>
<tr class="separator:aff806dc06cdf1ab8435431458324a32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a0d6364559a74189ecc9d5b84cd7b9"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a07a0d6364559a74189ecc9d5b84cd7b9"><td class="memTemplItemLeft" align="right" valign="top">CABANA_INLINE_FUNCTION <br class="typebreak"/>
std::enable_if<br class="typebreak"/>
&lt; std::is_integral&lt; S &gt;::value, <br class="typebreak"/>
int &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a07a0d6364559a74189ecc9d5b84cd7b9">arraySize</a> (const S &amp;s) const </td></tr>
<tr class="memdesc:a07a0d6364559a74189ecc9d5b84cd7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the data array at a given struct member index.  <a href="#a07a0d6364559a74189ecc9d5b84cd7b9">More...</a><br/></td></tr>
<tr class="separator:a07a0d6364559a74189ecc9d5b84cd7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac6ba3cb8e651f72c11ae3188c4bdec"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a3ac6ba3cb8e651f72c11ae3188c4bdec"><td class="memTemplItemLeft" align="right" valign="top">CABANA_FORCEINLINE_FUNCTION <br class="typebreak"/>
std::enable_if<br class="typebreak"/>
&lt; std::is_integral&lt; S &gt;::value, <br class="typebreak"/>
<a class="el" href="structCabana_1_1SoA.html">soa_type</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a3ac6ba3cb8e651f72c11ae3188c4bdec">access</a> (const S &amp;s) const </td></tr>
<tr class="memdesc:a3ac6ba3cb8e651f72c11ae3188c4bdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the <a class="el" href="structCabana_1_1SoA.html" title="Struct-of-Arrays. ">SoA</a> at a given index.  <a href="#a3ac6ba3cb8e651f72c11ae3188c4bdec">More...</a><br/></td></tr>
<tr class="separator:a3ac6ba3cb8e651f72c11ae3188c4bdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2a8fc5068bc630c1f57110ff252dea"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:adf2a8fc5068bc630c1f57110ff252dea"><td class="memTemplItemLeft" align="right" valign="top">CABANA_INLINE_FUNCTION <br class="typebreak"/>
std::enable_if<br class="typebreak"/>
&lt; std::is_integral&lt; I &gt;::value, <br class="typebreak"/>
<a class="el" href="structCabana_1_1Tuple.html">tuple_type</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#adf2a8fc5068bc630c1f57110ff252dea">getTuple</a> (const I &amp;i) const </td></tr>
<tr class="memdesc:adf2a8fc5068bc630c1f57110ff252dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a tuple at a given index via a deep copy.  <a href="#adf2a8fc5068bc630c1f57110ff252dea">More...</a><br/></td></tr>
<tr class="separator:adf2a8fc5068bc630c1f57110ff252dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884e3c1a2b5d199491ca7fa23097b6a5"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a884e3c1a2b5d199491ca7fa23097b6a5"><td class="memTemplItemLeft" align="right" valign="top">CABANA_INLINE_FUNCTION <br class="typebreak"/>
std::enable_if<br class="typebreak"/>
&lt; std::is_integral&lt; I &gt;::value, <br class="typebreak"/>
void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a884e3c1a2b5d199491ca7fa23097b6a5">setTuple</a> (const I &amp;i, const <a class="el" href="structCabana_1_1Tuple.html">tuple_type</a> &amp;tpl) const </td></tr>
<tr class="memdesc:a884e3c1a2b5d199491ca7fa23097b6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a tuple at a given index via a deep copy.  <a href="#a884e3c1a2b5d199491ca7fa23097b6a5">More...</a><br/></td></tr>
<tr class="separator:a884e3c1a2b5d199491ca7fa23097b6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8727d54a8bfe86a3b21c9a4d4cb45f5f"><td class="memTemplParams" colspan="2">template&lt;std::size_t M&gt; </td></tr>
<tr class="memitem:a8727d54a8bfe86a3b21c9a4d4cb45f5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCabana_1_1Slice.html">Slice</a>&lt; member_data_type&lt; M &gt;<br class="typebreak"/>
, <a class="el" href="structCabana_1_1HostSpace.html">memory_space</a>, <br class="typebreak"/>
<a class="el" href="structCabana_1_1DefaultAccessMemory.html">DefaultAccessMemory</a>, <br class="typebreak"/>
vector_length &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a8727d54a8bfe86a3b21c9a4d4cb45f5f">slice</a> () const </td></tr>
<tr class="memdesc:a8727d54a8bfe86a3b21c9a4d4cb45f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an unmanaged slice of a tuple member with default memory access.  <a href="#a8727d54a8bfe86a3b21c9a4d4cb45f5f">More...</a><br/></td></tr>
<tr class="separator:a8727d54a8bfe86a3b21c9a4d4cb45f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4daa69248c660aefec75e2ad494d62"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#aaf4daa69248c660aefec75e2ad494d62">ptr</a> () const </td></tr>
<tr class="memdesc:aaf4daa69248c660aefec75e2ad494d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an un-typed raw pointer to the entire data block.  <a href="#aaf4daa69248c660aefec75e2ad494d62">More...</a><br/></td></tr>
<tr class="separator:aaf4daa69248c660aefec75e2ad494d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a87485b232d388d7864456ea4f3996b3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87485b232d388d7864456ea4f3996b3c"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>vector_length</b> = VectorLength</td></tr>
<tr class="separator:a87485b232d388d7864456ea4f3996b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af525b6b8a5b9d2670115a15d26e060a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af525b6b8a5b9d2670115a15d26e060a1"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>number_of_members</b> = member_types::size</td></tr>
<tr class="separator:af525b6b8a5b9d2670115a15d26e060a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd3331e1c31060a80f5625fab32bc7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4dd3331e1c31060a80f5625fab32bc7b"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_rank</b> = 3</td></tr>
<tr class="separator:a4dd3331e1c31060a80f5625fab32bc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class DataTypes, class MemorySpace, int VectorLength = Impl::PerformanceTraits&lt;             typename MemorySpace::kokkos_execution_space&gt;::vector_length, typename std::enable_if&lt; (is_member_types&lt; DataTypes &gt;::value &amp;&amp;is_memory_space&lt; MemorySpace &gt;::value &amp;&amp;Impl::IsVectorLengthValid&lt; VectorLength &gt;::value), int &gt;::type = 0&gt;<br/>
class Cabana::AoSoA&lt; DataTypes, MemorySpace, VectorLength, type &gt;</h3>

<p>Array-of-Struct-of-Arrays. </p>
<p>A <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays. ">AoSoA</a> represents tuples and their data via an array-of-structs-of-arrays.</p>
<p>This class has both required and optional template parameters. The <code>DataType</code> parameter must always be provided, and must always be first. The parameters <code>Arg1Type</code>, <code>Arg2Type</code>, and <code>Arg3Type</code> are placeholders for different template parameters. The default value of the fifth template parameter <code>Specialize</code> suffices for most use cases. When explaining the template parameters, we won't refer to <code>Arg1Type</code>, <code>Arg2Type</code>, and <code>Arg3Type</code>; instead, we will refer to the valid categories of template parameters, in whatever order they may occur.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>(required) Specifically this must be an instance of <code><a class="el" href="structCabana_1_1MemberTypes.html" title="General sequence of types for SoA and AoSoA member data. ">MemberTypes</a></code> with the data layout of the structs. For example: <div class="fragment"><div class="line"><span class="keyword">using</span> DataType = MemberTypes&lt;double[3][3],double[3],int&gt;;</div>
</div><!-- fragment --> would define an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays. ">AoSoA</a> where each tuple had a 3x3 matrix of doubles, a 3-vector of doubles, and an integer. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays. ">AoSoA</a> is then templated on this sequence of types. In general, put larger datatypes first in the MemberType parameter pack (i.e. matrices and vectors) and group members of the same type together to achieve the smallest possible memory footprint based on compiler-generated padding.</td></tr>
    <tr><td class="paramname">MemorySpace</td><td>(required) The memory space.</td></tr>
    <tr><td class="paramname">VectorLength</td><td>(optional) The vector length within the structs of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays. ">AoSoA</a>. If not specified, this defaults to the preferred layout for the <code>MemorySpace</code>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aaf8315a02aafaa6b7af0b7fe8b5a3080"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes , class MemorySpace , int VectorLength = Impl::PerformanceTraits&lt;             typename MemorySpace::kokkos_execution_space&gt;::vector_length, typename std::enable_if&lt; (is_member_types&lt; DataTypes &gt;::value &amp;&amp;is_memory_space&lt; MemorySpace &gt;::value &amp;&amp;Impl::IsVectorLengthValid&lt; VectorLength &gt;::value), int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; DataTypes, <a class="el" href="structCabana_1_1HostSpace.html">MemorySpace</a>, VectorLength, type &gt;::<a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>The container size is zero and no memory is allocated. </p>

</div>
</div>
<a class="anchor" id="afe8403af8e3f14ad140c1a27689a8f98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes , class MemorySpace , int VectorLength = Impl::PerformanceTraits&lt;             typename MemorySpace::kokkos_execution_space&gt;::vector_length, typename std::enable_if&lt; (is_member_types&lt; DataTypes &gt;::value &amp;&amp;is_memory_space&lt; MemorySpace &gt;::value &amp;&amp;Impl::IsVectorLengthValid&lt; VectorLength &gt;::value), int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; DataTypes, <a class="el" href="structCabana_1_1HostSpace.html">MemorySpace</a>, VectorLength, type &gt;::<a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a container with n tuples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of tuples in the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3ac6ba3cb8e651f72c11ae3188c4bdec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes , class MemorySpace , int VectorLength = Impl::PerformanceTraits&lt;             typename MemorySpace::kokkos_execution_space&gt;::vector_length, typename std::enable_if&lt; (is_member_types&lt; DataTypes &gt;::value &amp;&amp;is_memory_space&lt; MemorySpace &gt;::value &amp;&amp;Impl::IsVectorLengthValid&lt; VectorLength &gt;::value), int &gt;::type  = 0&gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CABANA_FORCEINLINE_FUNCTION std::enable_if&lt;std::is_integral&lt;S&gt;::value,<a class="el" href="structCabana_1_1SoA.html">soa_type</a>&amp;&gt;::type <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; DataTypes, <a class="el" href="structCabana_1_1HostSpace.html">MemorySpace</a>, VectorLength, type &gt;::access </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the <a class="el" href="structCabana_1_1SoA.html" title="Struct-of-Arrays. ">SoA</a> at a given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structCabana_1_1SoA.html" title="Struct-of-Arrays. ">SoA</a> index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structCabana_1_1SoA.html" title="Struct-of-Arrays. ">SoA</a> reference at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="a07a0d6364559a74189ecc9d5b84cd7b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes , class MemorySpace , int VectorLength = Impl::PerformanceTraits&lt;             typename MemorySpace::kokkos_execution_space&gt;::vector_length, typename std::enable_if&lt; (is_member_types&lt; DataTypes &gt;::value &amp;&amp;is_memory_space&lt; MemorySpace &gt;::value &amp;&amp;Impl::IsVectorLengthValid&lt; VectorLength &gt;::value), int &gt;::type  = 0&gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CABANA_INLINE_FUNCTION std::enable_if&lt;std::is_integral&lt;S&gt;::value,int&gt;::type <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; DataTypes, <a class="el" href="structCabana_1_1HostSpace.html">MemorySpace</a>, VectorLength, type &gt;::arraySize </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the data array at a given struct member index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The struct index to get the array size for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the array at the given struct index. </dd></dl>

</div>
</div>
<a class="anchor" id="af482e2ec3ad6d123d6e6399ca6ee1938"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes , class MemorySpace , int VectorLength = Impl::PerformanceTraits&lt;             typename MemorySpace::kokkos_execution_space&gt;::vector_length, typename std::enable_if&lt; (is_member_types&lt; DataTypes &gt;::value &amp;&amp;is_memory_space&lt; MemorySpace &gt;::value &amp;&amp;Impl::IsVectorLengthValid&lt; VectorLength &gt;::value), int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CABANA_FUNCTION std::size_t <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; DataTypes, <a class="el" href="structCabana_1_1HostSpace.html">MemorySpace</a>, VectorLength, type &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the storage space currently allocated for the container, expressed in terms of tuples. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the container.</dd></dl>
<p>This capacity is not necessarily equal to the container size. It can be equal or greater, with the extra space allowing to accommodate for growth without the need to reallocate on each insertion.</p>
<p>Notice that this capacity does not suppose a limit on the size of the container. When this capacity is exhausted and more is needed, it is automatically expanded by the container (reallocating it storage space).</p>
<p>The capacity of a container can be explicitly altered by calling member reserve. </p>

</div>
</div>
<a class="anchor" id="adf2a8fc5068bc630c1f57110ff252dea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes , class MemorySpace , int VectorLength = Impl::PerformanceTraits&lt;             typename MemorySpace::kokkos_execution_space&gt;::vector_length, typename std::enable_if&lt; (is_member_types&lt; DataTypes &gt;::value &amp;&amp;is_memory_space&lt; MemorySpace &gt;::value &amp;&amp;Impl::IsVectorLengthValid&lt; VectorLength &gt;::value), int &gt;::type  = 0&gt; </div>
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CABANA_INLINE_FUNCTION std::enable_if&lt;std::is_integral&lt;I&gt;::value,<a class="el" href="structCabana_1_1Tuple.html">tuple_type</a>&gt;::type <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; DataTypes, <a class="el" href="structCabana_1_1HostSpace.html">MemorySpace</a>, VectorLength, type &gt;::getTuple </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a tuple at a given index via a deep copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index to get the tuple from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing a deep copy of the data at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="aff806dc06cdf1ab8435431458324a32a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes , class MemorySpace , int VectorLength = Impl::PerformanceTraits&lt;             typename MemorySpace::kokkos_execution_space&gt;::vector_length, typename std::enable_if&lt; (is_member_types&lt; DataTypes &gt;::value &amp;&amp;is_memory_space&lt; MemorySpace &gt;::value &amp;&amp;Impl::IsVectorLengthValid&lt; VectorLength &gt;::value), int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CABANA_INLINE_FUNCTION std::size_t <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; DataTypes, <a class="el" href="structCabana_1_1HostSpace.html">MemorySpace</a>, VectorLength, type &gt;::numSoA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of structs-of-arrays in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of structs-of-arrays in the container. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf4daa69248c660aefec75e2ad494d62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes , class MemorySpace , int VectorLength = Impl::PerformanceTraits&lt;             typename MemorySpace::kokkos_execution_space&gt;::vector_length, typename std::enable_if&lt; (is_member_types&lt; DataTypes &gt;::value &amp;&amp;is_memory_space&lt; MemorySpace &gt;::value &amp;&amp;Impl::IsVectorLengthValid&lt; VectorLength &gt;::value), int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; DataTypes, <a class="el" href="structCabana_1_1HostSpace.html">MemorySpace</a>, VectorLength, type &gt;::ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an un-typed raw pointer to the entire data block. </p>
<dl class="section return"><dt>Returns</dt><dd>An un-typed raw-pointer to the entire data block. </dd></dl>

</div>
</div>
<a class="anchor" id="a82123aff64317235fcd54cba710573fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes , class MemorySpace , int VectorLength = Impl::PerformanceTraits&lt;             typename MemorySpace::kokkos_execution_space&gt;::vector_length, typename std::enable_if&lt; (is_member_types&lt; DataTypes &gt;::value &amp;&amp;is_memory_space&lt; MemorySpace &gt;::value &amp;&amp;Impl::IsVectorLengthValid&lt; VectorLength &gt;::value), int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; DataTypes, <a class="el" href="structCabana_1_1HostSpace.html">MemorySpace</a>, VectorLength, type &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the container capacity be at least enough to contain n tuples. </p>
<p>If n is greater than the current container capacity, the function causes the container to reallocate its storage increasing its capacity to n (or greater).</p>
<p>In all other cases, the function call does not cause a reallocation and the container capacity is not affected.</p>
<p>This function has no effect on the container size and cannot alter its tuples. </p>

</div>
</div>
<a class="anchor" id="a90ca9c95fa26269e84c44ecf0a52794a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes , class MemorySpace , int VectorLength = Impl::PerformanceTraits&lt;             typename MemorySpace::kokkos_execution_space&gt;::vector_length, typename std::enable_if&lt; (is_member_types&lt; DataTypes &gt;::value &amp;&amp;is_memory_space&lt; MemorySpace &gt;::value &amp;&amp;Impl::IsVectorLengthValid&lt; VectorLength &gt;::value), int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; DataTypes, <a class="el" href="structCabana_1_1HostSpace.html">MemorySpace</a>, VectorLength, type &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container so that it contains n tuples. </p>
<p>If n is smaller than the current container size, the content is reduced to its first n tuples.</p>
<p>If n is greater than the current container size, the content is expanded by inserting at the end as many tuples as needed to reach a size of n.</p>
<p>If n is also greater than the current container capacity, an automatic reallocation of the allocated storage space takes place.</p>
<p>Notice that this function changes the actual content of the container by inserting or erasing tuples from it. </p>

</div>
</div>
<a class="anchor" id="a884e3c1a2b5d199491ca7fa23097b6a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes , class MemorySpace , int VectorLength = Impl::PerformanceTraits&lt;             typename MemorySpace::kokkos_execution_space&gt;::vector_length, typename std::enable_if&lt; (is_member_types&lt; DataTypes &gt;::value &amp;&amp;is_memory_space&lt; MemorySpace &gt;::value &amp;&amp;Impl::IsVectorLengthValid&lt; VectorLength &gt;::value), int &gt;::type  = 0&gt; </div>
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CABANA_INLINE_FUNCTION std::enable_if&lt;std::is_integral&lt;I&gt;::value,void&gt;::type <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; DataTypes, <a class="el" href="structCabana_1_1HostSpace.html">MemorySpace</a>, VectorLength, type &gt;::setTuple </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCabana_1_1Tuple.html">tuple_type</a> &amp;&#160;</td>
          <td class="paramname"><em>tpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a tuple at a given index via a deep copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index to set the tuple at.</td></tr>
    <tr><td class="paramname">tuple</td><td>The tuple to get the data from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59035815fbcbcd40ab512429f2e92945"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes , class MemorySpace , int VectorLength = Impl::PerformanceTraits&lt;             typename MemorySpace::kokkos_execution_space&gt;::vector_length, typename std::enable_if&lt; (is_member_types&lt; DataTypes &gt;::value &amp;&amp;is_memory_space&lt; MemorySpace &gt;::value &amp;&amp;Impl::IsVectorLengthValid&lt; VectorLength &gt;::value), int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CABANA_FUNCTION std::size_t <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; DataTypes, <a class="el" href="structCabana_1_1HostSpace.html">MemorySpace</a>, VectorLength, type &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of tuples in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of tuples in the container.</dd></dl>
<p>This is the number of actual objects held in the container, which is not necessarily equal to its storage capacity. </p>

</div>
</div>
<a class="anchor" id="a8727d54a8bfe86a3b21c9a4d4cb45f5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes , class MemorySpace , int VectorLength = Impl::PerformanceTraits&lt;             typename MemorySpace::kokkos_execution_space&gt;::vector_length, typename std::enable_if&lt; (is_member_types&lt; DataTypes &gt;::value &amp;&amp;is_memory_space&lt; MemorySpace &gt;::value &amp;&amp;Impl::IsVectorLengthValid&lt; VectorLength &gt;::value), int &gt;::type  = 0&gt; </div>
<div class="memtemplate">
template&lt;std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Slice.html">Slice</a>&lt;member_data_type&lt;M&gt;,<a class="el" href="structCabana_1_1HostSpace.html">memory_space</a>,<a class="el" href="structCabana_1_1DefaultAccessMemory.html">DefaultAccessMemory</a>,vector_length&gt; <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; DataTypes, <a class="el" href="structCabana_1_1HostSpace.html">MemorySpace</a>, VectorLength, type &gt;::slice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an unmanaged slice of a tuple member with default memory access. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The member index to get a slice of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>tag identifying which member to get a slice of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The member slice. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/src/<a class="el" href="Cabana__AoSoA_8hpp_source.html">Cabana_AoSoA.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 12 2018 15:42:33 for Cabana by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
