<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Cabana: Cabana::AoSoA&lt; DataTypes, DeviceType, VectorLength, MemoryTraits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cabana
   &#160;<span id="projectnumber">0.3.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Cabana</b></li><li class="navelem"><a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classCabana_1_1AoSoA-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Cabana::AoSoA&lt; DataTypes, DeviceType, VectorLength, MemoryTraits &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Array-of-Struct-of-Arrays.  
 <a href="classCabana_1_1AoSoA.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Cabana__AoSoA_8hpp_source.html">Cabana_AoSoA.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acdddfc2fcfb168c0c1790573ec07558e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdddfc2fcfb168c0c1790573ec07558e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>aosoa_type</b> = <a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;</td></tr>
<tr class="separator:acdddfc2fcfb168c0c1790573ec07558e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f62d7060ceb32d56f600650087d784"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82f62d7060ceb32d56f600650087d784"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>member_types</b> = <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a></td></tr>
<tr class="separator:a82f62d7060ceb32d56f600650087d784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bcb213b8730b4b6d9c4d4c97a1d7c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08bcb213b8730b4b6d9c4d4c97a1d7c6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>device_type</b> = DeviceType</td></tr>
<tr class="separator:a08bcb213b8730b4b6d9c4d4c97a1d7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01ceedcd50a61aed1bcca8421fc9dbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac01ceedcd50a61aed1bcca8421fc9dbe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>memory_space</b> = typename device_type::memory_space</td></tr>
<tr class="separator:ac01ceedcd50a61aed1bcca8421fc9dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072e5075225163d8396d17f21266f394"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a072e5075225163d8396d17f21266f394"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>execution_space</b> = typename device_type::execution_space</td></tr>
<tr class="separator:a072e5075225163d8396d17f21266f394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea56415eb6e1a653be933457fc799516"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea56415eb6e1a653be933457fc799516"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>memory_traits</b> = MemoryTraits</td></tr>
<tr class="separator:aea56415eb6e1a653be933457fc799516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e91888b0223290f9483ff5cec84872"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67e91888b0223290f9483ff5cec84872"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename memory_space::size_type</td></tr>
<tr class="separator:a67e91888b0223290f9483ff5cec84872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578753a4294a89bae864fe336018fbe4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a578753a4294a89bae864fe336018fbe4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>soa_type</b> = <a class="el" href="structCabana_1_1SoA.html">SoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">member_types</a>, vector_length &gt;</td></tr>
<tr class="separator:a578753a4294a89bae864fe336018fbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab243ad48b20cb3050e7f7a3b8ff52743"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab243ad48b20cb3050e7f7a3b8ff52743"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>soa_view</b> = Kokkos::View&lt; <a class="el" href="structCabana_1_1SoA.html">soa_type</a> *, device_type, memory_traits &gt;</td></tr>
<tr class="separator:ab243ad48b20cb3050e7f7a3b8ff52743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ea168328e8d0ae5bad700291f91e34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4ea168328e8d0ae5bad700291f91e34"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>index_type</b> = <a class="el" href="classCabana_1_1Impl_1_1Index.html">Impl::Index</a>&lt; vector_length &gt;</td></tr>
<tr class="separator:ae4ea168328e8d0ae5bad700291f91e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4d16bcfecf74f5e3a34b27a9564a90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade4d16bcfecf74f5e3a34b27a9564a90"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>tuple_type</b> = <a class="el" href="structCabana_1_1Tuple.html">Tuple</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">member_types</a> &gt;</td></tr>
<tr class="separator:ade4d16bcfecf74f5e3a34b27a9564a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbb59f8a982c8120367f361c2dcbe74"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7bbb59f8a982c8120367f361c2dcbe74"></a>
template&lt;std::size_t M&gt; </td></tr>
<tr class="memitem:a7bbb59f8a982c8120367f361c2dcbe74"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>member_data_type</b> = typename <a class="el" href="structCabana_1_1MemberTypeAtIndex.html">MemberTypeAtIndex</a>&lt; M, <a class="el" href="structCabana_1_1MemberTypes.html">member_types</a> &gt;::type</td></tr>
<tr class="separator:a7bbb59f8a982c8120367f361c2dcbe74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c939a21a5efea816aede2d7ec87bc6e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2c939a21a5efea816aede2d7ec87bc6e"></a>
template&lt;std::size_t M&gt; </td></tr>
<tr class="memitem:a2c939a21a5efea816aede2d7ec87bc6e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>member_value_type</b> = typename std::remove_all_extents&lt; member_data_type&lt; M &gt; &gt;::type</td></tr>
<tr class="separator:a2c939a21a5efea816aede2d7ec87bc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cac0b143264268046e02113de0e809e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9cac0b143264268046e02113de0e809e"></a>
template&lt;std::size_t M&gt; </td></tr>
<tr class="memitem:a9cac0b143264268046e02113de0e809e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>member_pointer_type</b> = typename std::add_pointer&lt; member_value_type&lt; M &gt; &gt;::type</td></tr>
<tr class="separator:a9cac0b143264268046e02113de0e809e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74acdf21069c7c7380d42b1acf28fd1"><td class="memTemplParams" colspan="2"><a class="anchor" id="af74acdf21069c7c7380d42b1acf28fd1"></a>
template&lt;std::size_t M&gt; </td></tr>
<tr class="memitem:af74acdf21069c7c7380d42b1acf28fd1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>member_slice_type</b> = <a class="el" href="classCabana_1_1Slice.html">Slice</a>&lt; member_data_type&lt; M &gt;, device_type, <a class="el" href="structCabana_1_1DefaultAccessMemory.html">DefaultAccessMemory</a>, vector_length, sizeof(<a class="el" href="structCabana_1_1SoA.html">soa_type</a>)/sizeof(member_value_type&lt; M &gt;)&gt;</td></tr>
<tr class="separator:af74acdf21069c7c7380d42b1acf28fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a874cfb5b0e84e6fe439d38bc714d355f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a874cfb5b0e84e6fe439d38bc714d355f">AoSoA</a> (const std::string &amp;<a class="el" href="classCabana_1_1AoSoA.html#ac092b0144c31ffce6e631aca534817f6">label</a>=&quot;&quot;)</td></tr>
<tr class="memdesc:a874cfb5b0e84e6fe439d38bc714d355f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a874cfb5b0e84e6fe439d38bc714d355f">More...</a><br/></td></tr>
<tr class="separator:a874cfb5b0e84e6fe439d38bc714d355f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad015c4b8d98ad56598c2fa2e3305159e"><td class="memItemLeft" align="right" valign="top">CABANA_DEPRECATED&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#ad015c4b8d98ad56598c2fa2e3305159e">AoSoA</a> (const size_type n)</td></tr>
<tr class="memdesc:ad015c4b8d98ad56598c2fa2e3305159e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a container with n tuples.  <a href="#ad015c4b8d98ad56598c2fa2e3305159e">More...</a><br/></td></tr>
<tr class="separator:ad015c4b8d98ad56598c2fa2e3305159e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070dac34a357a209724075da06cc72c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a070dac34a357a209724075da06cc72c1">AoSoA</a> (const std::string <a class="el" href="classCabana_1_1AoSoA.html#ac092b0144c31ffce6e631aca534817f6">label</a>, const size_type n)</td></tr>
<tr class="memdesc:a070dac34a357a209724075da06cc72c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a container with n tuples.  <a href="#a070dac34a357a209724075da06cc72c1">More...</a><br/></td></tr>
<tr class="separator:a070dac34a357a209724075da06cc72c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0659aee3d7ab746844077d94fa36ecd8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a0659aee3d7ab746844077d94fa36ecd8">AoSoA</a> (<a class="el" href="structCabana_1_1SoA.html">soa_type</a> *<a class="el" href="classCabana_1_1AoSoA.html#a65f606764fe4f17db7ec1dbea2c6caca">ptr</a>, const size_type num_soa, const size_type n)</td></tr>
<tr class="memdesc:a0659aee3d7ab746844077d94fa36ecd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an unmanaged <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays. ">AoSoA</a> with user-provided memory.  <a href="#a0659aee3d7ab746844077d94fa36ecd8">More...</a><br/></td></tr>
<tr class="separator:a0659aee3d7ab746844077d94fa36ecd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac092b0144c31ffce6e631aca534817f6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#ac092b0144c31ffce6e631aca534817f6">label</a> () const </td></tr>
<tr class="memdesc:ac092b0144c31ffce6e631aca534817f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data structure label.  <a href="#ac092b0144c31ffce6e631aca534817f6">More...</a><br/></td></tr>
<tr class="separator:ac092b0144c31ffce6e631aca534817f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978ee8f822bf68ebe5ca827ebc3cd80f"><td class="memItemLeft" align="right" valign="top">KOKKOS_FUNCTION size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a978ee8f822bf68ebe5ca827ebc3cd80f">size</a> () const </td></tr>
<tr class="memdesc:a978ee8f822bf68ebe5ca827ebc3cd80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of tuples in the container.  <a href="#a978ee8f822bf68ebe5ca827ebc3cd80f">More...</a><br/></td></tr>
<tr class="separator:a978ee8f822bf68ebe5ca827ebc3cd80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c7c9b4ed46b3988831d8a0c5edfaa3"><td class="memItemLeft" align="right" valign="top">KOKKOS_FUNCTION size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#ab2c7c9b4ed46b3988831d8a0c5edfaa3">capacity</a> () const </td></tr>
<tr class="memdesc:ab2c7c9b4ed46b3988831d8a0c5edfaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the storage space currently allocated for the container, expressed in terms of tuples.  <a href="#ab2c7c9b4ed46b3988831d8a0c5edfaa3">More...</a><br/></td></tr>
<tr class="separator:ab2c7c9b4ed46b3988831d8a0c5edfaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7a382835b5809eadba130ce2e9da9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#aec7a382835b5809eadba130ce2e9da9f">resize</a> (const size_type n)</td></tr>
<tr class="memdesc:aec7a382835b5809eadba130ce2e9da9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container so that it contains n tuples.  <a href="#aec7a382835b5809eadba130ce2e9da9f">More...</a><br/></td></tr>
<tr class="separator:aec7a382835b5809eadba130ce2e9da9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657bd2a85ad107ee746a7fc2f4996dd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a657bd2a85ad107ee746a7fc2f4996dd3">reserve</a> (const size_type n)</td></tr>
<tr class="memdesc:a657bd2a85ad107ee746a7fc2f4996dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the container capacity be at least enough to contain n tuples.  <a href="#a657bd2a85ad107ee746a7fc2f4996dd3">More...</a><br/></td></tr>
<tr class="separator:a657bd2a85ad107ee746a7fc2f4996dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fc7416349739ce9e5ec3b017493fbc"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a48fc7416349739ce9e5ec3b017493fbc">numSoA</a> () const </td></tr>
<tr class="memdesc:a48fc7416349739ce9e5ec3b017493fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of structs-of-arrays in the container.  <a href="#a48fc7416349739ce9e5ec3b017493fbc">More...</a><br/></td></tr>
<tr class="separator:a48fc7416349739ce9e5ec3b017493fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6332d0ddb679151d235203e63a59c84"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#ae6332d0ddb679151d235203e63a59c84">arraySize</a> (const size_type s) const </td></tr>
<tr class="memdesc:ae6332d0ddb679151d235203e63a59c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the data array at a given struct member index.  <a href="#ae6332d0ddb679151d235203e63a59c84">More...</a><br/></td></tr>
<tr class="separator:ae6332d0ddb679151d235203e63a59c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fd190d1203462e411f43d3654b8abf"><td class="memItemLeft" align="right" valign="top">KOKKOS_FORCEINLINE_FUNCTION <br class="typebreak"/>
<a class="el" href="structCabana_1_1SoA.html">soa_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a39fd190d1203462e411f43d3654b8abf">access</a> (const size_type s) const </td></tr>
<tr class="memdesc:a39fd190d1203462e411f43d3654b8abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the <a class="el" href="structCabana_1_1SoA.html">SoA</a> at a given index.  <a href="#a39fd190d1203462e411f43d3654b8abf">More...</a><br/></td></tr>
<tr class="separator:a39fd190d1203462e411f43d3654b8abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60b044fe90293b911f7318c320f6f55"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION <a class="el" href="structCabana_1_1Tuple.html">tuple_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#ad60b044fe90293b911f7318c320f6f55">getTuple</a> (const size_type i) const </td></tr>
<tr class="memdesc:ad60b044fe90293b911f7318c320f6f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a tuple at a given index via a deep copy.  <a href="#ad60b044fe90293b911f7318c320f6f55">More...</a><br/></td></tr>
<tr class="separator:ad60b044fe90293b911f7318c320f6f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac834c774799c45be41eacd0218c561cb"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#ac834c774799c45be41eacd0218c561cb">setTuple</a> (const size_type i, const <a class="el" href="structCabana_1_1Tuple.html">tuple_type</a> &amp;tpl) const </td></tr>
<tr class="memdesc:ac834c774799c45be41eacd0218c561cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a tuple at a given index via a deep copy.  <a href="#ac834c774799c45be41eacd0218c561cb">More...</a><br/></td></tr>
<tr class="separator:ac834c774799c45be41eacd0218c561cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32449b93091e7c5333f12fffd33f3db2"><td class="memTemplParams" colspan="2">template&lt;std::size_t M&gt; </td></tr>
<tr class="memitem:a32449b93091e7c5333f12fffd33f3db2"><td class="memTemplItemLeft" align="right" valign="top">CABANA_DEPRECATED <br class="typebreak"/>
<a class="el" href="classCabana_1_1Slice.html">member_slice_type</a>&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a32449b93091e7c5333f12fffd33f3db2">slice</a> (const std::string &amp;slice_label=&quot;&quot;) const </td></tr>
<tr class="memdesc:a32449b93091e7c5333f12fffd33f3db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an unmanaged slice of a tuple member with default memory access.  <a href="#a32449b93091e7c5333f12fffd33f3db2">More...</a><br/></td></tr>
<tr class="separator:a32449b93091e7c5333f12fffd33f3db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f606764fe4f17db7ec1dbea2c6caca"><td class="memItemLeft" align="right" valign="top">CABANA_DEPRECATED void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a65f606764fe4f17db7ec1dbea2c6caca">ptr</a> () const </td></tr>
<tr class="memdesc:a65f606764fe4f17db7ec1dbea2c6caca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an un-typed raw pointer to the entire data block.  <a href="#a65f606764fe4f17db7ec1dbea2c6caca">More...</a><br/></td></tr>
<tr class="separator:a65f606764fe4f17db7ec1dbea2c6caca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8d51d3c7ec415191c6f3124096ad82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCabana_1_1SoA.html">soa_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1AoSoA.html#a1e8d51d3c7ec415191c6f3124096ad82">data</a> () const </td></tr>
<tr class="memdesc:a1e8d51d3c7ec415191c6f3124096ad82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a typed raw pointer to the entire data block.  <a href="#a1e8d51d3c7ec415191c6f3124096ad82">More...</a><br/></td></tr>
<tr class="separator:a1e8d51d3c7ec415191c6f3124096ad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa368e79e965cd8304d69639eca0aeeb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa368e79e965cd8304d69639eca0aeeb9"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>vector_length</b> = VectorLength</td></tr>
<tr class="separator:aa368e79e965cd8304d69639eca0aeeb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af454652985934c8188f0bf4924ea81cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af454652985934c8188f0bf4924ea81cd"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>number_of_members</b> = member_types::size</td></tr>
<tr class="separator:af454652985934c8188f0bf4924ea81cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4fe7dbd55774238c87b0249c225e5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e4fe7dbd55774238c87b0249c225e5e"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_rank</b> = 3</td></tr>
<tr class="separator:a5e4fe7dbd55774238c87b0249c225e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt;<br/>
class Cabana::AoSoA&lt; DataTypes, DeviceType, VectorLength, MemoryTraits &gt;</h3>

<p>Array-of-Struct-of-Arrays. </p>
<p>A <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays. ">AoSoA</a> represents tuples and their data via an array-of-structs-of-arrays.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>(required) Specifically this must be an instance of <code><a class="el" href="structCabana_1_1MemberTypes.html" title="General sequence of types for SoA and AoSoA member data. ">MemberTypes</a></code> with the data layout of the structs. For example: <div class="fragment"><div class="line"><span class="keyword">using</span> DataType = MemberTypes&lt;double[3][3],double[3],int&gt;;</div>
</div><!-- fragment --> would define an <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays. ">AoSoA</a> where each tuple had a 3x3 matrix of doubles, a 3-vector of doubles, and an integer. The <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays. ">AoSoA</a> is then templated on this sequence of types. In general, put larger datatypes first in the MemberType parameter pack (i.e. matrices and vectors) and group members of the same type together to achieve the smallest possible memory footprint based on compiler-generated padding.</td></tr>
    <tr><td class="paramname">DeviceType</td><td>(required) The device type.</td></tr>
    <tr><td class="paramname">VectorLength</td><td>(optional) The vector length within the structs of the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays. ">AoSoA</a>. If not specified, this defaults to the preferred layout for the <code>DeviceType</code>.</td></tr>
    <tr><td class="paramname">MemoryTraits</td><td>(optional) Memory traits for the <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays. ">AoSoA</a> data. Can be used to indicate managed memory, unmanaged memory, etc. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a874cfb5b0e84e6fe439d38bc714d355f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::<a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>An optional label for the data structure.</td></tr>
  </table>
  </dd>
</dl>
<p>The container size is zero and no memory is allocated. </p>

</div>
</div>
<a class="anchor" id="ad015c4b8d98ad56598c2fa2e3305159e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CABANA_DEPRECATED <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::<a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a> </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a container with n tuples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of tuples in the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: this function has been deprecated in favor of the constructor that uses a label as this is more consistent with the construction of a Kokkos View. </p>

</div>
</div>
<a class="anchor" id="a070dac34a357a209724075da06cc72c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::<a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a container with n tuples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>A label for the data structure.</td></tr>
    <tr><td class="paramname">n</td><td>The number of tuples in the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0659aee3d7ab746844077d94fa36ecd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::<a class="el" href="classCabana_1_1AoSoA.html">AoSoA</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCabana_1_1SoA.html">soa_type</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>num_soa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an unmanaged <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays. ">AoSoA</a> with user-provided memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to user-allocated <a class="el" href="classCabana_1_1AoSoA.html" title="Array-of-Struct-of-Arrays. ">AoSoA</a> data.</td></tr>
    <tr><td class="paramname">num_soa</td><td>The number of SoAs the user has allocated.</td></tr>
    <tr><td class="paramname">n</td><td>The number of tuples in the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a39fd190d1203462e411f43d3654b8abf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_FORCEINLINE_FUNCTION <a class="el" href="structCabana_1_1SoA.html">soa_type</a>&amp; <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::access </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the <a class="el" href="structCabana_1_1SoA.html">SoA</a> at a given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structCabana_1_1SoA.html">SoA</a> index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structCabana_1_1SoA.html">SoA</a> reference at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6332d0ddb679151d235203e63a59c84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION size_type <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::arraySize </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the data array at a given struct member index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The struct index to get the array size for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the array at the given struct index. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2c7c9b4ed46b3988831d8a0c5edfaa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_FUNCTION size_type <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the storage space currently allocated for the container, expressed in terms of tuples. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the container.</dd></dl>
<p>This capacity is not necessarily equal to the container size. It can be equal or greater, with the extra space allowing to accommodate for growth without the need to reallocate on each insertion.</p>
<p>Notice that this capacity does not suppose a limit on the size of the container. When this capacity is exhausted and more is needed, it is automatically expanded by the container (reallocating it storage space).</p>
<p>The capacity of a container can be explicitly altered by calling member reserve. </p>

</div>
</div>
<a class="anchor" id="a1e8d51d3c7ec415191c6f3124096ad82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCabana_1_1SoA.html">soa_type</a>* <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::<a class="el" href="structdata.html">data</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a typed raw pointer to the entire data block. </p>
<dl class="section return"><dt>Returns</dt><dd>A typed raw-pointer to the entire data block. </dd></dl>

</div>
</div>
<a class="anchor" id="ad60b044fe90293b911f7318c320f6f55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION <a class="el" href="structCabana_1_1Tuple.html">tuple_type</a> <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::getTuple </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a tuple at a given index via a deep copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index to get the tuple from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing a deep copy of the data at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="ac092b0144c31ffce6e631aca534817f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data structure label. </p>
<dl class="section return"><dt>Returns</dt><dd>A string identifying the data structure.</dd></dl>
<p>This label will be assigned to the underlying Kokkos view managing the data of this class and can be used for debugging and profiling purposes. </p>

</div>
</div>
<a class="anchor" id="a48fc7416349739ce9e5ec3b017493fbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION size_type <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::numSoA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of structs-of-arrays in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of structs-of-arrays in the container. </dd></dl>

</div>
</div>
<a class="anchor" id="a65f606764fe4f17db7ec1dbea2c6caca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CABANA_DEPRECATED void* <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an un-typed raw pointer to the entire data block. </p>
<dl class="section return"><dt>Returns</dt><dd>An un-typed raw-pointer to the entire data block. </dd></dl>

</div>
</div>
<a class="anchor" id="a657bd2a85ad107ee746a7fc2f4996dd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the container capacity be at least enough to contain n tuples. </p>
<p>If n is greater than the current container capacity, the function causes the container to reallocate its storage increasing its capacity to n (or greater).</p>
<p>In all other cases, the function call does not cause a reallocation and the container capacity is not affected.</p>
<p>This function has no effect on the container size and cannot alter its tuples. </p>

</div>
</div>
<a class="anchor" id="aec7a382835b5809eadba130ce2e9da9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container so that it contains n tuples. </p>
<p>If n is smaller than the current container size, the content is reduced to its first n tuples.</p>
<p>If n is greater than the current container size, the content is expanded by inserting at the end as many tuples as needed to reach a size of n.</p>
<p>If n is also greater than the current container capacity, an automatic reallocation of the allocated storage space takes place.</p>
<p>Notice that this function changes the actual content of the container by inserting or erasing tuples from it. </p>

</div>
</div>
<a class="anchor" id="ac834c774799c45be41eacd0218c561cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::setTuple </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCabana_1_1Tuple.html">tuple_type</a> &amp;&#160;</td>
          <td class="paramname"><em>tpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a tuple at a given index via a deep copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index to set the tuple at.</td></tr>
    <tr><td class="paramname">tuple</td><td>The tuple to get the data from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a978ee8f822bf68ebe5ca827ebc3cd80f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_FUNCTION size_type <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of tuples in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of tuples in the container.</dd></dl>
<p>This is the number of actual objects held in the container, which is not necessarily equal to its storage capacity. </p>

</div>
</div>
<a class="anchor" id="a32449b93091e7c5333f12fffd33f3db2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataTypes, class DeviceType, int VectorLength, class MemoryTraits&gt; </div>
<div class="memtemplate">
template&lt;std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CABANA_DEPRECATED <a class="el" href="classCabana_1_1Slice.html">member_slice_type</a>&lt;M&gt; <a class="el" href="classCabana_1_1AoSoA.html">Cabana::AoSoA</a>&lt; <a class="el" href="structCabana_1_1MemberTypes.html">DataTypes</a>, DeviceType, VectorLength, MemoryTraits &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>slice_label</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an unmanaged slice of a tuple member with default memory access. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The member index to get a slice of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_label</td><td>An optional label to assign to the slice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The member slice. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/src/<a class="el" href="Cabana__AoSoA_8hpp_source.html">Cabana_AoSoA.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 11 2019 21:43:07 for Cabana by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
