<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cabana: Cabana::Halo&lt; MemorySpace, BuildType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cabana<span id="projectnumber">&#160;0.8.0-dev</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classCabana_1_1Halo.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCabana_1_1Halo-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Cabana::Halo&lt; MemorySpace, BuildType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A communication plan for scattering and gathering of ghosted data.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Cabana__Halo_8hpp_source.html">Cabana_Halo.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Cabana::Halo&lt; MemorySpace, BuildType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classCabana_1_1Halo__inherit__graph.png" border="0" usemap="#aCabana_1_1Halo_3_01MemorySpace_00_01BuildType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aCabana_1_1Halo_3_01MemorySpace_00_01BuildType_01_4_inherit__map" id="aCabana_1_1Halo_3_01MemorySpace_00_01BuildType_01_4_inherit__map">
<area shape="rect" title="A communication plan for scattering and gathering of ghosted data." alt="" coords="5,102,212,151"/>
<area shape="rect" href="classCabana_1_1CommunicationPlan.html" title="Communication plan base class." alt="" coords="10,5,207,54"/>
<area shape="poly" title=" " alt="" coords="111,69,111,101,106,101,106,69"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Cabana::Halo&lt; MemorySpace, BuildType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classCabana_1_1Halo__coll__graph.png" border="0" usemap="#aCabana_1_1Halo_3_01MemorySpace_00_01BuildType_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aCabana_1_1Halo_3_01MemorySpace_00_01BuildType_01_4_coll__map" id="aCabana_1_1Halo_3_01MemorySpace_00_01BuildType_01_4_coll__map">
<area shape="rect" title="A communication plan for scattering and gathering of ghosted data." alt="" coords="5,102,212,151"/>
<area shape="rect" href="classCabana_1_1CommunicationPlan.html" title="Communication plan base class." alt="" coords="10,5,207,54"/>
<area shape="poly" title=" " alt="" coords="111,69,111,101,106,101,106,69"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5f69fd5594bc26e9b672000fff26be75" id="r_a5f69fd5594bc26e9b672000fff26be75"><td class="memTemplParams" colspan="2">template&lt;class IdViewType, class RankViewType, typename T = BuildType, std::enable_if_t&lt; std::is_same&lt; T, <a class="el" href="structCabana_1_1Export.html">Export</a> &gt;::value, int &gt; = 0&gt; </td></tr>
<tr class="memitem:a5f69fd5594bc26e9b672000fff26be75"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5f69fd5594bc26e9b672000fff26be75">Halo</a> (MPI_Comm <a class="el" href="classCabana_1_1CommunicationPlan.html#a614a7eb904961fd1c301accd4f8b9848">comm</a>, const std::size_t num_local, const IdViewType &amp;element_ids, const RankViewType &amp;element_ranks, const std::vector&lt; int &gt; &amp;neighbor_ranks)</td></tr>
<tr class="memdesc:a5f69fd5594bc26e9b672000fff26be75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor and export rank constructor. Use this when you don't know who you will receiving from - only who you are sending to, but you already know which ranks neighbor each other (i.e. every rank already knows who they will be exporting to and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send and receive from the neighbors.  <br /></td></tr>
<tr class="separator:a5f69fd5594bc26e9b672000fff26be75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c39f13fe61bcfbd22e183785c4c83b6" id="r_a6c39f13fe61bcfbd22e183785c4c83b6"><td class="memTemplParams" colspan="2">template&lt;class IdViewType, class RankViewType, typename T = BuildType, std::enable_if_t&lt; std::is_same&lt; T, <a class="el" href="structCabana_1_1Export.html">Export</a> &gt;::value, int &gt; = 0&gt; </td></tr>
<tr class="memitem:a6c39f13fe61bcfbd22e183785c4c83b6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c39f13fe61bcfbd22e183785c4c83b6">Halo</a> (MPI_Comm <a class="el" href="classCabana_1_1CommunicationPlan.html#a614a7eb904961fd1c301accd4f8b9848">comm</a>, const std::size_t num_local, const IdViewType &amp;element_ids, const RankViewType &amp;element_ranks)</td></tr>
<tr class="memdesc:a6c39f13fe61bcfbd22e183785c4c83b6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Export.html" title="Export-based tag - default.">Export</a> rank constructor. Use this when you don't know who you will receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first.  <br /></td></tr>
<tr class="separator:a6c39f13fe61bcfbd22e183785c4c83b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f69fd5594bc26e9b672000fff26be75" id="r_a5f69fd5594bc26e9b672000fff26be75"><td class="memTemplParams" colspan="2">template&lt;class IdViewType, class RankViewType, typename T = BuildType, std::enable_if_t&lt; std::is_same&lt; T, <a class="el" href="structCabana_1_1Import.html">Import</a> &gt;::value, int &gt; = 0&gt; </td></tr>
<tr class="memitem:a5f69fd5594bc26e9b672000fff26be75"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5f69fd5594bc26e9b672000fff26be75">Halo</a> (MPI_Comm <a class="el" href="classCabana_1_1CommunicationPlan.html#a614a7eb904961fd1c301accd4f8b9848">comm</a>, const std::size_t num_local, const IdViewType &amp;element_ids, const RankViewType &amp;element_ranks, const std::vector&lt; int &gt; &amp;neighbor_ranks)</td></tr>
<tr class="memdesc:a5f69fd5594bc26e9b672000fff26be75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor and import rank constructor. Use this when you don't know who you will sending to - only who you are receiving from, but you already know which ranks neighbor each other (i.e. every rank already knows who they will be exporting to and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send and receive from the neighbors.  <br /></td></tr>
<tr class="separator:a5f69fd5594bc26e9b672000fff26be75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c39f13fe61bcfbd22e183785c4c83b6" id="r_a6c39f13fe61bcfbd22e183785c4c83b6"><td class="memTemplParams" colspan="2">template&lt;class IdViewType, class RankViewType, typename T = BuildType, std::enable_if_t&lt; std::is_same&lt; T, <a class="el" href="structCabana_1_1Import.html">Import</a> &gt;::value, int &gt; = 0&gt; </td></tr>
<tr class="memitem:a6c39f13fe61bcfbd22e183785c4c83b6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c39f13fe61bcfbd22e183785c4c83b6">Halo</a> (MPI_Comm <a class="el" href="classCabana_1_1CommunicationPlan.html#a614a7eb904961fd1c301accd4f8b9848">comm</a>, const std::size_t num_local, const IdViewType &amp;element_ids, const RankViewType &amp;element_ranks)</td></tr>
<tr class="memdesc:a6c39f13fe61bcfbd22e183785c4c83b6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Import.html" title="Import-based tag.">Import</a> rank constructor. Use this when you don't know which ranks neighbor each other. (i.e. every rank does not already know who they will be exporting to and receiving from)  <br /></td></tr>
<tr class="separator:a6c39f13fe61bcfbd22e183785c4c83b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7fa1e057f65089995a01895283f4b2" id="r_a6a7fa1e057f65089995a01895283f4b2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a7fa1e057f65089995a01895283f4b2">numLocal</a> () const</td></tr>
<tr class="memdesc:a6a7fa1e057f65089995a01895283f4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements locally owned by this rank.  <br /></td></tr>
<tr class="separator:a6a7fa1e057f65089995a01895283f4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a2f092117288f3aff7d93b016dd6e7" id="r_a20a2f092117288f3aff7d93b016dd6e7"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20a2f092117288f3aff7d93b016dd6e7">numGhost</a> () const</td></tr>
<tr class="memdesc:a20a2f092117288f3aff7d93b016dd6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ghost elements this rank. Use this to resize a data structure for scatter/gather operations. For use with scatter gather, a data structure should be of size <a class="el" href="#a6a7fa1e057f65089995a01895283f4b2" title="Get the number of elements locally owned by this rank.">numLocal()</a> + <a class="el" href="#a20a2f092117288f3aff7d93b016dd6e7" title="Get the number of ghost elements this rank. Use this to resize a data structure for scatter/gather op...">numGhost()</a>.  <br /></td></tr>
<tr class="separator:a20a2f092117288f3aff7d93b016dd6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classCabana_1_1CommunicationPlan"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classCabana_1_1CommunicationPlan')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan&lt; MemorySpace &gt;</a></td></tr>
<tr class="memitem:ad37cb95149bc904f4da45e193dc59cd3 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_ad37cb95149bc904f4da45e193dc59cd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#ad37cb95149bc904f4da45e193dc59cd3">CommunicationPlan</a> (MPI_Comm <a class="el" href="classCabana_1_1CommunicationPlan.html#a614a7eb904961fd1c301accd4f8b9848">comm</a>)</td></tr>
<tr class="memdesc:ad37cb95149bc904f4da45e193dc59cd3 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:ad37cb95149bc904f4da45e193dc59cd3 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614a7eb904961fd1c301accd4f8b9848 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a614a7eb904961fd1c301accd4f8b9848"><td class="memItemLeft" align="right" valign="top">
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><b>comm</b> () const</td></tr>
<tr class="memdesc:a614a7eb904961fd1c301accd4f8b9848 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MPI communicator. <br /></td></tr>
<tr class="separator:a614a7eb904961fd1c301accd4f8b9848 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45792fbc446d3289cb3028a730bcd959 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a45792fbc446d3289cb3028a730bcd959"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a45792fbc446d3289cb3028a730bcd959">numNeighbor</a> () const</td></tr>
<tr class="memdesc:a45792fbc446d3289cb3028a730bcd959 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of neighbor ranks that this rank will communicate with.  <br /></td></tr>
<tr class="separator:a45792fbc446d3289cb3028a730bcd959 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d67b24c7e983fc6adafd04f5887dfb inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a97d67b24c7e983fc6adafd04f5887dfb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a97d67b24c7e983fc6adafd04f5887dfb">neighborRank</a> (const int neighbor) const</td></tr>
<tr class="memdesc:a97d67b24c7e983fc6adafd04f5887dfb inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a local neighbor id get its rank in the MPI communicator.  <br /></td></tr>
<tr class="separator:a97d67b24c7e983fc6adafd04f5887dfb inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e22d0dd1f9fd7ac52de395f2a74d9bd inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a8e22d0dd1f9fd7ac52de395f2a74d9bd"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a8e22d0dd1f9fd7ac52de395f2a74d9bd">numExport</a> (const int neighbor) const</td></tr>
<tr class="memdesc:a8e22d0dd1f9fd7ac52de395f2a74d9bd inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements this rank will export to a given neighbor.  <br /></td></tr>
<tr class="separator:a8e22d0dd1f9fd7ac52de395f2a74d9bd inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c004e3614b1d62fd95f55bdcf3ce5d inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a57c004e3614b1d62fd95f55bdcf3ce5d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a57c004e3614b1d62fd95f55bdcf3ce5d">totalNumExport</a> () const</td></tr>
<tr class="memdesc:a57c004e3614b1d62fd95f55bdcf3ce5d inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of exports this rank will do.  <br /></td></tr>
<tr class="separator:a57c004e3614b1d62fd95f55bdcf3ce5d inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905dbd5d80fc34f0299ecf24e30274c5 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a905dbd5d80fc34f0299ecf24e30274c5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a905dbd5d80fc34f0299ecf24e30274c5">numImport</a> (const int neighbor) const</td></tr>
<tr class="memdesc:a905dbd5d80fc34f0299ecf24e30274c5 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements this rank will import from a given neighbor.  <br /></td></tr>
<tr class="separator:a905dbd5d80fc34f0299ecf24e30274c5 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b8a67e50990c64f8e8923982d7f306 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a93b8a67e50990c64f8e8923982d7f306"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a93b8a67e50990c64f8e8923982d7f306">totalNumImport</a> () const</td></tr>
<tr class="memdesc:a93b8a67e50990c64f8e8923982d7f306 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of imports this rank will do.  <br /></td></tr>
<tr class="separator:a93b8a67e50990c64f8e8923982d7f306 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe2c790ef56d1d027ae6d29b63b1198 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a1fe2c790ef56d1d027ae6d29b63b1198"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a1fe2c790ef56d1d027ae6d29b63b1198">exportSize</a> () const</td></tr>
<tr class="memdesc:a1fe2c790ef56d1d027ae6d29b63b1198 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of export elements.  <br /></td></tr>
<tr class="separator:a1fe2c790ef56d1d027ae6d29b63b1198 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0864132bc0c1a26c7fb33d8e9ed059c0 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a0864132bc0c1a26c7fb33d8e9ed059c0"><td class="memItemLeft" align="right" valign="top">Kokkos::View&lt; std::size_t *, <a class="el" href="classCabana_1_1CommunicationPlan.html#a4b57656297b6e95ac7dce53d6967f1df">memory_space</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a0864132bc0c1a26c7fb33d8e9ed059c0">getExportSteering</a> () const</td></tr>
<tr class="memdesc:a0864132bc0c1a26c7fb33d8e9ed059c0 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the steering vector for the exports.  <br /></td></tr>
<tr class="separator:a0864132bc0c1a26c7fb33d8e9ed059c0 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4845343a014ce1e73ad07ce56a7abacb inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a4845343a014ce1e73ad07ce56a7abacb"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class RankViewType&gt; </td></tr>
<tr class="memitem:a4845343a014ce1e73ad07ce56a7abacb inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlan.html#a2888c5686762460a20d0cc78aea4e9d4">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlan.html#a4b57656297b6e95ac7dce53d6967f1df">memory_space</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a4845343a014ce1e73ad07ce56a7abacb">createWithTopology</a> (ExecutionSpace exec_space, <a class="el" href="structCabana_1_1Export.html">Export</a>, const RankViewType &amp;element_export_ranks, const std::vector&lt; int &gt; &amp;neighbor_ranks)</td></tr>
<tr class="memdesc:a4845343a014ce1e73ad07ce56a7abacb inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor and export rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors.  <br /></td></tr>
<tr class="separator:a4845343a014ce1e73ad07ce56a7abacb inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0730029e5db0fec6e7ac9599749f9093 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a0730029e5db0fec6e7ac9599749f9093"><td class="memTemplParams" colspan="2">template&lt;class RankViewType&gt; </td></tr>
<tr class="memitem:a0730029e5db0fec6e7ac9599749f9093 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlan.html#a2888c5686762460a20d0cc78aea4e9d4">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlan.html#a4b57656297b6e95ac7dce53d6967f1df">memory_space</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a0730029e5db0fec6e7ac9599749f9093">createWithTopology</a> (<a class="el" href="structCabana_1_1Export.html">Export</a>, const RankViewType &amp;element_export_ranks, const std::vector&lt; int &gt; &amp;neighbor_ranks)</td></tr>
<tr class="memdesc:a0730029e5db0fec6e7ac9599749f9093 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor and export rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors.  <br /></td></tr>
<tr class="separator:a0730029e5db0fec6e7ac9599749f9093 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453a8e993c45cf0eb89ae6b67ebbf5af inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a453a8e993c45cf0eb89ae6b67ebbf5af"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class RankViewType&gt; </td></tr>
<tr class="memitem:a453a8e993c45cf0eb89ae6b67ebbf5af inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlan.html#a2888c5686762460a20d0cc78aea4e9d4">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlan.html#a4b57656297b6e95ac7dce53d6967f1df">memory_space</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a453a8e993c45cf0eb89ae6b67ebbf5af">createWithoutTopology</a> (ExecutionSpace exec_space, <a class="el" href="structCabana_1_1Export.html">Export</a>, const RankViewType &amp;element_export_ranks)</td></tr>
<tr class="memdesc:a453a8e993c45cf0eb89ae6b67ebbf5af inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Export.html" title="Export-based tag - default.">Export</a> rank creator. Use this when you don't know who you will receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first.  <br /></td></tr>
<tr class="separator:a453a8e993c45cf0eb89ae6b67ebbf5af inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad266968f06c80cbe77db80e863a81d34 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_ad266968f06c80cbe77db80e863a81d34"><td class="memTemplParams" colspan="2">template&lt;class RankViewType&gt; </td></tr>
<tr class="memitem:ad266968f06c80cbe77db80e863a81d34 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlan.html#a2888c5686762460a20d0cc78aea4e9d4">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlan.html#a4b57656297b6e95ac7dce53d6967f1df">memory_space</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#ad266968f06c80cbe77db80e863a81d34">createWithoutTopology</a> (<a class="el" href="structCabana_1_1Export.html">Export</a>, const RankViewType &amp;element_export_ranks)</td></tr>
<tr class="memdesc:ad266968f06c80cbe77db80e863a81d34 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Export.html" title="Export-based tag - default.">Export</a> rank creator. Use this when you don't know who you will receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first.  <br /></td></tr>
<tr class="separator:ad266968f06c80cbe77db80e863a81d34 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6431801fb098675e1723225dac4f30ca inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a6431801fb098675e1723225dac4f30ca"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class RankViewType, class IdViewType&gt; </td></tr>
<tr class="memitem:a6431801fb098675e1723225dac4f30ca inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a6431801fb098675e1723225dac4f30ca">createWithTopology</a> (ExecutionSpace exec_space, <a class="el" href="structCabana_1_1Import.html">Import</a>, const RankViewType &amp;element_import_ranks, const IdViewType &amp;element_import_ids, const std::vector&lt; int &gt; &amp;neighbor_ranks) -&gt; std::tuple&lt; Kokkos::View&lt; typename RankViewType::size_type *, typename RankViewType::memory_space &gt;, Kokkos::View&lt; int *, typename RankViewType::memory_space &gt;, Kokkos::View&lt; int *, typename IdViewType::memory_space &gt; &gt;</td></tr>
<tr class="memdesc:a6431801fb098675e1723225dac4f30ca inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor and import rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors.  <br /></td></tr>
<tr class="separator:a6431801fb098675e1723225dac4f30ca inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed6e777d594c30686fe354c20beea5f inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a3ed6e777d594c30686fe354c20beea5f"><td class="memTemplParams" colspan="2">template&lt;class RankViewType, class IdViewType&gt; </td></tr>
<tr class="memitem:a3ed6e777d594c30686fe354c20beea5f inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a3ed6e777d594c30686fe354c20beea5f">createWithTopology</a> (<a class="el" href="structCabana_1_1Import.html">Import</a>, const RankViewType &amp;element_import_ranks, const IdViewType &amp;element_import_ids, const std::vector&lt; int &gt; &amp;neighbor_ranks)</td></tr>
<tr class="memdesc:a3ed6e777d594c30686fe354c20beea5f inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor and import rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors.  <br /></td></tr>
<tr class="separator:a3ed6e777d594c30686fe354c20beea5f inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab068ab8ffe3c1d3ba2fec974ac1a9ff5 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_ab068ab8ffe3c1d3ba2fec974ac1a9ff5"><td class="memTemplParams" colspan="2">template&lt;class ExecutionSpace, class RankViewType, class IdViewType&gt; </td></tr>
<tr class="memitem:ab068ab8ffe3c1d3ba2fec974ac1a9ff5 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#ab068ab8ffe3c1d3ba2fec974ac1a9ff5">createWithoutTopology</a> (ExecutionSpace exec_space, <a class="el" href="structCabana_1_1Import.html">Import</a>, const RankViewType &amp;element_import_ranks, const IdViewType &amp;element_import_ids) -&gt; std::tuple&lt; Kokkos::View&lt; typename RankViewType::size_type *, typename RankViewType::memory_space &gt;, Kokkos::View&lt; int *, typename RankViewType::memory_space &gt;, Kokkos::View&lt; int *, typename IdViewType::memory_space &gt; &gt;</td></tr>
<tr class="memdesc:ab068ab8ffe3c1d3ba2fec974ac1a9ff5 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Import.html" title="Import-based tag.">Import</a> rank creator. Use this when you don't know who you will be receiving from - only who you are importing from. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first.  <br /></td></tr>
<tr class="separator:ab068ab8ffe3c1d3ba2fec974ac1a9ff5 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563ba842b419411df93d2750cc83aed8 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a563ba842b419411df93d2750cc83aed8"><td class="memTemplParams" colspan="2">template&lt;class RankViewType, class IdViewType&gt; </td></tr>
<tr class="memitem:a563ba842b419411df93d2750cc83aed8 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a563ba842b419411df93d2750cc83aed8">createWithoutTopology</a> (<a class="el" href="structCabana_1_1Import.html">Import</a>, const RankViewType &amp;element_import_ranks, const IdViewType &amp;element_import_ids)</td></tr>
<tr class="memdesc:a563ba842b419411df93d2750cc83aed8 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structCabana_1_1Import.html" title="Import-based tag.">Import</a> rank creator. Use this when you don't know who you will be receiving from - only who you are importing from. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first.  <br /></td></tr>
<tr class="separator:a563ba842b419411df93d2750cc83aed8 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d09203fe92d9a63f2852bdfd317c72a inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a4d09203fe92d9a63f2852bdfd317c72a"><td class="memTemplParams" colspan="2">template&lt;class PackViewType, class RankViewType&gt; </td></tr>
<tr class="memitem:a4d09203fe92d9a63f2852bdfd317c72a inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a4d09203fe92d9a63f2852bdfd317c72a">createExportSteering</a> (const PackViewType &amp;neighbor_ids, const RankViewType &amp;element_export_ranks)</td></tr>
<tr class="memdesc:a4d09203fe92d9a63f2852bdfd317c72a inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the export steering vector.  <br /></td></tr>
<tr class="separator:a4d09203fe92d9a63f2852bdfd317c72a inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9b8b82a49acbca33d63164320d44f5 inherit pub_methods_classCabana_1_1CommunicationPlan" id="r_a9e9b8b82a49acbca33d63164320d44f5"><td class="memTemplParams" colspan="2">template&lt;class PackViewType, class RankViewType, class IdViewType&gt; </td></tr>
<tr class="memitem:a9e9b8b82a49acbca33d63164320d44f5 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a9e9b8b82a49acbca33d63164320d44f5">createExportSteering</a> (const PackViewType &amp;neighbor_ids, const RankViewType &amp;element_export_ranks, const IdViewType &amp;element_export_ids)</td></tr>
<tr class="memdesc:a9e9b8b82a49acbca33d63164320d44f5 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the export steering vector.  <br /></td></tr>
<tr class="separator:a9e9b8b82a49acbca33d63164320d44f5 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classCabana_1_1CommunicationPlan"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classCabana_1_1CommunicationPlan')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan&lt; MemorySpace &gt;</a></td></tr>
<tr class="memitem:a4b57656297b6e95ac7dce53d6967f1df inherit pub_types_classCabana_1_1CommunicationPlan" id="r_a4b57656297b6e95ac7dce53d6967f1df"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>memory_space</b> = MemorySpace</td></tr>
<tr class="memdesc:a4b57656297b6e95ac7dce53d6967f1df inherit pub_types_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kokkos memory space. <br /></td></tr>
<tr class="separator:a4b57656297b6e95ac7dce53d6967f1df inherit pub_types_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae846372aa7018c5da4d017502a0803e2 inherit pub_types_classCabana_1_1CommunicationPlan" id="r_ae846372aa7018c5da4d017502a0803e2"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>execution_space</b> = typename memory_space::execution_space</td></tr>
<tr class="memdesc:ae846372aa7018c5da4d017502a0803e2 inherit pub_types_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default execution space. <br /></td></tr>
<tr class="separator:ae846372aa7018c5da4d017502a0803e2 inherit pub_types_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2888c5686762460a20d0cc78aea4e9d4 inherit pub_types_classCabana_1_1CommunicationPlan" id="r_a2888c5686762460a20d0cc78aea4e9d4"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename memory_space::memory_space::size_type</td></tr>
<tr class="memdesc:a2888c5686762460a20d0cc78aea4e9d4 inherit pub_types_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type. <br /></td></tr>
<tr class="separator:a2888c5686762460a20d0cc78aea4e9d4 inherit pub_types_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class MemorySpace, class BuildType = Export&gt;<br />
class Cabana::Halo&lt; MemorySpace, BuildType &gt;</div><p>A communication plan for scattering and gathering of ghosted data. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MemorySpace</td><td>Kokkos memory space in which data for this class will be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>The halo allows for scatter and gather operations between locally-owned and ghosted data. All data in the <a class="el" href="classCabana_1_1Halo.html" title="A communication plan for scattering and gathering of ghosted data.">Halo</a> (e.g. export and import data) is from the point of view of the forward <em>GATHER</em> operation such that, for example, the number of exports is the number of exports in the gather and the number of imports is the number of imports in the gather. The reverse <em>SCATTER</em> operation sends the ghosted data back the the uniquely-owned decomposition and resolves collisions. Based on input for the forward communication plan (where local data will be sent) the local number of ghosts is computed. Some nomenclature:</p>
<p><a class="el" href="structCabana_1_1Export.html" title="Export-based tag - default.">Export</a> - the local data we uniquely own that we will send to other ranks for those ranks to be used as ghosts. <a class="el" href="structCabana_1_1Export.html" title="Export-based tag - default.">Export</a> is used in the context of the forward communication plan (the gather).</p>
<p><a class="el" href="structCabana_1_1Import.html" title="Import-based tag.">Import</a> - the ghost data that we get from other ranks. The rank we get a ghost from is the unique owner of that data. <a class="el" href="structCabana_1_1Import.html" title="Import-based tag.">Import</a> is used in the context of the forward communication plan (the gather). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5f69fd5594bc26e9b672000fff26be75" name="a5f69fd5594bc26e9b672000fff26be75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f69fd5594bc26e9b672000fff26be75">&#9670;&#160;</a></span>Halo() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace, class BuildType = Export&gt; </div>
<div class="memtemplate">
template&lt;class IdViewType, class RankViewType, typename T = BuildType, std::enable_if_t&lt; std::is_same&lt; T, <a class="el" href="structCabana_1_1Export.html">Export</a> &gt;::value, int &gt; = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Halo.html">Cabana::Halo</a>&lt; MemorySpace, BuildType &gt;::Halo </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_local</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IdViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_ranks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>neighbor_ranks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Neighbor and export rank constructor. Use this when you don't know who you will receiving from - only who you are sending to, but you already know which ranks neighbor each other (i.e. every rank already knows who they will be exporting to and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send and receive from the neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IdViewType</td><td>The container type for the export element ids. This container type can be either a Kokkos View or a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
    <tr><td class="paramname">RankViewType</td><td>The container type for the export element ranks. This container type can be either a Kokkos View or a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
    <tr><td class="paramname">BuildType</td><td>must be <a class="el" href="structCabana_1_1Export.html" title="Export-based tag - default.">Cabana::Export</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The MPI communicator over which the halo is defined.</td></tr>
    <tr><td class="paramname">num_local</td><td>The number of locally-owned elements on this rank.</td></tr>
    <tr><td class="paramname">element_ids</td><td>The local ids of the elements that will be exported to other ranks to be used as ghosts. Element ids may be repeated in this list if they are sent to multiple destinations. Must be the same length as element_ranks. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">element_ranks</td><td>The ranks to which we will send each element in element_ids. In this case each rank must be one of the neighbor ranks. Must be the same length as element_ids. A rank is allowed to send to itself. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">neighbor_ranks</td><td>List of ranks this rank will send to and receive from. This list can include the calling rank. This is effectively a description of the topology of the point-to-point communication plan. The elements in this list must be unique. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c39f13fe61bcfbd22e183785c4c83b6" name="a6c39f13fe61bcfbd22e183785c4c83b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c39f13fe61bcfbd22e183785c4c83b6">&#9670;&#160;</a></span>Halo() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace, class BuildType = Export&gt; </div>
<div class="memtemplate">
template&lt;class IdViewType, class RankViewType, typename T = BuildType, std::enable_if_t&lt; std::is_same&lt; T, <a class="el" href="structCabana_1_1Export.html">Export</a> &gt;::value, int &gt; = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Halo.html">Cabana::Halo</a>&lt; MemorySpace, BuildType &gt;::Halo </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_local</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IdViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_ranks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structCabana_1_1Export.html" title="Export-based tag - default.">Export</a> rank constructor. Use this when you don't know who you will receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IdViewType</td><td>The container type for the export element ids. This container type can be either a Kokkos View or a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
    <tr><td class="paramname">RankViewType</td><td>The container type for the export element ranks. This container type can be either a Kokkos View or a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
    <tr><td class="paramname">BuildType</td><td>must be <a class="el" href="structCabana_1_1Export.html" title="Export-based tag - default.">Cabana::Export</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The MPI communicator over which the halo is defined.</td></tr>
    <tr><td class="paramname">num_local</td><td>The number of locally-owned elements on this rank.</td></tr>
    <tr><td class="paramname">element_ids</td><td>The local ids of the elements that will be sent to other ranks to be used as ghosts. Element ids may be repeated in this list if they are sent to multiple destinations. Must be the same length as element_ranks. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">element_ranks</td><td>The ranks to which we will export each element in element_ids. Must be the same length as element_ids. The neighbor ranks will be determined from this list. A rank is allowed to send to itself. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f69fd5594bc26e9b672000fff26be75" name="a5f69fd5594bc26e9b672000fff26be75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f69fd5594bc26e9b672000fff26be75">&#9670;&#160;</a></span>Halo() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace, class BuildType = Export&gt; </div>
<div class="memtemplate">
template&lt;class IdViewType, class RankViewType, typename T = BuildType, std::enable_if_t&lt; std::is_same&lt; T, <a class="el" href="structCabana_1_1Import.html">Import</a> &gt;::value, int &gt; = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Halo.html">Cabana::Halo</a>&lt; MemorySpace, BuildType &gt;::Halo </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_local</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IdViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_ranks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>neighbor_ranks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Neighbor and import rank constructor. Use this when you don't know who you will sending to - only who you are receiving from, but you already know which ranks neighbor each other (i.e. every rank already knows who they will be exporting to and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send and receive from the neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IdViewType</td><td>The container type for the export element ids. This container type can be either a Kokkos View or a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
    <tr><td class="paramname">RankViewType</td><td>The container type for the export element ranks. This container type can be either a Kokkos View or a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
    <tr><td class="paramname">BuildType</td><td>must be <a class="el" href="structCabana_1_1Import.html" title="Import-based tag.">Cabana::Import</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The MPI communicator over which the halo is defined.</td></tr>
    <tr><td class="paramname">num_local</td><td>The number of locally-owned elements on this rank.</td></tr>
    <tr><td class="paramname">element_ids</td><td>The local ids of the elements that will be imported from other ranks to be used as ghosts. Element ids may be repeated in this list if they are sent to multiple destinations. Must be the same length as element_ranks. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">element_ranks</td><td>The ranks from which we will import each element in element_ids. In this case each rank must be one of the neighbor ranks. Must be the same length as element_ids. A rank is allowed to send to itself. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">neighbor_ranks</td><td>List of ranks this rank will send to and receive from. This list can include the calling rank. This is effectively a description of the topology of the point-to-point communication plan. The elements in this list must be unique. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c39f13fe61bcfbd22e183785c4c83b6" name="a6c39f13fe61bcfbd22e183785c4c83b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c39f13fe61bcfbd22e183785c4c83b6">&#9670;&#160;</a></span>Halo() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace, class BuildType = Export&gt; </div>
<div class="memtemplate">
template&lt;class IdViewType, class RankViewType, typename T = BuildType, std::enable_if_t&lt; std::is_same&lt; T, <a class="el" href="structCabana_1_1Import.html">Import</a> &gt;::value, int &gt; = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Halo.html">Cabana::Halo</a>&lt; MemorySpace, BuildType &gt;::Halo </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_local</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IdViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;</td>          <td class="paramname"><span class="paramname"><em>element_ranks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structCabana_1_1Import.html" title="Import-based tag.">Import</a> rank constructor. Use this when you don't know which ranks neighbor each other. (i.e. every rank does not already know who they will be exporting to and receiving from) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IdViewType</td><td>The container type for the export element ids. This container type can be either a Kokkos View or a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
    <tr><td class="paramname">RankViewType</td><td>The container type for the export element ranks. This container type can be either a Kokkos View or a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
    <tr><td class="paramname">BuildType</td><td>must be <a class="el" href="structCabana_1_1Import.html" title="Import-based tag.">Cabana::Import</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The MPI communicator over which the halo is defined.</td></tr>
    <tr><td class="paramname">num_local</td><td>The number of locally-owned elements on this rank.</td></tr>
    <tr><td class="paramname">element_ids</td><td>The local ids of the elements that will be imported from other ranks to be used as ghosts. Element ids may be repeated in this list if they are sent to multiple destinations. Must be the same length as element_ranks. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">element_ranks</td><td>The ranks from which we will import each element in element_ids. In this case each rank must be one of the neighbor ranks. Must be the same length as element_ids. A rank is allowed to send to itself. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a20a2f092117288f3aff7d93b016dd6e7" name="a20a2f092117288f3aff7d93b016dd6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a2f092117288f3aff7d93b016dd6e7">&#9670;&#160;</a></span>numGhost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace, class BuildType = Export&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCabana_1_1Halo.html">Cabana::Halo</a>&lt; MemorySpace, BuildType &gt;::numGhost </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of ghost elements this rank. Use this to resize a data structure for scatter/gather operations. For use with scatter gather, a data structure should be of size <a class="el" href="#a6a7fa1e057f65089995a01895283f4b2" title="Get the number of elements locally owned by this rank.">numLocal()</a> + <a class="el" href="#a20a2f092117288f3aff7d93b016dd6e7" title="Get the number of ghost elements this rank. Use this to resize a data structure for scatter/gather op...">numGhost()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of ghosted elements on this rank. </dd></dl>

</div>
</div>
<a id="a6a7fa1e057f65089995a01895283f4b2" name="a6a7fa1e057f65089995a01895283f4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7fa1e057f65089995a01895283f4b2">&#9670;&#160;</a></span>numLocal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemorySpace, class BuildType = Export&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCabana_1_1Halo.html">Cabana::Halo</a>&lt; MemorySpace, BuildType &gt;::numLocal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of elements locally owned by this rank. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements locally owned by this rank. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/src/<a class="el" href="Cabana__Halo_8hpp_source.html">Cabana_Halo.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceCabana.html">Cabana</a></li><li class="navelem"><a class="el" href="classCabana_1_1Halo.html">Halo</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
