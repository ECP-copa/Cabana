<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cabana: Cabana::Halo&lt; DeviceType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cabana
   &#160;<span id="projectnumber">1.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceCabana.html">Cabana</a></li><li class="navelem"><a class="el" href="classCabana_1_1Halo.html">Halo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCabana_1_1Halo-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Cabana::Halo&lt; DeviceType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A communication plan for scattering and gathering of ghosted data.  
 <a href="classCabana_1_1Halo.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Cabana__Halo_8hpp_source.html">Cabana_Halo.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Cabana::Halo&lt; DeviceType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classCabana_1_1Halo__inherit__graph.png" border="0" usemap="#aCabana_1_1Halo_3_01DeviceType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aCabana_1_1Halo_3_01DeviceType_01_4_inherit__map" id="aCabana_1_1Halo_3_01DeviceType_01_4_inherit__map">
<area shape="rect" title="A communication plan for scattering and gathering of ghosted data." alt="" coords="6,95,202,121"/>
<area shape="rect" href="classCabana_1_1CommunicationPlan.html" title="Communication plan base class." alt="" coords="5,5,203,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Cabana::Halo&lt; DeviceType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classCabana_1_1Halo__coll__graph.png" border="0" usemap="#aCabana_1_1Halo_3_01DeviceType_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aCabana_1_1Halo_3_01DeviceType_01_4_coll__map" id="aCabana_1_1Halo_3_01DeviceType_01_4_coll__map">
<area shape="rect" title="A communication plan for scattering and gathering of ghosted data." alt="" coords="6,95,202,121"/>
<area shape="rect" href="classCabana_1_1CommunicationPlan.html" title="Communication plan base class." alt="" coords="5,5,203,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab9bcdf50034fdd817cb41e71a08b8140"><td class="memTemplParams" colspan="2">template&lt;class IdViewType , class RankViewType &gt; </td></tr>
<tr class="memitem:ab9bcdf50034fdd817cb41e71a08b8140"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Halo.html#ab9bcdf50034fdd817cb41e71a08b8140">Halo</a> (MPI_Comm <a class="el" href="classCabana_1_1CommunicationPlan.html#a092a7b336e78855a4bf4a6e21577f8d4">comm</a>, const std::size_t num_local, const IdViewType &amp;element_export_ids, const RankViewType &amp;element_export_ranks, const std::vector&lt; int &gt; &amp;neighbor_ranks)</td></tr>
<tr class="memdesc:ab9bcdf50034fdd817cb41e71a08b8140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor and export rank constructor. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be exporting to and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send and receive from the neighbors.  <a href="classCabana_1_1Halo.html#ab9bcdf50034fdd817cb41e71a08b8140">More...</a><br /></td></tr>
<tr class="separator:ab9bcdf50034fdd817cb41e71a08b8140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd40df99504d9e45263036b724652b11"><td class="memTemplParams" colspan="2">template&lt;class IdViewType , class RankViewType &gt; </td></tr>
<tr class="memitem:acd40df99504d9e45263036b724652b11"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1Halo.html#acd40df99504d9e45263036b724652b11">Halo</a> (MPI_Comm <a class="el" href="classCabana_1_1CommunicationPlan.html#a092a7b336e78855a4bf4a6e21577f8d4">comm</a>, const std::size_t num_local, const IdViewType &amp;element_export_ids, const RankViewType &amp;element_export_ranks)</td></tr>
<tr class="memdesc:acd40df99504d9e45263036b724652b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export rank constructor. Use this when you don't know who you will receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first.  <a href="classCabana_1_1Halo.html#acd40df99504d9e45263036b724652b11">More...</a><br /></td></tr>
<tr class="separator:acd40df99504d9e45263036b724652b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5046e216f82ee74086c8fd6f5255a3fd"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Halo.html#a5046e216f82ee74086c8fd6f5255a3fd">numLocal</a> () const</td></tr>
<tr class="memdesc:a5046e216f82ee74086c8fd6f5255a3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements locally owned by this rank.  <a href="classCabana_1_1Halo.html#a5046e216f82ee74086c8fd6f5255a3fd">More...</a><br /></td></tr>
<tr class="separator:a5046e216f82ee74086c8fd6f5255a3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658af06caa6eb2ae02bcc29011e9b9f0"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1Halo.html#a658af06caa6eb2ae02bcc29011e9b9f0">numGhost</a> () const</td></tr>
<tr class="memdesc:a658af06caa6eb2ae02bcc29011e9b9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ghost elements this rank. Use this to resize a data structure for scatter/gather operations. For use with scatter gather, a data structure should be of size <a class="el" href="classCabana_1_1Halo.html#a5046e216f82ee74086c8fd6f5255a3fd" title="Get the number of elements locally owned by this rank.">numLocal()</a> + <a class="el" href="classCabana_1_1Halo.html#a658af06caa6eb2ae02bcc29011e9b9f0" title="Get the number of ghost elements this rank. Use this to resize a data structure for scatter/gather op...">numGhost()</a>.  <a href="classCabana_1_1Halo.html#a658af06caa6eb2ae02bcc29011e9b9f0">More...</a><br /></td></tr>
<tr class="separator:a658af06caa6eb2ae02bcc29011e9b9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classCabana_1_1CommunicationPlan"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classCabana_1_1CommunicationPlan')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan&lt; DeviceType &gt;</a></td></tr>
<tr class="memitem:a06e29072acf141f5da2aa73c27443f94 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a06e29072acf141f5da2aa73c27443f94">CommunicationPlan</a> (MPI_Comm <a class="el" href="classCabana_1_1CommunicationPlan.html#a092a7b336e78855a4bf4a6e21577f8d4">comm</a>)</td></tr>
<tr class="memdesc:a06e29072acf141f5da2aa73c27443f94 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classCabana_1_1CommunicationPlan.html#a06e29072acf141f5da2aa73c27443f94">More...</a><br /></td></tr>
<tr class="separator:a06e29072acf141f5da2aa73c27443f94 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092a7b336e78855a4bf4a6e21577f8d4 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memItemLeft" align="right" valign="top"><a id="a092a7b336e78855a4bf4a6e21577f8d4"></a>
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a092a7b336e78855a4bf4a6e21577f8d4">comm</a> () const</td></tr>
<tr class="memdesc:a092a7b336e78855a4bf4a6e21577f8d4 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MPI communicator. <br /></td></tr>
<tr class="separator:a092a7b336e78855a4bf4a6e21577f8d4 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5847e10e2ccc2acd50058d31ca76c371 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a5847e10e2ccc2acd50058d31ca76c371">numNeighbor</a> () const</td></tr>
<tr class="memdesc:a5847e10e2ccc2acd50058d31ca76c371 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of neighbor ranks that this rank will communicate with.  <a href="classCabana_1_1CommunicationPlan.html#a5847e10e2ccc2acd50058d31ca76c371">More...</a><br /></td></tr>
<tr class="separator:a5847e10e2ccc2acd50058d31ca76c371 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6daf10233f0724f92c7a1d1b584c3f inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#afd6daf10233f0724f92c7a1d1b584c3f">neighborRank</a> (const int neighbor) const</td></tr>
<tr class="memdesc:afd6daf10233f0724f92c7a1d1b584c3f inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a local neighbor id get its rank in the MPI communicator.  <a href="classCabana_1_1CommunicationPlan.html#afd6daf10233f0724f92c7a1d1b584c3f">More...</a><br /></td></tr>
<tr class="separator:afd6daf10233f0724f92c7a1d1b584c3f inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821815e33487add9bbe38f61aa5ce133 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a821815e33487add9bbe38f61aa5ce133">numExport</a> (const int neighbor) const</td></tr>
<tr class="memdesc:a821815e33487add9bbe38f61aa5ce133 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements this rank will export to a given neighbor.  <a href="classCabana_1_1CommunicationPlan.html#a821815e33487add9bbe38f61aa5ce133">More...</a><br /></td></tr>
<tr class="separator:a821815e33487add9bbe38f61aa5ce133 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3bbc1074cf677e7b73146fdcfe1657 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a9f3bbc1074cf677e7b73146fdcfe1657">totalNumExport</a> () const</td></tr>
<tr class="memdesc:a9f3bbc1074cf677e7b73146fdcfe1657 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of exports this rank will do.  <a href="classCabana_1_1CommunicationPlan.html#a9f3bbc1074cf677e7b73146fdcfe1657">More...</a><br /></td></tr>
<tr class="separator:a9f3bbc1074cf677e7b73146fdcfe1657 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c6f777ad2ab14bfb0e95e7cf5883d7 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a89c6f777ad2ab14bfb0e95e7cf5883d7">numImport</a> (const int neighbor) const</td></tr>
<tr class="memdesc:a89c6f777ad2ab14bfb0e95e7cf5883d7 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements this rank will import from a given neighbor.  <a href="classCabana_1_1CommunicationPlan.html#a89c6f777ad2ab14bfb0e95e7cf5883d7">More...</a><br /></td></tr>
<tr class="separator:a89c6f777ad2ab14bfb0e95e7cf5883d7 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4453fb4235b63ed9123647755ea6e3b inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#af4453fb4235b63ed9123647755ea6e3b">totalNumImport</a> () const</td></tr>
<tr class="memdesc:af4453fb4235b63ed9123647755ea6e3b inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of imports this rank will do.  <a href="classCabana_1_1CommunicationPlan.html#af4453fb4235b63ed9123647755ea6e3b">More...</a><br /></td></tr>
<tr class="separator:af4453fb4235b63ed9123647755ea6e3b inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f40f145fa90fdb2ae2049549675dd0 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a73f40f145fa90fdb2ae2049549675dd0">exportSize</a> () const</td></tr>
<tr class="memdesc:a73f40f145fa90fdb2ae2049549675dd0 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of export elements.  <a href="classCabana_1_1CommunicationPlan.html#a73f40f145fa90fdb2ae2049549675dd0">More...</a><br /></td></tr>
<tr class="separator:a73f40f145fa90fdb2ae2049549675dd0 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244cc72428af0c610a8752f957136ac7 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memItemLeft" align="right" valign="top">Kokkos::View&lt; std::size_t *, <a class="el" href="classCabana_1_1CommunicationPlan.html#a166fe8d6270e0d3224d4298bc4b4bb6b">device_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a244cc72428af0c610a8752f957136ac7">getExportSteering</a> () const</td></tr>
<tr class="memdesc:a244cc72428af0c610a8752f957136ac7 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the steering vector for the exports.  <a href="classCabana_1_1CommunicationPlan.html#a244cc72428af0c610a8752f957136ac7">More...</a><br /></td></tr>
<tr class="separator:a244cc72428af0c610a8752f957136ac7 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1276eca1bba9971bb3c01720bdc1ed66 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:a1276eca1bba9971bb3c01720bdc1ed66 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlan.html#afeb0f589e39614e6bd75bd834e6cd4ef">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlan.html#a166fe8d6270e0d3224d4298bc4b4bb6b">device_type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a1276eca1bba9971bb3c01720bdc1ed66">createFromExportsAndTopology</a> (const ViewType &amp;element_export_ranks, const std::vector&lt; int &gt; &amp;neighbor_ranks)</td></tr>
<tr class="memdesc:a1276eca1bba9971bb3c01720bdc1ed66 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor and export rank creator. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be sending and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send to and receive from the neighbors.  <a href="classCabana_1_1CommunicationPlan.html#a1276eca1bba9971bb3c01720bdc1ed66">More...</a><br /></td></tr>
<tr class="separator:a1276eca1bba9971bb3c01720bdc1ed66 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe26fa589ec060f526d001f94ae90df9 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplParams" colspan="2">template&lt;class ViewType &gt; </td></tr>
<tr class="memitem:abe26fa589ec060f526d001f94ae90df9 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">Kokkos::View&lt; <a class="el" href="classCabana_1_1CommunicationPlan.html#afeb0f589e39614e6bd75bd834e6cd4ef">size_type</a> *, <a class="el" href="classCabana_1_1CommunicationPlan.html#a166fe8d6270e0d3224d4298bc4b4bb6b">device_type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#abe26fa589ec060f526d001f94ae90df9">createFromExportsOnly</a> (const ViewType &amp;element_export_ranks)</td></tr>
<tr class="memdesc:abe26fa589ec060f526d001f94ae90df9 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export rank creator. Use this when you don't know who you will receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first.  <a href="classCabana_1_1CommunicationPlan.html#abe26fa589ec060f526d001f94ae90df9">More...</a><br /></td></tr>
<tr class="separator:abe26fa589ec060f526d001f94ae90df9 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8281c28110645e3a8af293a1984917 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplParams" colspan="2">template&lt;class PackViewType , class RankViewType &gt; </td></tr>
<tr class="memitem:a8a8281c28110645e3a8af293a1984917 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a8a8281c28110645e3a8af293a1984917">createExportSteering</a> (const PackViewType &amp;neighbor_ids, const RankViewType &amp;element_export_ranks)</td></tr>
<tr class="memdesc:a8a8281c28110645e3a8af293a1984917 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the export steering vector.  <a href="classCabana_1_1CommunicationPlan.html#a8a8281c28110645e3a8af293a1984917">More...</a><br /></td></tr>
<tr class="separator:a8a8281c28110645e3a8af293a1984917 inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0809d8f8ef5a6594f00cf7b1ed50fec inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplParams" colspan="2">template&lt;class PackViewType , class RankViewType , class IdViewType &gt; </td></tr>
<tr class="memitem:aa0809d8f8ef5a6594f00cf7b1ed50fec inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#aa0809d8f8ef5a6594f00cf7b1ed50fec">createExportSteering</a> (const PackViewType &amp;neighbor_ids, const RankViewType &amp;element_export_ranks, const IdViewType &amp;element_export_ids)</td></tr>
<tr class="memdesc:aa0809d8f8ef5a6594f00cf7b1ed50fec inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the export steering vector.  <a href="classCabana_1_1CommunicationPlan.html#aa0809d8f8ef5a6594f00cf7b1ed50fec">More...</a><br /></td></tr>
<tr class="separator:aa0809d8f8ef5a6594f00cf7b1ed50fec inherit pub_methods_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classCabana_1_1CommunicationPlan"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classCabana_1_1CommunicationPlan')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classCabana_1_1CommunicationPlan.html">Cabana::CommunicationPlan&lt; DeviceType &gt;</a></td></tr>
<tr class="memitem:a166fe8d6270e0d3224d4298bc4b4bb6b inherit pub_types_classCabana_1_1CommunicationPlan"><td class="memItemLeft" align="right" valign="top"><a id="a166fe8d6270e0d3224d4298bc4b4bb6b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a166fe8d6270e0d3224d4298bc4b4bb6b">device_type</a> = DeviceType</td></tr>
<tr class="memdesc:a166fe8d6270e0d3224d4298bc4b4bb6b inherit pub_types_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device type. <br /></td></tr>
<tr class="separator:a166fe8d6270e0d3224d4298bc4b4bb6b inherit pub_types_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb04f782ff2aa705075d56d758c4f678 inherit pub_types_classCabana_1_1CommunicationPlan"><td class="memItemLeft" align="right" valign="top"><a id="adb04f782ff2aa705075d56d758c4f678"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#adb04f782ff2aa705075d56d758c4f678">memory_space</a> = typename device_type::memory_space</td></tr>
<tr class="memdesc:adb04f782ff2aa705075d56d758c4f678 inherit pub_types_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory space. <br /></td></tr>
<tr class="separator:adb04f782ff2aa705075d56d758c4f678 inherit pub_types_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0dc771fcf7c9015a6f935e9621725a inherit pub_types_classCabana_1_1CommunicationPlan"><td class="memItemLeft" align="right" valign="top"><a id="a0f0dc771fcf7c9015a6f935e9621725a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#a0f0dc771fcf7c9015a6f935e9621725a">execution_space</a> = typename device_type::execution_space</td></tr>
<tr class="memdesc:a0f0dc771fcf7c9015a6f935e9621725a inherit pub_types_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution space. <br /></td></tr>
<tr class="separator:a0f0dc771fcf7c9015a6f935e9621725a inherit pub_types_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb0f589e39614e6bd75bd834e6cd4ef inherit pub_types_classCabana_1_1CommunicationPlan"><td class="memItemLeft" align="right" valign="top"><a id="afeb0f589e39614e6bd75bd834e6cd4ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCabana_1_1CommunicationPlan.html#afeb0f589e39614e6bd75bd834e6cd4ef">size_type</a> = typename memory_space::size_type</td></tr>
<tr class="memdesc:afeb0f589e39614e6bd75bd834e6cd4ef inherit pub_types_classCabana_1_1CommunicationPlan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type. <br /></td></tr>
<tr class="separator:afeb0f589e39614e6bd75bd834e6cd4ef inherit pub_types_classCabana_1_1CommunicationPlan"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class DeviceType&gt;<br />
class Cabana::Halo&lt; DeviceType &gt;</h3>

<p>A communication plan for scattering and gathering of ghosted data. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DeviceType</td><td>Device type for which the data for this class will be allocated and where parallel execution occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>The halo allows for scatter and gather operations between locally-owned and ghosted data. All data in the <a class="el" href="classCabana_1_1Halo.html" title="A communication plan for scattering and gathering of ghosted data.">Halo</a> (e.g. export and import data) is from the point of view of the forward <em>GATHER</em> operation such that, for example, the number of exports is the number of exports in the gather and the number of imports is the number of imports in the gather. The reverse <em>SCATTER</em> operation sends the ghosted data back the the uniquely-owned decomposition and resolves collisions. Based on input for the forward communication plan (where local data will be sent) the local number of ghosts is computed. Some nomenclature:</p>
<p>Export - the local data we uniquely own that we will send to other ranks for those ranks to be used as ghosts. Export is used in the context of the forward communication plan (the gather).</p>
<p>Import - the ghost data that we get from other ranks. The rank we get a ghost from is the unique owner of that data. Import is used in the context of the forward communication plan (the gather). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab9bcdf50034fdd817cb41e71a08b8140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bcdf50034fdd817cb41e71a08b8140">&#9670;&nbsp;</a></span>Halo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType &gt; </div>
<div class="memtemplate">
template&lt;class IdViewType , class RankViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Halo.html">Cabana::Halo</a>&lt; DeviceType &gt;::<a class="el" href="classCabana_1_1Halo.html">Halo</a> </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IdViewType &amp;&#160;</td>
          <td class="paramname"><em>element_export_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;&#160;</td>
          <td class="paramname"><em>element_export_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_ranks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Neighbor and export rank constructor. Use this when you already know which ranks neighbor each other (i.e. every rank already knows who they will be exporting to and receiving from) as it will be more efficient. In this case you already know the topology of the point-to-point communication but not how much data to send and receive from the neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IdViewType</td><td>The container type for the export element ids. This container type can be either a Kokkos View or a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
    <tr><td class="paramname">RankViewType</td><td>The container type for the export element ranks. This container type can be either a Kokkos View or a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The MPI communicator over which the halo is defined.</td></tr>
    <tr><td class="paramname">num_local</td><td>The number of locally-owned elements on this rank.</td></tr>
    <tr><td class="paramname">element_export_ids</td><td>The local ids of the elements that will be exported to other ranks to be used as ghosts. Element ids may be repeated in this list if they are sent to multiple destinations. Must be the same length as element_export_ranks. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">element_export_ranks</td><td>The ranks to which we will send each element in element_export_ids. In this case each rank must be one of the neighbor ranks. Must be the same length as element_export_ids. A rank is allowed to send to itself. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">neighbor_ranks</td><td>List of ranks this rank will send to and receive from. This list can include the calling rank. This is effectively a description of the topology of the point-to-point communication plan. The elements in this list must be unique.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function completely updates the state of this object and invalidates the previous state. </dd></dl>

</div>
</div>
<a id="acd40df99504d9e45263036b724652b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd40df99504d9e45263036b724652b11">&#9670;&nbsp;</a></span>Halo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType &gt; </div>
<div class="memtemplate">
template&lt;class IdViewType , class RankViewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCabana_1_1Halo.html">Cabana::Halo</a>&lt; DeviceType &gt;::<a class="el" href="classCabana_1_1Halo.html">Halo</a> </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IdViewType &amp;&#160;</td>
          <td class="paramname"><em>element_export_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankViewType &amp;&#160;</td>
          <td class="paramname"><em>element_export_ranks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export rank constructor. Use this when you don't know who you will receiving from - only who you are sending to. This is less efficient than if we already knew who our neighbors were because we have to determine the topology of the point-to-point communication first. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IdViewType</td><td>The container type for the export element ids. This container type can be either a Kokkos View or a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
    <tr><td class="paramname">RankViewType</td><td>The container type for the export element ranks. This container type can be either a Kokkos View or a <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> <a class="el" href="classCabana_1_1Slice.html" title="A slice of an array-of-structs-of-arrays with data access to a single multidimensional member.">Slice</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The MPI communicator over which the halo is defined.</td></tr>
    <tr><td class="paramname">num_local</td><td>The number of locally-owned elements on this rank.</td></tr>
    <tr><td class="paramname">element_export_ids</td><td>The local ids of the elements that will be sent to other ranks to be used as ghosts. Element ids may be repeated in this list if they are sent to multiple destinations. Must be the same length as element_export_ranks. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan.</td></tr>
    <tr><td class="paramname">element_export_ranks</td><td>The ranks to which we will export each element in element_export_ids. Must be the same length as element_export_ids. The neighbor ranks will be determined from this list. A rank is allowed to send to itself. The input is expected to be a Kokkos view or <a class="el" href="namespaceCabana.html" title="Core: particle data structures and algorithms.">Cabana</a> slice in the same memory space as the communication plan.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function completely updates the state of this object and invalidates the previous state. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a658af06caa6eb2ae02bcc29011e9b9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658af06caa6eb2ae02bcc29011e9b9f0">&#9670;&nbsp;</a></span>numGhost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCabana_1_1Halo.html">Cabana::Halo</a>&lt; DeviceType &gt;::numGhost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of ghost elements this rank. Use this to resize a data structure for scatter/gather operations. For use with scatter gather, a data structure should be of size <a class="el" href="classCabana_1_1Halo.html#a5046e216f82ee74086c8fd6f5255a3fd" title="Get the number of elements locally owned by this rank.">numLocal()</a> + <a class="el" href="classCabana_1_1Halo.html#a658af06caa6eb2ae02bcc29011e9b9f0" title="Get the number of ghost elements this rank. Use this to resize a data structure for scatter/gather op...">numGhost()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of ghosted elements on this rank. </dd></dl>

</div>
</div>
<a id="a5046e216f82ee74086c8fd6f5255a3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5046e216f82ee74086c8fd6f5255a3fd">&#9670;&nbsp;</a></span>numLocal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCabana_1_1Halo.html">Cabana::Halo</a>&lt; DeviceType &gt;::numLocal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of elements locally owned by this rank. </p>
<dl class="section return"><dt>Returns</dt><dd>THe number of elements locally owned by this rank. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/src/<a class="el" href="Cabana__Halo_8hpp_source.html">Cabana_Halo.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
